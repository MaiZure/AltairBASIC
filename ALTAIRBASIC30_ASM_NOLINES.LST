SEARCH  MCS808                  ;THE UNIVERSAL FILE
SUBTTL  COMMON FILE
SALL
LENGTH==2                       ; 0 MEANS 4K, 1 MEANS 8K, 2 MEANS 12K
REALIO==1
CASSW==0                        ;CASSETTE SWITCH (CSAVE,CLOAD)
PURE==0                         ;ON FOR PURE CODE
LPTSW==0
DSKFUN==0                       ;ON TO READ/WRITE
CONSSW==0
CLMWID==^D14                    ;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
RAMBOT=^O20000                  ;BOTTOM LOCATION OF RAM FOR PURE SWITCH
CONTRW==1                       ;ALLOW ^O
IFE     REALIO,<
        LPTSW==0                ;SIMULATOR DEFAULTS
        CASSW==0
        CONSSW==0
        DSKFUN==0
        CONTRW==0>
IFE     LENGTH,<
        EXTFNC==0               ;ON MEANS EXTENDED FUNCTIONS
        MULDIM==0               ;ON MEANS MULTIPLE DIMENSIONED ARRAYS ALLOWED
        STRING==0               ;ON MEANS STRINGS ALLOWED
        CASSW==0
        LPTSW==0
        DSKFUN==0
        CONSSW==0
        CONTRW==0>
IFE     LENGTH-1,<
        EXTFUN==1
        MULDIM==1
        STRING==1>
IFE     LENGTH-2,<
        EXTFUN==1
        MULDIM==1
        STRING==1>
DEFINE  SYNCHK(A),<RST  1
                A>
DEFINE  CHRGET,<RST     2>
DEFINE  OUTCHR,<RST     3
DEFINE  COMPAR,<RST     4
DEFINE  FSIGN,<RST      5
DEFINE  PUSHM,<RST      6
DEFINE  PUSHFM,<PUSHM
                PUSHM>
DEFINE  ACLRF,<
        ^D13
IFN     STRING,<^D10>>
DEFINE  PUSHR,<
        PUSH    D
        PUSH    B>
DEFINE  POPR,<
        POP     B
        POP     D>
DEFINE  MOVRI(B,C,D,E),<
        XWD     ^O1000,^O001    ;; "LXI B"
        EXP     C
        EXP     B
        XWD     ^O1000,^O021    ;; "LXI D
        EXP     E
        EXP     D>
IF1,<
IFE     LENGTH,<PRINTX  /SMALL/>
IFE     LENGTH-1,<PRINTX        /MEDIUM/>
IFE     LENGTH-2,<PRINTX        /BIG
IFE     REALIO,<PRINTX  /SIMULATE/>
IFN     REALIO,<PRINTX  /ON MACHINE/>
IFN     CASSW,<PRINTX   /CASSETTE/>
IFN     PURE,<PRINTX    /PURE/>
IFN     LPTSW,<PRINTX   /LPT/>
IFN     DSKFUN,<PRINTX  /DISK/>
IFN     CONSSW,<PRINTX  /CONSOLE/>>
PAGE
SUBTTL  VERSION 3.0 -- MORE FEATURES TO GO
TITLE   BASIC MCS 8080  GATES/ALLEN/DAVIDOFF
IFNDEF  LENGTH,<PRINTX !!! MUST HAVE COM !!!
        END>
MCSSIM(START)
COMMENT *
--------- ---- -- ---- ----- --- ---- -----
COPYRIGHT 1975 BY BILL GATES AND PAUL ALLEN
--------- ---- -- ---- ----- --- ---- -----
ORIGINALLY WRITTEN ON THE PDP-10 FROM
FEBRUARY 9 TO  APRIL 9
BILL GATES WROTE THE RUNTIME STUFF.
PAUL ALLEN WROTE THE NON-RUNTIME STUFF.
MONTE DAVIDOFF WROTE THE MATH PACKAGE.
THINGS TO DO:
GOSUB / INPUT BUG  (BUF SMASH)
PRINT PUNCTUATION MANDATORY
MULTIPLE LET
RESTART AT 0 SHOULD  GO THROUGH  STKINI
USER DEFINED FUNCTIONS(MULTI-ARG,MULTI-LINE,STRINGS)
MAKE STACK BOUNDARY STUFF EXACT
PUNCH,RENUMBER...
INLINE CONSTANT CONVERSION--MAKE IT WORK
*
RADIX 10                        ;THROUGHOUT
.P==0                           ;FOR SIMULATOR FIXUPS
NUMLEV==17+LENGTH*2             ;NUMBER OF STACK LEVELS RESERVED
                                ;WITH AN EXPLICIT CALL TO GETSTK
LPTLEN==72                      ;WIDTH OF LINE-PRINTER
LINLEN==72                      ;TELETYPE LINE LENGTH
BUFLEN==72                      ;INPUT BUFFER SIZE
STRSIZ==4
IFE     LENGTH-2<STRSIZ==3>
NUMTMP==3                       ;NUMBER OF STRING TEMPORARIES
IFE     LENGTH-2,<NUMTMP=5>
CR==13
CONTW==15                       ;CHARACTER TO SUPRESS OUTPUT
ODONE==128                      ;BIT FOR OUTPUT DONE
IDONE==1                        ;BIT FOR INPUT DONE
TTOCHN==1                       ;TELETYPE OUTPUT CHANNEL
TTICHN==1                       ;TELETYPE INPUT CHANNEL
LISTEN==0                       ;ON MEANS LISTEN FOR ^C
FUNCTS==1                       ;ON MEANS USER FUNCTIONS ALLOWED
                                ;! CANNOT BE ON WITH LENGTH=0 (SUBFLG)
IFN     REALIO,<
LISTEN==1>
IFE     LENGTH,<
FUNCTS==0>
INTERNAL        .C1,BUF,READY,REASON,SNERR,EMERR,REPINI
INTERNAL        STREND,CURLIN,DV0ERR,ERROV
IFN     REALIO,<
INTERNAL        CNLCA1,CNLCA2,CNLCA3>
IFN     EXTFNC,<INTERNAL        ATNFIX,COSFIX,SINFIX,TANFIX
EXTERNAL        FPWR,EXP>
EXTERNAL        QINT,ZERO,MOVE,FOUT,FIN,FCOMP,FADD,PUSHF,INT,INIT
EXTERNAL        MOVFR,MOVRF,MOVRM,INPRT,LINPRT
EXTERNAL        MOVFM,MOVMF,TSTACK,FLOATRI,FADDS
INTERNAL        ILLFUN,FAC,FACLD,TXTTAB,STROUT,SCRTCH
EXTERNAL        INRART,NEG,FLOAT
INTERNAL        OUTDO,STROUI
INTERNAL        STKTOP,ERROR,FCERR
IFN     STRING,<
INTERNAL         VALTYP,TEMPPT
INTERNAL        TEMPST,STRLIT
IFN     LENGTH-2,<
INTERNAL        TMERR>
INTERNAL        MEMZIS,FRETOP
EXTERNAL        SIGNS>
INTERNAL        FBUFFR,MINUTK,PLUSTK,CRDO,LINGET,INTXT,QINLIN
IFN     MULDIM,<INTERNAL        BSERR>
IFN     MULDIM,<EXTERNAL        UMULT>
IFE     LENGTH,<INTERNAL        RNDFIX,SQRFIX,SINFIX>
INTERNAL        SIGN
EXTERNAL        SIGNC,POPHRT
IFN     CONTRW,<
INTERNAL        CNTWFL>
IFN     LPTSW,<
        INTERNAL        LPTPOS,PRTFLG>
IFE     LENGTH-2,<
EXTERNAL        CONSIH,VMOVFA,VMOVAF,ISIGN,FPWRQ,CONIA,GETBCD,VSIGN
EXTERNAL        VMOVMF,VMOVFM,FRCINT,FRCSNG,FRCDBL,VNEG,PUFOUT,DCXBRT,IADD
EXTERNAL        ISUB,IMULT,IDIV,ICOMP,INEG,DADD,DSUB,DMULT,DDIV,DCOMP,VINT
EXTERNAL        TMERR,VMOVE,VALINT,VALSNG,FRCSTR,CHKSTR,MAKINT
INTERNAL        DFACLO,ARG,ARGLO,VALTYP,ERRTM,TEMP2,TEMP3,GETYPE>
PAGE
SUBTTL  SOME EXPLANATION
COMMENT *
ALTAIR BASIC CONFIGURES MEMORY AS FOLLOWS:
LOW LOCATIONS
        RST     SUBROUTINES
                0       STARTUP
                        INITIALLY A JMP TO THE INITIALIZATION CODE
                        BUT CHANGED TO A JMP TO READY.
                        RESTARTING THE MACHINE AT 0 DURING PROGRAM
                        EXECUTION CAN LEAVE THINGS MESSED UP.
                1       SYNCHK
                        A CHECK IS MADE TO MAKE SURE THE
                        CHARACTER POINTER POINTS AT A SPECIFIC
                        CHARACTER. IF NOT THE "SYNTAX ERROR"
                        ROUTINE IS CALLED. IF SO,
                        THE CHRGET RST IS DROPPED INTO SO
                        THE CHARACTER AFTER THE MATCHED
                        ONE WILL BE PUT IN [A] AND
                        THE CONDITION CODES WILL REFLECT THIS
                        EXAMPLE: SYNCHK THENTK (THE MATCH CHARACTER IS
                        GIVEN IN THE LOCATION AFTER THE RST)
                        WOULD CHECK TO MAKE SURE [H,L] POINTED TO A THENTK
                        AND IF SO FETCH THE NEXT CHARACTER INTO [A]
                        IF NOT, A "SYNTAX ERROR" WOULD BE GIVEN.
                2       CHRGET
                        USING [H,L] AS THE TEXT POINTER
                        THE TEXT POINTER IS INCREMENTED
                        AND THE NEXT CHARACTER IS FETCHED INTO [A]
                        IF THE CHARACTER IS A " " IT IS SKIPPED
                        OVER AND THE NEXT CHARACTER IS FETCHED,
                        THE STATEMENT TERMINATIONS ":" AND 0
                        LEAVE THE ZERO FLAG SET.
                        THE NUMERICS "0" THROUGH "9" LEAVE THE CARRY
                        FLAG SET. THE CURRENT CHARACTER CAN BE
                        REFETCHED INTO [A] BY DOING A MOV A,M.
                        IF THE CONDITION CODES MUST BE SET UP AGAIN
                        DCX H,CHRGET WILL WORK. IT IS VERY DIFFICULT
                        TO REEXAMINE THE CHARACTER BEFORE THE CURRENT
                        ONE SINCE SPACES MAY BE IN-BETWEEN.
                        DCX H,DCX M,CHRGET WILL NOT ALWAYS WORK.
                3       OUTCHR
                        THE CHARACTER IN [A] IS PRINTED ON
                        THE USER'S TERMINAL. [A] AND THE
                        CONDITION CODES ARE PRESERVED
                4       COMPAR
                        [D,E] AND [H,L] ARE COMPARED AS UNSIGNED
                        DOUBLE-BYTE INTEGERS. CARRY IS SET IF
                        [H,L] IS LESS THAN [D,E]. ZERO IS SET IF THEY
                        ARE EQUAL. [A] IS SMASHED. THE ONLY DEFINITE
                        THING THAT CAN BE SAID ABOUT [A] ON RETURN
                        IS THAT IF THE ZERO FLAG IS SET, [A] WILL
                        EQUAL 0.
                5       FSIGN
                        THE FAC (FLOATING ACCUMULATOR)
                        WHICH IS USED TO STORE NUMERIC RESULTS
                        IS CHECKED TO SEE WHAT SIGN ITS
                        VALUE HAS.
                6       PUSHM
                        A DOUBLE BYTE QUANTITY POINTED
                        TO BY [H,L] IS PUSHED ONTO THE
                        STACK, [B,C] IS SET EQUAL TO THE
                        VALUE PUSHED, [H,L] IS INCREMENTED BY TWO
                7       IN THE 4K VERSION RST 7 IS UNUSED AND THE LOCATIONS
                        ASSOCIATED WITH IT ARE USED TO CONTINUE
                        THE CODE FOR RST 6. IN THE 8K A JMP IS MADE
                        AROUND THE FIRST THREE RST 7 LOCATIONS
                        DURING RST 6 EXECUTION, RST 7 INITIALLY
                        CONTAINS A RET, BUT THE USER CAN CHANGE IT TO
                        A JMP TO AN INTERRUPT SERVICE ROUTINE.
        FUNCTION DISPATCH ADDRESSES
                FUNDSP CONTAINS THE ADDRESSES OF THE
                FUNCTION ROUTINES IN THE ORDER OF THE
                FUNCTION NAMES IN THE CRUNCH LIST.
                THE FUNCTIONS THAT TAKE MORE THAN ONE ARGUMENT
                ARE AT THE END. SEE THE EXPLANATION AT ISFUN.
        THE OPERATOR TABLE
                THE OPTAB TABLE CONTAINS AN OPERATORS PRECEDENCE
                FOLLOWED BY THE ADDRESS OF THE ROUTINE TO PERFORM
                THE OPERATION. THE INDEX INTO THE
                OPERATOR TABLE IS MADE BY SUBTRACTING OFF THE CRUNCH VALUE
                OF THE LOWEST NUMBERED OPERATOR. THE ORDER
                OF OPERATORS IN THE CRUNCH LIST AND IN OPTAB IS IDENTICAL.
                THE PRECEDENCES ARE ARBITRARY,EXCEPT FOR THEIR
                COMPARATIVE SIZES. NOTE THAT THE PRECENDENCE FOR
                UNARY OPERATORS SUCH AS NOT AND NEGATION ARE
                SETUP SPECIALLY WITHOUT USING A TABLE.
        THE RESERVED WORD ON CRUNCH LIST
                WHEN A COMMAND OR PROGRAM LINE IS TYPED IN
                IT IS STORED IN BUF. AS SOON AS THE WHOLE LINE
                HAS BEEN TYPED IN (INLIN RETURNS) CRUNCH IS
                CALLED TO CONVERT ALL RESERVED WORDS TO THEIR
                CRUNCH VALUES, THIS REDUCES THE SIZE OF THE
                PROGRAM AND SPEEDS UP EXECUTION BY ALLOWING
                TABLE DISPATCHES TO PERFORM FUNCTIONS,STATEMENTS,
                AND OPERATIONS. THIS IS BECAUSE ALL THE STATEMENT
                NAMES ARE STORED CONSECUTIVELY IN THE CRUNCH LIST.
                WHEN A MATCH IS FOUND BETWEEN A STRING
                OF CHARACTERS AND A WORD IN THE CRUNCH LIST
                THE ENTIRE TEXT OF THE MATCHED WORD IS TAKEN OUT OF
                THE INPUT LINE AND RESERVED WORD TAKEN IS PUT
                IN ITS PLACE. A RESERVED WORD TOKEN IS ALWAYS EQUAL
                TO OCTAL 200 PLUS THE POSITION OF THE MATCHED WORD
                IN THE CRUNCH LIST.
        STATEMENT DISPATCH ADDRESSES
                WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
                CHARACTER OF THE STATEMENT IS EXAMINED
                TO SEE IF IT IS LESS THAN THE RESERVED
                WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME,
                IF SO, THE "LET" CODE IS CALLED TO
                TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
                OTHERWISE A CHECK IS MADE TO MAKE SURE THE
                RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
                STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
                TO DISPATCH TO IS FETCHED FROM STMDSP (THE STATEMENT
                DISPATCH TABLE) USING THE RESERVED WORD
                NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
                THE TABLE.
        ERROR MESSAGES
                WHEN AN ERROR CONDITION IS DETECTED
                [E] MUST BE SET UP TO INDICATE WHICH ERROR
                MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
                TO ERROR. THE STACK WILL BE RESET AND ALL
                PROGRAM CONTEXT WILL BE LOST. VARIABLES
                VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
                ONLY THE VALUE OF [E] IS IMPORTANT WHEN
                THE BRANCH IS MADE TO ERROR, [E] IS USED AS AN
                INDEX INTO ERRTAB WHICH GIVES THE TWO
                CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
                USER'S TERMINAL.
        IMPURE STORAGE
                ALL TEMPORARIES,FLAGS,POINTERS, THE BUFFER AREA,
                THE FLOATING ACCUMULATOR,AND ANYTHING ELSE THAT
                IS USED TO STORE A CHANGING VALUE SHOULD BE LOCATED
                IN THIS AREA. CARE MUST BE MADE IN MOVING LOCATIONS
                IN THIS AREA SINCE THE JUXTAPOSITION OF TWO LOCATIONS
                IS OFTEN DEPENDED UPON.
        TEXTUAL MESSAGES
                CONSTANT MESSAGES ARE STORED HERE. UNLESS
                THE CODE TO CHECK IF A STRING MUST BE COPIED
                IS CHANGED THESE STRINGS MUST BE STORED ABOVE
                DSCTMP, OR ELSE THEY WILL BE COPIED BEFORE
                THEY ARE PRINTED.
        FNDFOR
                MOST SMALL ROUTINES ARE FAIRLY SIMPLE
                AND ARE DOCUMENTED IN PLACE. FNDFOR IS
                USED FOR FINDING "FOR" ENTRIES ON
                THE STACK. WHENEVER A "FOR" IS EXECUTED AN
                18 BYTE ENTRY IS PUSHED ONTO THE STACK.
                BEFORE THIS IS DONE, HOWEVER, A CHECK
                MUST BE MADE TO SEE IF THERE
                ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
                FOR THE SAME LOOP VARIABLE. IF SO, THAT "FOR" ENTRY
                AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
                ARE ELIMINATED FROM THE STACK. THIS IS SO A
                PROGRAM THAT JUMPS OUT OF THE MIDDLE
                OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
                AND AGAIN WON'T USE UP 18 BYTES OF STACK
                SPACE EVERY TIME. THE "NEXT" CODE ALSO
                CALLS FNDFOR TO SEARCH FOR A "FOR" ENTRY WITH
                THE LOOP VARIABLE IN
                THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
                THE STACK IS RESET. IF NO MATCH IS FOUND A
                "NEXT WITHOUT FOR" ERROR OCCURS. GOSUB EXECUTION
                ALSO PUTS A 6 BYTE ENTRY ON STACK.
                WHEN A RETURN IS EXECUTED FNDFOR IS
                CALLED WITH A VARIABLE POINTER THAT CAN'T
                BE MATCHED. WHEN "FNDFOR" HAS RUN
                THROUGH ALL THE "FOR" ENTRIES ON THE STACK
                IT RETURNS AND THE RETURN CODE MAKES
                SURE THE ENTRY THAT WAS STOPPED
                ON IS A GOSUB ENTRY. THIS ASSURES THAT
                IF YOU GOSUB TO A SECTION OF CODE
                IN WHICH A FOR LOOP IS ENTERED BUT NEVER
                EXITED THE RETURN WILL STILL BE
                ABLE TO FIND THE MOST RECENT
                GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
                "GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
                THE GOSUB ENTRY.
        NON-RUNTIME STUFF
                THE CODE TO INPUT A LINE,CRUNCH IT, GIVE ERRORS,
                FIND SPECIFIC LINE IN THE PROGRAM
                PERFORM A "NEW", "CLEAR", AND "LIST" ARE
                ALL IN THIS AREA. GIVEN THE EXPLANATION OF
                PROGRAM STORAGE GIVEN BELOW THESE ARE
                ALL STRAIGHTFORWARD.
        NEWSTT
                WHENEVER A STATEMENT FINISHED EXECUTION IT
                DOES A "RET" WHICH TAKES
                EXECUTION BACK TO NEWSTT. STATEMENTS THAT
                CREATE OR LOOK AT SEMI-PERMANENT STACK ENTRIES
                MUST GET RID OF THE RETURN ADDRESS OF NEWSTT AND
                JMP TO NEWSTT WHEN DONE. NEWSTT ALWAYS
                CHRGETS THE FIRST CHARACTER AFTER THE STATEMENT
                NAME BEFORE DISPATCHING. WHEN RETURNING
                BACK TO NEWSTT THE ONLY THING THAT
                MUST BE SET UP IS THE TEXT POINTER IN
                [H,L]. NEWSTT WILL CHECK TO MAKE SURE
                [H,L] IS POINTING TO A STATEMENT TERMINATOR.
                IF A STATEMENT SHOULDN'T BE PERFORMED UNLESS
                IT IS PROPERLY FORMATTED (I.E "NEW") IT CAN
                SIMPLY DO A "RNZ" AFTER READING ALL OF
                ITS ARGUMENTS. SINCE THE ZERO FLAG
                BEING OFF INDICATES THERE IS NOT
                A STATEMENT TERMINATOR NEWSTT WILL
                DO THE JMP TO THE "SYNTAX ERROR"
                ROUTINE. IF A STATEMENT SHOULD BE STARTED
                OVER IT CAN DO LHLD TEMP,RET SINCE THE [H,L]
                AT NEWSTT IS ALWAYS STORED IN TEMP. OF COURSE
                CARE MUST TAKEN THAT NO ROUTINE
                THAT SMASHES TEMP HAS BEEN CALLED.
                THE ^C CODE STORES TEMP IN OLDTXT AND CURLIN (THE
                CURRENT LINE NUMBER) IN OLDLIN SINCE THE ^C CHECK
                IS MADE BEFORE THE STATEMENT POINTED TO IS
                EXECUTED. "STOP" AND "END" STORE THE TEXT POINTER
                IN [H,L] WHICH POINTERS AT THEIR TERMINATING
                CHARACTER IN OLDTXT.
        STATEMENT CODE
                THE INDIVIDUAL STATEMENT CODE COMES
                NEXT. THE APPROACH USED IN EXECUTING EACH
                STATEMENT IS DOCUMENTED IN THE STATEMENT CODE
                ITSELF.
        FRMEVL, THE FORMULA EVALUATOR
                GIVEN AN [H,L] POINTING TO THE STARTING
                CHARACTER OF A FORMULA FRMEVL
                EVALUATES THE FORMULATE AND LEAVES
                THE VALUE IN THE FLOATING ACCUMULATOR (FAC).
                [H,L] IS RETURNED POINTING TO THE FIRST CHARACTER
                THAT COULD NOT BE INTERPRETED AS PART OF THE
                FORMULA. THE ALGORITHM USES THE STACK
                TO STORE TEMPORARY RESULTS:
                        0. PUT A DUMMY PRECEDENCE OF ZERO ON
                                THE STACK.
                        1. READ LEXEME (CONSTANT,FUNCTION,
                                VARIABLE,FORMULA IN PARENS)
                                AND TAKE THE LAST PRECEDENCE VALUE
                                OFF THE STACK
                        2. SEE IF THE NEXT CHARACTER IS AN OPERATOR
                                IF NOT,RETURN. THIS MAY CAUSE
                                OPERATOR APPLICATION OR AN ACTUAL
                                RETURN FROM FRMEVL
                                AND COMPARE IT TO THE PRECEDENCE
                                OF THE LAST OPERATOR ON THE STACK
                        4. IF = OR LESS REMEMBER THE TEXT
                                POINTER AT THE START OF THIS OPERATOR
                                AND DO A RETURN TO CAUSE
                                APPLICATION OF THE LAST OPERATOR.
                                EVENTUALLY RETURN TO STEP 2
                                BY RETURNING TO RETAOP.
                        5. IF GREATER PUT THE LAST PRECEDENCE
                                BACK ON, SAVE THE CURRENT
                                TEMPORARY RESULT, OPERATOR ADDRESS
                                AND PRECEDENCE AND RETURN TO STEP 1.
                RELATIONAL OPERATORS ARE ALL HANDLED THROUGH
                A COMMON ROUTINE. SPECIAL
                CARE IS TAKEN TO DETECT TYPE MISMATCHES SUCH AS 3+"F"
        EVAL -- THE ROUTINE TO READ A LEXEME
                EVAL CHECKS FOR THE DIFFERENT TYPES OF
                ENTITIES IT IS SUPPOSED TO DETECT.
                LEADING PLUSES ARE IGNORED,
                DIGITS AND "." CAUSE FIN (FLOATING INPUT)
                TO BE CALLED. FUNCTION NAMES CAUSE THE
                FORMULA INSIDE THE PARENTHESES TO BE EVALUATED
                AND THE FUNCTION ROUTINE TO BE CALLED. VARIABLE
                NAMES CAUSE PTRGET TO BE CALLED TO GET A POINTER
                TO THE VALUE, AND THEN THE VALUE IS PUT INTO
                THE FAC. AN OPEN PARENTHESIS CAUSES FRMEVL
                TO BE CALLED (RECURSIVELY), AND THE ")" TO
                BE CHECKED FOR. UNARY OPERATORS (NOT AND
                NEGATION)  PUT THEIR PRECEDENCE ON THE STACK
                AND ENTER FORMULA EVALUATION AT STEP 1, SO
                THAT EVERYTHING UP TO AN OPERATOR GTEATER THAN
                THEIR PRECEDENCE OR THE END OF THE FORMULA
                WILL BE EVALUATED. WHEN FRMEVL DOES A RETURN
                BECAUSE IT SEES AN OPERATOR OF HIGHER PRECEDENCE
                IT DOES NOT PASS THE TEXT POINTER IN [H,L], SO
                AFTER THE UNARY OPERATION HAS BEEN PERFORMED
                ON THE FAC THE TEXT POINTER MUST BE FETCHED FROM
                A TEMPORARY LOCATION THAT FRMEVL USES AND
                A RETURN BACK TO FRMEVL DONE.
        DIMENSION AND VARIABLE SEARCHING
                SPACE IS ALLOCATED FOR VARIABLES AS THEY ARE
                ENCOUNTERED. THUS "DIM" STATEMENTS MUST BE
                EXECUTED TO HAVE EFFECT. 6 BYTES ARE ALLOCATED
                FOR EACH SIMPLE VARIABLE, WHETHER IT IS A STRING,
                NUMBER OR USER DEFINED FUNCTION. THE FIRST TWO
                BYTES GIVE THE NAME OF THE VARIABLE AND THE LAST FOUR
                GIVE ITS VALUE. (VARTAB) GIVES THE FIRST LOCATION
                WHERE A SIMPLE VARIABLE NAME IS FOUND AND (ARYTAB)
                GIVES THE LOCATION TO STOP SEARCHING FOR SIMPLE
                VARIABLES. A "FOR" ENTRY HAS A TEXT POINTER
                AND A POINTER TO A VARIABLE VALUE SO NEITHER
                THE PROGRAM OR THE SIMPLE VARIABLES CAN BE
                MOVED WHILE THERE ARE ACTIVE "FOR" ENTRIES ON THE STACK
                USER DEFINED FUNCTION VALUES ALSO CONTAIN
                POINTERS INTO SIMPLE VARIABLE SPACE SO NO USER-DEFINED
                FUNCTION VALUES CAN BE RETAINED IF SIMPLE VARIABLES
                ARE MOVED. ADDING A SIMPLE VARIABLE
                ADDING SIX TO ARYTAB AND STREND, BLOCK TRANSFERING
                THE ARRAY VALUES UP BY SIX AND MAKING SURE THE
                NEW (STREND) IS NOT TO CLOSE TO THE STACK.
                THIS MOVEMENT OF ARRAY VARIABLES MEANS
                THAT NO POINTER TO AN ARRAY WILL STAY VALID WHEN
                NEW SIMPLE VARIABLES CAN BE ENCOUNTERED. THIS IS
                WHY ARRAY VARIABLES ARE NOT ALLOWED "FOR"
                LOOP VARIABLES. SETING UP ANEW ARRAY VARIABLE
                MERELY INVOLVES BUILDING THE DESCRIPTOR,
                UPDATING STREND, AND MAKING SURE THERE IS
                STILL ENOUGH ROOM BETWEEN STREND AND THE
                STACK. WITHOUT MULTIPLE DIMENSIONS THE FORMAT
                OF AN ARRAY VARIABLE IS SIMPLY:
                        SECOND CHARACTER
                        FIRST CHARACTER
                        NUMBER OF BYTES USED BY VALUES
                        VALUES
                THE FORMAT WHEN MULTPLY DIMENSIONED VARIABLES
                ARE ALLOWED IS DESCRIBED IN THE "MULDIM" CODE.
                PTRGET, THE ROUTINE WHICH RETURNS A POINTER
                TO A VARIABLE VALUE, HAS TWO IMPORTANT FLAGS. ONE IS
                "DIMFLG" WHICH INDICATED WHETHER "DIM" CALLED PTRGET
                OR NOT. IF SO, NO PRIOR ENTRY FOR THE VARIABLE IN
                QUESTION SHOULD BE FOUND, AND THE INDEX INDICATED
                HOW MUCH SPACE TO SET ASIDE. SIMPLE VARIABLES CAN
                BE "DIMENSIONED", BUT THE ONLY EFFECT WILL BE TO
                SET ASIDE SPACE FOR THE VARIABLE IF IT HASN'T BEEN
                ENCOUNTERED YET. THE OTHER IMPORTANT FLAG IS SUBFLG
                WHICH INDICATES WHETHER A SUBSCRIPTED VARIABLE SHOULD BE
                ALLOWED IN THE CURRENT CONTEXT. IF SUBFLG IS NON-ZERO
                THE OPEN PARENTHESIS FOR A SUBSCRIPTED VARIABLE
                WILL NOT BE SCANNED BY PTRGET, AND PTRGET WILL RETURN
                WITH A TEXT POINTER POINTING TO THE "(, IF
                THERE WAS ONE.
        STRINGS
                IN THE VARIABLE TABLE STRINGS ARE STORED JUST LIKE
                NUMBERIC VARIABLES. SIMPLE STRINGS HAVE FOUR VALUE
                BYTES WHICH ARE INITIALIZED TO ALL ZEROES (WHICH
                REPRESENTS THE NULL STRING). THE ONLY DIFFERENCE
                IN HANDLING IS THAT WHEN PTRGET SEES A "$" AFTER THE
                NAME OF A VARIABLE, PTRGET SETS VALTYP TO ONE AND TURNS
                ON THE MSB (MOST-SIGNIFICANT-BIT) OF THE VALUE OF
                THE FIRST CHARACTER OF THE VARIABLE NAME.
                HAVING THIS BIT ON IN THE NAME OF THE VARIABLE ENSURES
                THAT THE SEARCH ROUTINE WILL NOT MATCH
                'A' WITH 'AS' OR 'A$' WITH 'A'. THE MEANING OF
                THE FOUR VALUE BYTES ARE:
                        LOW
                                LENGTH OF THE STRING
                                UNUSED
                                LOW 8 BITS
                                HIGH 8 BITS  OF THE ADDRESS
                                        OF THE CHARACTERS IN THE
                                        STRING IF LENGTH,NE.0.
                                        MEANINGLESS OTHERWISE.
                        HIGH
                THE VALUE OF A STRING VARIABLE (THESE 4 BYTES)
                IS CALLED THE STRING DESCRIPTOR TO DISTINGUISH
                IT FROM THE ACTUAL STRING DATA. WHENEVER A
                STRING CONSTANT IS ENCOUNTERED IN A FORMULA OR AS
                PART OF AN INPUT STRING, OR AS PART OF DATA, STRLIT
                IS CALLED, CAUSING A DESCRIPTOR TO BE BUILT FOR
                THE STRING. IF THE STRING CONSTANT IS IN BUF (WHICH
                IT WILL BE IF THE STRING IS BEING "INPUT", OR THE
                STRING IS PART OF SOME FORMULA IN A DIRECT STATEMENT)
                THE VALUE IS COPIED INTO STRING SPACE SINCE BUF
                IS ALWAYS CHANGING. "STRCPY" IS USED TO COPY
                STRINGS.
                STRING FUNCTIONS AND THE ONE STRING OPERATOR "+"
                ALWAYS RETURN THEIR VALUES IN STRING SPACE.
                ASSIGNING A STRING A CONSTANT VALUE IN A PROGRAM
                THROUGH A "READ" OR ASSIGNMENT STATEMENT
                WILL NOT USE ANY STRING SPACE SINCE
                THE STRING DESCRIPTOR  WILL POINT INTO THE
                PROGRAM ITSELF. IN GENERAL, COPYING IS DONE
                WHEN A STRING VALUE IS IN BUF, OR IT IS IN STRING
                SPACE AND THERE IS AN ACTIVE POINTER TO IT.
                THUS F$=G$ WILL CAUSE COPYING IF G$ HAS ITS
                STRING DATA IN STRING SPACE. F$=CHR$(7)
                WILL USE ONE BYTE OF STRING SPACE TO STORE THE
                NEW ONE CHARACTER STRING CREATED BY "CHR$", BUT
                THE ASSIGNMENT ITSELF WILL CAUSE NO COPYING SINCE
                THE ONLY POINTER AT THE NEW STRING IS A
                TEMPORARY DESCRIPTOR CREATED BY FRMEVL WHICH WILL
                GO AWAY AS SOON AS THE ASSIGNMENT IS DONE.
                IT IS THE NATURE OF GARBAGE COLLECTION THAT
                DISALLOWS HAVING TWO STRING DESCRIPTORS POINT TO THE SAME
                AREA IN STRING SPACE. STRING FUNCTIONS AND OPERATORS
                MUST PROCEED AS FOLLOWS:
                        1) FIGURE OUT THE LENGTH OF THEIR RESULT
                        2) CALL GETSPA TO FIND SPACE FOR THEIR
                        RESULT. THE ARGUMENTS TO THE FUNCTION
                        OR OPERATOR MAY CHANGE SINCE GARBAGE COLLECTION
                        MAY BE INVOLVED. THE ONLY THING THAT CAN
                        BE SAVED DURING THE CALL TO GETSPA IS A POINTER
                        TO THE DESCRIPTORS OF THE ARGUMENTS.
                        3) CONSTRUCT THE RESULT DESCRIPTOR IN DSCTMP.
                        GETSPA RETURNS THE LOCATION OF THE AVAILABLE
                        SPACE.
                        4) CREATE THE NEW VALUE BY COPYING PARTS
                        OF THE ARGUMENTS OR WHATEVER.
                        5) FREE UP THE ARGUMENTS BY CALLING FRETMP.
                        6) JUMP TO PUTNEW TO GET THE DESCRIPTOR IN
                        DSCTMP TRANSFERRED INTO A NEW STRING TEMPORARY.
                THE REASON FOR STRING TEMPORARIES IS THAT GARBAGE
                COLLECTION HAS TO KNOW ABOUT ALL ACTIVE STRING DESCRIPTORS
                SO IT KNOWS WHAT IS AND ISN'T IN USE. STRING TEMPORARIES ARE
                USED TO STORE THE DESCRIPTORS OF STRING EXPRESSIONS.
                INSTEAD OF HAVING AN ACTUAL VALUE STORED IN THE
                FAC, AND HAVING THE VALUE OF A TEMPORARY RESULT
                BEING SAVED ON THE STACK, AS HAPPENS WITH NUMERIC
                VARIABLES, STRINGS HAVE THE POINTER TO A STRING DESCRIPTOR
                STORED IN THE FAC, AND IT IS THIS POINTER
                THAT GETS SAVED ON THE STACK BY FORMULA EVALUATION.
                STRING FUNCTIONS CANNOT FREE THEIR ARGUMENTS UP RIGHT
                AWAY SINCE GETSPA MAY FORCE
                GARBAGE COLLECTION AND THE ARGUMENT STRINGS
                MAY BE OVER-WRITTEN SINCE GARBAGE COLLECTION
                WILL NOT BE ABLE TO FIND AN ACTIVE POINTER TO
                THEM. FUNCTION AND OPERATOR RESULTS ARE BUILT IN
                DSCTMP SINCE STRING TEMPORARIES ARE ALLOCATED
                (PUTNEW) AND DEALLOATED (FRETMP) IN A FIFO ORDERING
                (I.E. A STACK) SO THE NEW TEMPORARY CANNOT
                BE SET UP UNTIL THE OLD ONE(S) ARE FREED. TRYING
                TO BUILD A RESULT IN A TEMPORARY AFTER
                FREEING UP THE ARGUMENT TEMPORARIES COULD RESULT
                IN ONE OF THE ARGUMENT TEMPORARIES BEING OVERWRITTEN
                TOO SOON BY THE NEW RESULT.
                STRING SPACE IS ALLOCATED AT THE VERY TOP
                OF MEMORY. MEMSIZ POINTS BEYOND THE LAST LOCATION OF
                 STRING SPACE. STRING ARE STORED IN HIGH LOCATIONS
                FIRST. WHENEVER STRING SPACE IS ALLOCATED (GETSPA)
                FRETOP, WHICH IS INITIALIZED TO [MEMSIZ], IS UPDATED
                TO GIVE THE HIGHEST LOCATION IN STRING SPACE
                THAT IS NOT IN USE. THE RESULT IS THAT
                FRETOP GETS SMALLER AND SMALLER, UNTIL SOME
                ALLOCATION WOULD MAKE [FRETOP] LESS THAN OR EQUAL TO
                [STKTOP]. THIS MEANS STRING SPACE HAS RUN INTO THE
                STACK AND THAT GARBAGE COLLECTION MUST BE CALLED.
                GARBAGE COLLECTION:
                        0. MINPTR=[STKTOP] [FRETOP]=[MEMSIZ]
                        1. REMMIN=0
                        2. FOR EACH STRING DESCRIPTOR
                        (TEMPORARIES, SIMPLE STRINGS, STRING ARRAYS)
                        IF THE STRING IS NOT NULL AND ITS POINTER IS
                        .GT.MINPTR AND .LT.FRETOP,
                        MINPTR=THIS STRING DESCRIPTOR
                        REMMIN=POINTER AT THIS STRING DESCRIPTOR
                        END
                        3. IF REMMIN.NE.0 (WE FOUND AN UNCOLLECTED STRING)
                        BLOCK TRANSFER THE STRING DATA POINTED
                        TO IN THE STRING DESCRIPTOR POINTED TO BY REMMIN
                        SO THAT THE LAST BYTE OF STRING DATA IS AT
                        [FRETOP]. UPDATE FRETOP SO THAT IT
                        POINTS TO THE LOCATION JUST BELOW THE ONE
                        THE STRING DATA WAS MOVED INTO. UPDATE
                        THE POINTER IN THE DESCRIPTOR SO IT POINTS
                        TO THE NEW LOCATION OF THE STRING DATA.
                        GO TO STEP 1
                AFTER CALLING GARBAGE COLLECTION GETSPA AGAIN CHECKS
                TO SEE IF [A] CHARACTERS ARE AVAILABLE BETWEEN
                [STKTOP] AND [FRETOP] , IF NOT AN "OUT OF STRING"
                ERROR IS INVOKED.
        MATH PACKAGE
                THE MATH PACKAGE CONTAINS FLOATING INPUT (FIN),
                FLOATING OUTPUT (FOUT) FLOATING COMPARE (FCOMP)
                ... AND ALL THE NUMERIC OPERATORS AND FUNCTIONS.
                THE FORMATS,CONVENTIONS AND ENTRY POINTS ARE ALL
                DESCRIBED IN THE MATH PACKAGE ITSELF.
        INIT -- THE INITIALIZATION ROUTINE
                INITIALIZATION FIRST LOOKS AT THE SWITCH REGISTERS
                TO SEE WHAT TYPE OF I/O SHOULD BE DONE.
                ANY NON-STANDARD I/O CAUSES LOCATIONS IN BASIC
                TO BE CHANGED. THEN THE AMOUNT OF MEMORY,
                TERMINAL WIDTH,AND WHICH FUNCTIONS TO BE RETAINED
                ARE ASCERTAINED FROM THE USER. A ZERO IS PUT DOWN
                AT THE FIRST LOCATION NOT USED BY THE MATH-PACKAGE
                AND TXTTAB IS SET UP TO POINT AT THE NEXT LOCATION.
                THIS DETERMINES WHERE PROGRAM STORAGE WILL START. THE
                HIGHEST MEMORY LOCATION MINUS THE AMOUNT OF DEFAULTED
                STRING SPACE (50) GIVES THE FIRST LOCATION USED BY THE
                STACK. SPECIAL CHECKS ARE MADE TO MAKE SURE
                ALL QUESTIONS IN INIT ARE ANSWERED REASONABLY, SINCE
                ONCE INIT FINISHES THE LOCATIONS IT USES ARE
                USED FOR PROGRAM STORAGE. THE LAST THING INIT DOES IS
                CHANGE LOCATION ZERO TO BE A JUMP TO READY INSTEAD
                OF INIT. ONCE THIS IS DONE THERE IS NO WAY TO RESTART
                INIT.
        STORAGE
                                A ZERO.
                [TXTTAB]        POINTER TO NEXT LINE'S POINTER
                                LINE # OF THIS LINE (2 BYTES)
                                CHARACTERS ON THIS LINE
                                ZERO
                                POINTER AT NEXT LINE'S POINTER
                                            (POINTED TO BY THE ABOVE POINTER)
                                ... REPEATS ...
                LAST LINE:      POINTER AT ZERO POINTER
                                LINE # OF THIS LINE
                                CHARACTERS ON THIS LINE
                                ZERO
                                DOUBLE ZERO (POINTED TO BY THE ABOVE POINTER)
                [VARTAB]        SIMPLE VARIABLES. 6 BYTES PER VALUE.
                                2 BYTES GIVE THE NAME, 4 BYTES THE VALUE
                                ... REPEATS ...
                [ARYTAB]        ARRAY VARIABLES. 2 BYTES NAME, 2 BYTE
                                LENGTH, VALUE (EXTRA IF MULDIM ON)
                                ... REPEATS  ...
                [STREND]        FREE SPACE
                                ... REPEATS ...
                                MOST RECENT STACK ENTRY
                                ... REPEATS ...
                [STKTOP]        FIRST STACK ENTRY
                                FREE STRING SPACE
                                ... REPEATS ...
                [FRETOP]        STRING SPACE IN USE
                                ... REPEATS ...
                [MEMSIZ]        HIGHEST MACHINE LOCATION
                                UNUSED EXCEPT BY THE VAL FUNCTION.
HIGH LOCATIONS
*
PAGE
SUBTTL  RST ROUTINES
RELOC 0
START:  DI                      ;DISENABLE INTERRUPTS
        JMP     INIT            ;INIT IS THE INITIALIZE ROUTINE 
                                ;IT SETS UP CERTAIN
                                ;LOCATIONS DELETES FUNCTIONS IF
                                ;DESIRED AND
                                ;CHANGES THIS TO JMP READY
IFN     LENGTH-2,<
        ADR(DEINT)              ;STORE HERE THE ROUTINE
                                ;TO TURN THE FAC INTO
                                ;A TWO-BYTE SIGNED INTEGER
        ADR(GIVABF)>            ;STORE HERE THE ADDRESS
                                ;OF THE ROUTINE TO CONVERT [A,B]
                                ;TO A FLOATING POINT NUMBER IN THE FAC
IFE     LENGTH-2,<
        ADR(FECINT)             ;TURN FAC INTO AN INTEGER IN [H,L]
        ADR(MAKINT)>            ;TURN [H,L] INTO A VALUE IN THE FAC
                                ;SET VALTYP FOR INTEGER
RELOC 8
;
; SYNCHK LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
; IS A SPECIFIC THING (CONTAINED IN THE LOCATION AFTER THE CALL)
; IF NOT IT CALLS THE 'SYNTAX ERROR' ROUTINE, OTHERWISE IT GOBBLES
; THE NEXT CHARACTER AND RETURNS. (BY FALLING INTO CHRGET)
;
; ALL REGISTERS ARE PRESERVED EXCEPT [A]=NEW CHAR
; AND (H,L) ENDS UP POINTING AT THE CHARACTER AFTER THE ONE
; WHICH WAS CHECKED.
;
        MOV     A,M             ;GET THE CURRENT CHARACTER
        XTHL                    ;GET CALL ADDRESS IN TO [H,L]
                                ;PUT TEXT POINTER ON STACK
        CMP     M               ;SEE IF [A] =CURRENT CHARACTER
                                ;IS THE RIGHT THING.
        INX     H               ;FIX RETURN ADDRESS.
        XTHL                    ;PUT RETURN ADDRESS BACK AND RESTORE
                                ;THE TEXT POINTER.
        JNZ     SNERR           ;IF THE CHARACTER WASN'T RIGHT CALL
                                ;THE 'SYNTAX ERROR' ROUTINE
                                ;OTHERWISE FALL THROUGH
                                ;AND GET ANOTHER CHARACTER.
;
; CHRGET, USING [H,L] AS THE CURRENT TEXT POINTER FETCHES
; A NEW CHARACTER INTO [A] AFTER INCREMENTING [H,L]
; AND SETS CONDITION CODES ACCORDING TO WHATS IT [A]
;       C=       NUMERIC    ("0" THROUGH "9")
;       Z=       ":" OR END-OF-LINE (A 0)
;
; ALL REGISTERS SAVED EXCEPT [A]=NEW CHAR
; [H,L]=[H,L]+1
;
RELOC 16
IFE     LENGTH,<CHRGTR:>
        INX     H               ;UPDATE THE TEXT POINTER
        MOV     A,M             ;GET NEW CHARACTER
        CPI     ":"             ;MAKE ":" HAVE ZERO ON AND
                                ;CARRY OFF
                                ;ALL ALPHABETICS & RESERVED
                                ;WORDS GET ZERO & CARRY OFF
RNC                             ;.GT.":" GO BACK
JMP     CHRCON                  ;NO ROOM FOR WHOLE ROUTINE
;
; THIS RST ROUTINE OUTPUTS THE CHARACTER IN [A] USING PRTFLG (LPT OR TTY)
; CNTWFL (SUPRESS OUTPUT OR NOT), TTYPOS (PRINT HEAD POSITION),
; TIMING ETC.. NO REGISTERS OR CONDITION CODES ARE CHANGED.
;
RELOC 24
OUTDO:  PUSH    PSW
IFN     CONTRW,<
        LDA     CNTWFL          ;GET SUPPRESS FLAG
        ORA     A>              ;SEE IF IT IS SET
IFE     LENGTH!CONTRW!LPTSW,<
        LDA     TTYPOS>         ;USE RST BYTES, [A]=TTYPOS
        JMP     OUTCON
;
; COMPAR COMPARES [H,L] WITH [D,E] UNSIGNED
;
;               [H,L] LESS THAN [D,E] SET CARRY
;               [H,L] = [D,E] SET ZERO
;
; [A] IS THE ONLY REGISTER USED
;
RELOC 32
        MOV     A,H
        SUB     D
        RNZ
        MOV     A,L
        SUB     E
        RET
NULCNT: 1                       ;STORE HERE THE NUMBER OF NULLS
                                ;TO PRINT AFTER CRLF
TTYPOS: BLOCK   1               ;STORE TERMINAL POSITION HERE
;
;THE FSIGN  RST RETURNS A=-1 IF FAC IS LESS THAN 0
;       A=0 IF FAC=0
;       A=1 IF FAC GREATER THAN ZERO
; THE CONDITION CODES REFLECT THE VALUE OF [A]
; AND NO OTHER REGISTERS ARE MODIFIED.
; THIS WORKS ONLY WHEN THE FAC IS A SINGLE OR DOUBLE PRECISION NUMBER
; THE 'VSIGN' ROUTINE IS MORE GENERAL SINCE
; IT WILL TAKE THE SIGN OF THE INTEGERS AS WELL
; AND GIVES "TMERR" ON STRINGS.
;
RELOC   40
SIGN:   LDA     FAC
        ORA     A
        JNZ     SIGNC
        RET
;
; THIS IS THE PUSHM RST
; EFFECT IS:
;       MOVE    C,M
;       INX     H
;       MOV     B,M
;       INX     H
;       PUSH    B
; DIFFICULTY COMES IN BECAUSE OF THE
; RETURN ADDRESS.
;
RELOC   48
        XHTL                    ;SWITCH [H,L] AND RETURN ADDRESS
        SHLD    PUSHMA+1        ;FIXUP JUMP PLACE TO GO
        POP     H               ;REGAIN [H,L]
IFN     LENGTH,<
        JMP     $CODE+59        ;IN 8K ALLOW USER TO HAVE RST 7
                                ;FOR INTERRUPT TRAPPING
RELOC   56
        RET                     ;INITIALLY NO INTERRUPT
                                ;ROUTINE
        NOP
        NOP>
        MOV     C,M             ;GRAB FROM MEMORY
        INX     H
        MOV     B,M
        INX     H
        PUSH    B               ;PUSH [B,C] ONTO THE STACK
                                ;SINCE IT CONTAINS [M]
PUSHMA: JMP     PUSHMA          ;RETURN  ADDRESS STORED HERE
PAGE
SUBTTL DISPATCH TABLES,RESERVED WORDS, ERROR TEXT... ALL CONSTANT
FUNDSP: ADR(SGN)
IFN     LENGTH-2,<
        ADR(INT)>
IFE     LENGTH-2,<
        ADR(VINT)>
        ADR(ABS)
USRLOC: ADR(ILLFUN)             ;INITIALLY NO USER ROUTINE
IFN     LENGTH,<ADR(FRE)
        ADR(FNINP)
IFN     LPTSW,<ADR(LPOS)>
        ADR(POS)>
SQRFIX: ADR(SQR)
RNDFIX: ADR(RND)
IFN     EXTFNC,<
        ADR(LOG)
        ADR(EXP)
COSFIX: ADR(COS)>
SINFIX: ADR(SIN)
IFN     EXTFNC,<
TANFIX: ADR(TAN)
ATNFIX: ADR(ATN)>
IFN     LENGTH,<
        ADR(PEEK)>
IFN     DSKFUN,<ADR(DSKI$)>
IFN     STRING,<
        ADR(LEN)
        ADR(STR$)
        ADR(VAL)
        ADR(ASC)
        ADR(CHR$)
        ADR(LEFT$)
        ADR(RIGHT$)
        ADR(MIDS$)>
DEFINE ADRP(X),<ADR(X)>
IFE     LENGTH-2,<
DEFINE ADRP(X),<>>
OPTAB: 121                      ;OPERATOR TABLE CONTAINS
                                ;PRECEDENCE FOLLOWED BY
                                ;THE ROUTINE ADDRESS
        ADRP(FADDT)
        121
        ADRP(FSUBT)
        123
        ADRP(FMULTT)
        123
        ADRP(FDIVT)
IFN     EXTFNC,<127
        ADRP(FPWRT)>
IFN     LENGTH,<
        80
        ADRP(AND)
        70
        ADRP(OR)>
;
; TOKEN FOR RESERVED WORDS ALWAYS HAVE THE MOST
; SIGNIFICANT BIT ON
; THE LIST OF RESERVED WORDS
;
Q=128-1
DEFINE  DCI(A),<Q=Q+1
        XLIST
        DC(A)
        LIST>
        ENDTK==Q
        FORTK==Q
        DATATK==Q
        GOTOTK==Q
        IFTK==Q
        GOSUTK==Q
        REMTK==Q
IFE     LENGTH-1,<
        ELSETK==Q
IFN     DSKFUN,<DCI"DSKO$">
IFN     LPTSW,<DCI"LPRINT">
IFN     LENGTH,<
        PRINTK==Q
IFE     REALIO,<
        DCI"DDT">
IFN     LPTSW,<DCI"LLIST>
IFN     CASSW,<DCI"CLOAD"
        DCI"CSAVE">
IFN     CONSW,<DCI"CONSOLE">
        SCRATK=Q
; END OF COMMAND LIST
        "T"
        "A"
        "B"
        "("+128
        Q=Q+1
        TABTK=Q
        TOTK==Q
IFN     LENGTH,<
        "S"
        "P"
        "C"
        "("+128                 ;MACRO DOESNT LIKE ('S IN ARGUMENTS
        Q=Q+1
        SPCTK==Q>
        FNTK==Q>
        USINTK==Q>
        THENTK=Q
IFN     LENGTH,<
        NOTTK==Q>
        STEPTK=Q
        PLUSTK=Q
        MINUTK=Q
        LSTOPK==Q+1-PLUSTK      ; CRUNCH # OF HIGHEST OP+1-PLUSTK
        190                     ;A GREATER THAN SIGN
        Q=Q+1
        GREATK=Q
        EQUALK=Q
        188
        Q=Q+1
        LESSTK=Q                ;A LESS THAN SIGN
;
; NOTE DANGER OF ONE RESERVED WORD BEING A PART
; OF ANOTHER
; IE . . IF 2 GREATER THAN F OR T=5 THEN...
; WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
; IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
; SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
; ANOTHER EXAMPLE: IF T OR Q THEN ... "TO" IS CRUNCHED
;
        ONEFUN=Q
IFN     LPTSW,<DCI"LPOS">
        SQRTK==Q
IFN     EXTFNC,<
        ATNTK==Q>
IFN     LENGTH,<
IFN     DSKFUN,<DCI"DSKI$">
IFN     STRING,<
LASNUM==Q                       ;NUMBER OF LAST FUNCTION
                                ;THAT TAKES ONE ARG
        0                       ;MARKS END OF RESERVED WORD LIST
STMDSP: ADR(END)
        ADR(FOR)
        ADR(NEXT)
        ADR(DATA)
        ADR(INPUT)
        ADR(DIM)
        ADR(READ)
        ADR(LET)
        ADR(GOTO)
        ADR(RUN)
        ADR(IF)
        ADR(RESTORE)
        ADR(GOSUB)
        ADR(RETURN)
        ADR(REM)
        ADR(STOP)
IFE     LENGTH-2,<
        ADR(ELSE)
        ADR(TON)
        ADR(TOFF)
        ADR(EDIT)>
IFN     LENGTH,<ADR(FNOUT)
        ADR(ONGOTO)
        ADR(NULL)
        ADR(FNWAIT)>
IFN     DSKFUN,<ADR(DSKO$)>
IFN     LPTSW,<ADR(LPRINT)>
IFN     LENGTH,<
        ADR(POKE)
        ADR(PRINT)
IFN     FUNCTS,<ADR(DEF)>
IFN     LENGTH,<ADR(CONT)>
IFE     REALIO, <ADR(OUT)>
        ADR(LIST)
IFN     LPTSW,<ADR(LLIST)>
IFE     LENGTH-2,<ADR(DELETE)>
        ADR(CLEAR)
IFN     CASSW,<ADR(CLOAD)
        ADR(CSAVE)>
IFN     CONSSW,<ADR(CONSOLE)>
        ADR(SCRATH)
IFE     LENGTH-2,<
FRCTBL: ADR(FRCDBL)
        ADR(FRCINT)
        ADR(FRCSNG)
;
; THESE TABLES ARE USED AFTER THE DECISION HAS BEEN MADE
; TO APPLY AN OPERATOR AND ALL THE NECESSARY CONVERSION HAS
; BEEN DONE TO MATCH THE TWO ARGUMENT TYPES (APPLOP)
;
DBLDSP: ADR(DADD)               ;DOUBLE PRECISION ROUTINES
        ADR(DSUB)
        ADR(DMULT)
        ADR(DDIV)
        ADR(DCOMP)
SNGDSP: ADR(FADD)               ;SINGLE PRECISION ROUTINES
        ADR(FSUB)
        ADR(FMULT)
        ADR(FDIV)
        ADR(FCOMP)
INTDSP: ADR(IADD)               ;INTEGER ROUTINES
        ADR(ISUB)
        ADR(IMULT)
        ADR(IDIV)
        ADR(ICOMP)
Q=-2
DEFINE  DCL(X),<>
DEFINE  DCE(X),<Q=Q+2
        XLIST
        DC(X)
        LIST>
ERRTAB:
IFE     LENGTH-2,<
        0
        Q=0
        DEFINE  DCE(X),<>
        DEFINE  DCL(X),<
        Q=Q+1
        DC(X)
        0>>
        DCE"NF"
        DCL"NEXT WITHOUT FOR"
        ERRNF==Q
        DCE"SN"
        DCL"SYNTAX ERROR"
        ERRSN==Q
        DCE"RG"
        DCL"RETURN WITHOUT GOSUB"
        ERRRG==Q
        DCE"OD"
        DCL"OUT OF DATA"
        ERROD==Q"
        DCE"FC"
        "DCL"ILLEGAL FUNCTION CALL"
        ERRFC==Q
        DCE"OV"
        DCL"OVERFLOW"
        ERROV==Q
        DCE"OM"
        DCL"OUT OF MEMORY"
        ERROM==Q
        DCE"US"
        DCL"UNDEFINED STATEMENT"
        ERRUS==Q
        DCE"BS"
        DCL"SUBSCRIPT OUT OF RANGE"
        ERRBS==Q
        DCE"DD"
        DCL"REDIMENSIONED ARRAY"
        ERRDD==Q
        DCE"/0"
        DCL"DIVISION BY ZER0"
        ERRDV0==Q
        DCE"ID"
        DCL"ILLEGAL DIRECT"
        ERRID==Q
IFN     STRING,<
        DCE"TM"
        DCL"TYPE MISMATCH"
        ERRTM==Q
        DCE"OS"
        DCL"OUT OF STRING SPACE"
        ERRSO==Q
        DCE"LS"
        DCL"STRING TOO LONG"
        ERRLS==Q
        DCE"ST"
        DCL"STRING FORMULA TOO COMPLEX"
        ERRST==Q>
IFN     LENGTH,<
        DCE"CN"
        DCL"CAN'T CONTINUE"
        ERRCN==Q>
IFN     FUNCTS,<
        DCE"UF"
        DCL"UNDEFINED USER FUNCTIONS"
        ERRUF==Q>
PAGE
SUBTTL  LOW SEGMENT -- RAM -- IE THIS STUFF IS NOT CONSTANT
;
; THIS IS THE "VOLATILE" STORAGE AREA AND NONE OF IT
; CAN BE KEPT IN ROM, ANY CONSTANTS IN THIS AREA CANNOT
; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE
; PROGRAM INSTRUCTION IN ROM.
;
BUFMIN: 44                      ;A COMMA (PRELOAD OR ROM)
                                ;USED BY INPUT STATEMENT SINCE THE
                                ;DATA POINTER ALWAYS STARTS ON A
                                ;COMMA OR TERMINATOR
BUF:    BLOCK   BUFLEN          ;TYPE IN STORED HERE
                                ;DIRECT STATEMENTS EXECUTE OUT OF
                                ;HERE, REMEMBER INPUT SMASHES BUF.
                                ;MUST BE AT A LOWER ADDRESS
                                ;THAN DSCTMP OR ASSIGNMENT OF STRING
                                ;VALUES IN DIRECT STATEMENTS WON'T COPY
                                ;INTO STRING SPACE -- WHICH IT MUST
IFN     LPTSW,<
LPTPOS: BLOCK   1               ;POSITION OF LPT PRINT HEAD
PRTFLG: BLOCK   1>              ;WHETHER OUTPUT GOES TO LPT
                                ;NON-ZERO MEANS SEND OUTPUT TO LPT
IFN     CONTRW,<
CNTWFL: BLOCK   1>              ;SUPRESS OUTPUT FLAG
DIMFLG: BLOCK   1               ;IN GETTING A POINTER TO A VARIABLE
                                ;IT IS IMPORTANT TO REMEMBER WHETHER IT
                                ;IS BEING DONE FOR "DIM" OR NOT
                                ;DIMFLG AND VALTYP MUST BE
                                ;CONSECUTIVE LOCATIONS
IFN     STRING,<
VALTYP: BLOCK   1               ;THE TYPE INDICATOR
                                ;IN THE 8K 0=NUMERIC 1=STRING
OPRTYP:                         ;USED TO STORE OPERATOR NUMBER
                                ;IN THE EXTENDED MOMENTARILY BEFORE
                                ;OPERATOR APPLICATION
DORES:  BLOCK   1               ;WHETHER CAN OR CAN'T CRUNCH RES'D WORDS
                                ;TURNED ON IN THE 8K WHEN "DATA"
                                ;BEING SCANNED BY CRUNCH SO UNQUOTED
                                ;STRINGS WON'T BE CRUNCHED.
MEMSIZ: BLOCK   2               ;HIGHEST LOCATION IN MEMORY
TEMPPT: BLOCK   2               ;POINTER AT FIRST FREE TEMP DESCRIPTOR
                                ;INITIALIZED TO POINT TO TEMPST
TEMPST: BLOCK   STRSIZ*NUMTMP   ;STORAGE FOR NUMTMP DESCRIPTORS
DSCTMP: BLOCK   STRSIZ          ;STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE
FRETOP: BLOCK   2>              ;TOP OF STRING FREE SPACE
IFN     LENGTH!STRING,<
TEMP3:  BLOCK   2>              ;USED TO HOLD VARB # OF HIGH LOC FOUND
                                ;IN GARBAGE COLLECTION
                                ;AND USED MOMENTARILY BY FRMEVL
                                ;USED IN EXTENDED BY FOUT
                                ;ARRAY VARIABLE HANDLING TEMPORARY
IFN     LENGTH,<
DATLIN: BLOCK   2               ;DATA LINE # -- REMEMBER FOR ERRORS
SUBFLG: BLOCK   1>              ;FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED
                                ;"FOR" AND USER-DEFINED FUNCTION
                                ;POINTER FETCHING TURN
                                ;THIS ON BEFORE CALLING PTRGET
                                ;SO ARRAYS WON'T BE DETECTED.
                                ;STKINI AND PTRGET CLEAR IT.
FLGINP: BLOCK   1               ;FLAGS WHETHER WE ARE DOING INPUT
                                ;OR A READ
TEMP:   BLOCK   2               ;TEMPORARY FOR STATEMENT CODE
                                ;NEWSTT SAVES [H,L] HERE FOR INPUT AND ^C
                                ;"LET" SAVED NUMBERIC VARIABLE
                                ;POINTERS HERE FOR "FOR"
                                ;"NEXT" SAVES ITS TEXT POINTER HERE
                                ;CLEARC SAVE [H,L] HERE
TEMP2:  BLOCK   2               ;FORMULA EVALUATOR TEMP
                                ;MUST BE PRESERVED BY OPERATORS
                                ;USED IN EXTENDED BY FOUT
                                ;ARRAY VARIABLE HANDLER TEMPORARY
CURLIN: BLOCK   2               ;CURRENT LINE #
                                ;SET TO 65535 WHEN DIRECT STATEMENTS EXECUTE
IFN     LENGTH,<
OLDLIN: BLOCK   2               ;OLD LINE NUMBER
OLDTXT: BLOCK   2>              ;OLD TEXT POINTER
                                ;POINTS AT STATEMENT TO BE EXECUTED NEXT
STKTOP: BLOCK   2               ;TOP LOCATION TO USE FOR THE STACK
                                ;INITIALLY SET UP BY INIT
                                ;ACCORDING TO MEMORY SIZE
                                ;TO ALLOW FOR 50 BYTES OF STRING SPACE.
                                ;CHANGED BY A CLEAR COMMAND WITH
                                ;AN ARGUMENT.
TXTTAB: BLOCK   2               ;POINTER TO BEGINNING OF TEXT
                                ;DOESN'T CHANGE AFTER BEING
                                ;SETUP BY INIT.
VARTAB: BLOCK   2               ;POINTER TO START OF SIMPLE
                                ;VARIABLE SPACE
                                ;UPDATED WHENEVER THE SIZE OF THE
                                ;PROGRAM CHANGES, SET TO [TXTTAB]
                                ;BY SCRATCH ("NEW").
ARYTAB: BLOCK   2               ;POINTER TO BEGINNING OF ARRAY
                                ;TABLE
                                ;INCREMENTED BY 6 WHENEVER
                                ;A NEW SIMPLE VARIABLE IS FOUND, AND
                                ;SET TO [VARTAB] BY CLEARC.
STREND: BLOCK   2               ;END OF STORAGE IN USE
                                ;INCREASED WHENEVER A NEW ARRAY
                                ;OR SIMPLE VARIABLE IS ENCOUNTERED
                                ;SET TO [VARTAB] BY CLEARC.
DATPTR: BLOCK   2               ;POINTER TO DATA. INITIALIZED TO POINT
                                ;AT THE ZERO IN FRONT OF [TXTTAB]
IFE     LENGTH-2,<
TRCFLG: BLOCK   1>              ;0 MEANS NO TRACE IN PROGRESS
;THE FLOATING ACCUMULATOR
IFE     LENGTH-2,<
        BLOCK   1               ;[TEMPORARY LEAST SIGNIFICANT BYTE]
DFACLO: BLOCK   4>              ;[FOUR LOWEST ORDERS FOR DOUBLE PRECISION]
FACLO:  BLOCK   3               ;[LOW ORDER OF MANTISSA]
                                ;[MIDDLE ORDER OF MANTISSA]
                                ;[HIGH ORDER OF MANTISSA]
FAC:    BLOCK   2               ;[EXPONENT]
                                ;[TEMPORARY COMPLEMENT OF SIGN IN MSB]
IFE     LENGTH-2,<
        BLOCK   1               ;[TEMPORARY LEAST SIGNIFICANT BYTE]
ARGLO:  BLOCK   7               ;[LOCATION OF SECOND ARGUMENT FOR DOUBLE
ARG:    BLOCK   1>              ; PRECISION]
FBUFFR  BLOCK   13              ;BUFFER FOR FOUT
IFE     LENGTH-2,<BLOCK 35-13>
PAGE
SUBTTL  TEXT CONSTANTS FOR PRINT OUT
;
; NEEDED FOR MESSAGES IN ALL VERSIONS
; MUST BE STORED ABOVE DSCTMP OR ELSE STRLIT
; WILL COPY THEM BEFORE STRPRT PRINTS THEM. THIS IS BAD, SINCE IF THE
; USER IS OUT OF STRING SPACE BASIC WILL LOOP GETTING "OUT OF STRING SPACE"
; ERRORS.
;
IFN     LENGTH-2,<
ERR:    DC" ERROR"
        0>
INTXT:  DC" IN "
        0
REDDY:  ACRLF
        DC"OK"
        ACRLF
        0
IFN     LENGTH,<
BRKTXT: ACRLF
        DC"BREAK"
        0>
PAGE
SUBTTL  GENERAL STORAGE MANAGEMENT ROUTINES
;
; FIND A FOR ENTRY ON THE STACK WITH THE VARIABLE POINTER
; PASSED IN [D,E].
;
FNDFOR: LXI     H,4+$CODE       ;IGNORING EVERYONES "NEWSTT"
                                ;AND THE RETURN ADDRESS OF THIS
        DAD     SP              ;SUBROUTINE, SET [H,L]=SP
LOOPER: MOV     A,M             ;SEE WHAT TYPE OF THING IS ON THE STACK
        INX     H
        CPI     FORTK           ;IS THIS STACK ENTRY A FOR?
RNZ                             ;NO SO OK
IFE     LENGTH,<
        PUSHM                   ;GET VARIABLE NAME
        XTHL>
IFN     LENGTH,<
        MOV     C,M
        INX     H               ;DO EQUIVALENT OF PUSHM / XTHL
        MOV     B,M
        INX     H
        PUSH    H               ;PUT H  ON
        MOV     L,C             ;PUSH B / XTHL IS SLOWER
        MOV     H,B
        MOV     A,D             ;FOR THE "NEXT" STATEMENT WITHOUT AN ARGUMENT
        ORA     E               ;WE MATCH ON ANYTHING
        XCHG                    ;MAKE SURE WE RETURN (D,E)
        JZ      POPGOF          ;POINTING TO THE VARIABLE
        XCHG>
        COMPAR
POPGOF: LXI     B,$CODE+13      ;TO WIPE OUT A FOR ENTRY
        POP     H
        RZ                      ;IF FOR MATCHES GOOD
        DAD     H
        JMP     LOOPER          ;TRY THE NEXT ONE
;
; THIS IS THE BLOCK TRANSFER ROUTINE
; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD
;
; [H,L] = DESTINATION OF HIGH ADDRESS
; [D,E] = LOW ADDRESS TO BE TRANSFERRED
; [B,C] = HIGH ADDRESS TO BE TRANSFERRED
;
; A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT
; OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND THE HIGHEST LOCATION
; TRANSFERRED INTO
;
; ON EXIT [H,L]=[D,E]=LOW [B,C]=LOCATION LOW WAS MOVED INTO
;
BLTU:   CALL    REASON          ;CHECK DESINTATION TO MAKE
                                ;SURE THE STACK WON'T BE OVERRUN
BLTUC:  PUSH    B               ;EXCHANGE [B,C] AND [H,L]
        XTHL
        POP     B
BLTLOP: COMPAR                  ;SEE IF WE ARE DONE
        MOV     A,M             ;GET THE WORD TO TRANSFER
        STAX    B               ;TRANSFER IT
        RZ
        DCX     B
        DCX     H               ;BACKUP FOR NEXT GUY
        JMP     BLTLOP
;
; THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER
; OF LOCATIONS REMAIN AVAILABLE FOR THE
; STACK. THE CALL IS :
;       CALL    GETSTK
;       NUMBER OF 2 BYTE ENTRIES NECESSARY
;
; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
; AN ARBITRARY AMOUNT OF STUFF ON THE STACK
; (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)
; IT IS ALSO CALLED BY ROUTINES SUCH AS GOSUB AND FOR
; WHICH MAKE PERMANENT ENTRIES ON THE STACK
;
;
; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
; NUMLEV STACK LOCATIONS NEED NOT CALL THIS
;
GETSTK: XTHL
        MOV     C,M             ;GET ARUGMENT INTO [C]
        INX     H
        XTHL                    ;PUT BACK RETURN ADDRESS
        PUSH    H               ;SAVE [H,L]
        LHLD    STREND
        MVI     B,0
        DAD     B
        DAD     B               ;SEE IF WE CAN HAVE THIS MANY
        CALL    REASON
        POP     H               ;RESTORE [H,L]
        RET
;
; [H,L]= SOME ADDRESS
; [H,L] IS EXAMINED TO MAKE SURE AT LEAST NUMLEV
; LOCATIONS REMAIN BETWEEN IT AND THE TOP OF THE STACK
;
REASON: PUSH    D               ;SAVE [D,E]
        XCHG                    ;PUT [H,L] IN [D,E]
        LXI     H,$CODE+65536-2*NUMLEV  ;SETUP OFFSET OF GUARANTEED
                                ;LOCATIONS
        DAD     SP              ;[H,L]=STACK POINTER + OFFSET
        COMPAR                  ;SEE IF THIS IS .GT. ENTERING [H,L]
        XCHG                    ;RESTORE [H,L] FROM [D,E]
        POP     D               ;GET [D,E] BACK
        RNC                     ;WAS OK?
OMERR:  MVI     E,EEPROM        ;"OUT OF MEMORY"
IFE     LENGTH,<
        XWD     ^O1000,1>       ;"LXI B," OVER THE NEXT 2
IFN     LENGTH,<
        JMP     ERROR>
PAGE
SUBTTL ERROR HANDLER, READY, COMPACTIFICATION, NEW, CLEAR, MAIN
IFN      LENGTH,<
DATSNE: LHLD    DATLIN          ;GET DATA LINE
        SMLD    CURLIN>         ;MAKE IT CURRENT LINE
SNERR:  MVI     E,ERRSN         ;"SYNTAX ERROR"
        XWD     ^O1000,1        ;"LXI B," OVER THE NEXT 2
DV0ERR: MVI     E,ERRDV0        ;DIVISION BY ZERO
IFN     LENGTH,<
        XWD     ^O1000,1        ;SKIP NEXT TWO
NFERR:  MVI     E,ERRNF>        ;"NEXT WITHOUT FOR" ERROR
ERROR:  CALL    STKINI          ;RESET THE STACK AND FLAGS
IFN     CONTRW,<
        XRA     A
        STA     CNTWFL>         ;FORCE OUTPUT
        CALL    CRDO            ;CRLF
        LXI     H,ERRTAB        ;GET START OF ERROR TABLE
IFE     LENGTH-2,<
LEPSKP: CALL    REM             ;SKIP AN ERROR MESSAGE
        DCR     E               ;DECREMENT ERROR COUNT
        INX     H               ;SKIP OVER THIS ERROR MESSAGE
        JNZ     LEPSKP>         ;SKIP SOME MORE
IFN     LENGTH-2<
        MOV     D,A             ;GET ZERO INTO D
        MVI     A,"7"           ;START OF ERROR MESSAGE
        OUTCHR                  ;TYPE IT
        DAD     D               ;ADD IN ERROR CODE
        MOV     A,M             ;GET FIRST ERROR CHARACTER
        OUTCHR                  ;TYPE IT
        CHRGET                  ;GET 2ND CHARACTER OF ERROR CODE
        OUTCHR                  ;TYPE IT
        LXI     H,ERR>          ;GET POINTER TO " ERROR"
ERRFIN: CALL    STROUT          ;TYPE IT
        LHLD    CURLIN          ;CURRENT LINE #
        MOV     A,H             ;SEE IF IN DIRECT MODE
        ANA     L
        INR     A               ;ZERO SAYS DIRECT MODE
        CNZ     INPUT           ;PRINT LINE NUMBER IN [H,L]
IFE     LENGTH,<
        XWD     ^O1000,1        ;"LXI B," OVER THE NEXT 2
END:
STOP:   RNZ                     ;MAKE SURE HE TERMINATED IT
STPEND: POP     B               ;GET RID OF "NEWSTT" RETURN ADDRESS
ENDCON:>
IFE     LENGTH-2,<
;
; FOR "LIST" COMMAND STOPPING
;
        XWD     ^O1000,^O76             ;SKIP THE NEXT BYTE
STPRDY: POP     B>
READY:  IFN     LPTSW,<
        CALL    FINLPT>         ;PRINT ANY LEFT OVERS
IFN     CONTRW,<
        XRA     A
        STA     CNTWFL>         ;FORCE OUTPUT
        LXI     H,$CODE+65535
        SHLD    CURLIN          ;SETUP CURLIN FOR DIRECT MODE
        LXI     H,REDDY         ;"READY" CRLF CRLF
REPINI: CALL    INIT            ;PRINT IT. REPLACED BY CALL STROUT
                                ;BY THE INIT CODE. THIS IS HERE SO AFTER
                                ;ERRORS DURING INIT. INIT IS RESTARTED
MAIN:   CALL    INLIN           ;GET A LINE FROM TTY
        CHRGET                  ;GET THE FIRST
        INR     A               ;SEE IF 0 SAVING THE CARRY FLAG
        DCR     A
        JZ      MAIN            ;IF SO, A BLANK LINE WAS INPUT
        PUSH    PSW             ;SAVE STATUS INDICATOR FOR 1ST CHARACTER
        CALL    LINGET          ;READ IN A LINE #
        PUSH    D               ;SAVE LINE #
        CALL    CRUNCH          ;CRUNCH THE LINE DOWN
        MOV     B,A             ;A=0 AFTER CRUNCH, [B,C]=CHAR COUNT FOR NODEL
        POP     D               ;RESTORE LINE #
        POP     PSW             ;WAS THERE A LINE #?
        JNC     GONE            ;IF NOT ITS A DIRECT STATEMENT
        PUSH    D
        PUSH    B               ;SAVE LINE # AND CHARACTER COUNT
        CHRGET                  ;REMEMBER IF THIS LINE IS
        PUSH    PSW             ;BLANK SO WE DON'T INSERT IT
        CALL    FNDLIN          ;GET A POINTER TO THE LINE
        PUSH    B               ;SAVE THE POINTER
IFE     LENGTH-2,<
        CC      DEL>            ;DELETE THE LINE
IFN     LENGTH-2,<
        JNC     NODEL           ;NO MATCH SO DON'T DELETE
        XCHG                    ;[D,E] NOW HAS THE POINTER TO THE LINE
                                ;BEYOND THIS ONE
        LHLD    VARTAB          ;COMPACTIFYING TO VARTAB
MLOOP:  LDAX    D
        STAX    B               ;SHOVING DOWN TO ELIMINATE A LINE
        INX     B
        INX     D
        COMPAR
        JNC     MLOOP           ;DONE COMPACTIFYING?
        MOV     H,B
        MOV     L,C
        INX     H               ;NEW VARTAB
        SHLD    VARTAB>
NODEL:  POP     D               ;POP POINTER AT PLACE TO INSERT
        POP     PSW             ;SEE IF THIS LINE HAD
                                ;ANYTHING ON IT
        JZ      FINI            ;IF NOT DON'T INSERT
        LHLD    VARTAB          ;CURRENT END
        XTHL                    ;[H,L]=CHARACTER COUNT, VARTAB
                                ;ONTO THE STACK
        POP     B               ;[B,C]=OLD VARTAB
        DAD     B
        PUSH    H               ;SAVE NEW VARTAB
        CALL    BLTU
        POP     H               ;POP OFF VARTAB
        SHLD    VARTAB          ;UPDATE VARTAB
        XCHG
        MOV     M,H             ;FOOL CHEAD WITH NON-ZERO LINK
        INX     H               ;SO IT DOESN'T THINK
                                ;THIS LINK IS THE
                                ;END OF THE PROGRAM
        INX     H
        POP     D               ;GET LINE # OFF STACK
        MOV     M,E
        INX     H               ;PUT DOWN LINE #
        MOV     M,D
        INX     H
        LXI     D,BUF           ;MOVE LINE FROM BUF TO PROGRAM AREA
MLOOPR: LDAX    D               ;NOW TRANSFERING LINE
                                ;IN FROM BUF
        MOV     M,A
        INX     H
        INX     D
        ORA     A               ;ZERO MARKS THE END
        JNZ     MLOOPR
FINI:   CALL    RUNC            ;DO CLEAR & SET UP STACK
                                ;ALSO SETS [H,L] TO [TXTTAB]-1
        INX     H
;
; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
; UP ALL THE LINKS. THE END OF EACH
; LINE IS FOUND BY SEARCHING FOR THE ZERO AT THE END.
; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM
;
CHEAD:  MOV     D,H             ;[D,E]=[H,L]
        MOV     E,L
        MOV     A,M             ;SEE IF END OF CHAIN
        INX     H               ;BUMP POINTER
        ORA     M               ;2ND BYTE
        JZ      MAIN            ;DONE
        INX     H               ;FIX H TO START OF TEXT
        INX     H
        INX     H
        XRA     A               ;SEARCHING FOR A ZERO IN MEMORY
CZLOOP: CMP     M               ;TO MARK THE END OF THIS LINK
        INX     H               ;BUMP POINTER
        JNZ     CZLOOP          ;END OF LINE
        XCHG                    ;SWITCH TEMP
        MOV     M,E             ;DO FIRST BYTE OF FIXUP
        INX     H               ;ADVANCE POINTER
        MOV     M,D             ;2ND BYTE OF FIXUP
        XCHG                    ;AND BACK AGAIN
        JMP     CHEAD           ;KEEP CHAINING TIL DONE
IFE     LENGTH-2,<
;
; SCNLIN SCANS A LINE RANGE OF
; THE FORM #-# OR # OR #- OR -# OR BLANK
; AND THEN FINDS THE FIRST LINE IN THE RANGE
;
SCNLIN: LXI     D,$CODE         ;ASSUME START OF LIST AT ZERO
        PUSH    D               ;SAVE INITIAL ASSUMPTION
        JZ      ALLLST          ;IF FINISHED, LIST IT ALL
        POP     D               ;WE ARE GOING TO GRAB A #
        CALL    LINGET          ;GET A LINE #, IF NONE, RETURNS ZERO
        PUSH    D               ;SAVE FIRST
        JZ      ONELIN          ;IF ONLY # THEN DONE.
        SYNCHK  MINUTK          ;MUST BE A DASH.
ALLLST: LXI     D,$CODE+^D65529 ;ASSUME MAX END OF RANGE
        CNZ     LINGET          ;GET THE END OF RANGE
        JNZ     SNERR           ;MUST BE TERMINATOR
ONELIN: XCHG                    ;[H,L] = FINAL
        POP     D               ;GET INITIAL IN [D,E]
        XTHL                    ;PUT MAX ON STACK, RETURN ADDR TO [H,L]
        PUSH    H>              ;SAVE RETURN ADDRESS BACK
;
; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
; WHOSE LINE # IS PASSED IN [D,E]. [D,E] IS PRESERVED.
; THERE ARE THREE POSSIBLE RETURNS:
;
;       1) ZERO FLAG SET. CARRY NOT SET. LINE NOT FOUND.
;          NO LINE IN PROGRAM GREATER THAN ONE SOUGHT.
;          [B,C] POINTS TO TWO ZERO BYTES AT END OF PROGRAM.
;          [H,L]=[B,C]
;
;       2) ZERO, CARRY SET.
;          [B,C] POINTS TO THE LINK FIELD IN THE LINK
;          WHICH IS THE LINE SEARCHED FOR.
;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
;
;       3) NON-ZERO, CARRY NOT SET.
;          LINE NOT FOUND. [B,C]  POINTS TO LINE IN PROGRAM
;          GREATER THAN ONE SEARCHED FOR.
;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
;
FNDLIN: LHLD    TXTTAB          ;GET POINTER TO START OF TEXT
LOOP:   MOV     B,H             ;IF EXITING BECAUSE OF END OF PROGRAM,
                                ;SET [B,C] TO POINT TO DOUBLE ZEROES.
        MOV     C,L
        MOD     A,M             ;GET WORD POINTER TO
        INX     H               ;BUMP POINTER
        ORA     M               ;GET 2ND BYTE
        DCX     H               ;GO BACK
        RZ                      ;IF ZERO THEN DONE
        PUSH    B
        PUSHM                   ;PUSH LINK
        PUSHM                   ;PUSH BINARY LINE #
        POP     H               ;POP HERE
        COMPAR                  ;COMPARE [D,E] TO [H,L]
        POP     H               ;GET LINK
        POP     B               ;GET POINTER TO THIS LINE IN [B,C]
        CMC                     ;TURN CARRY ON
        RZ                      ;EQUAL RETURN
        CMC                     ;MAKE CARRY ZERO
        RNC                     ;NO MATCH RETURN (GREATER)
        JMP     LOOP            ;KEEP LOOKING
;
; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
; AS VARIABLE SPACE
;
SCRATH: RNZ                     ;MAKE SURE THERE IS A TERMINATOR
SCRTCH: LHLD    TXTTAB
IFN     LENGTH-2,<
        XHA     A>
IFE     LENGTH-2,<
        CALL    TOFF>           ;TURN OFF TRACE. SET [A]=0
        MOV     M,A             ;SAVE AT END OFF TEXT
        INX     H               ;BUMP POINTER
        MOV     M,A             ;SAVE ZERO
        INX     H               ;BUMP POINTER
        SHLD    VARTAB          ;NEW START OF VARIABLE
IFE     LENGTH,<
RUN:    RNZ>                    ;CHECK FOR A TERMINATOR
RUNC:   LHLD    TXTTAB          ;POINT AT THE START OF TEXT
        DCX     H
;
; CLEARC IS A SUBROUTINE WHICH INITIALIZES THE VARIABLE AND
; ARRAY SPACE BY RESETING ARYTAB (THE END OF SIMPLE VARIABLE SPACE)
; AND STREND (THE END OF ARRAY STORAGE). IT FALLS INTO STKINI
; WHICH RESETS THE STACK. [H,L] IS PRESERVED.
;
IFE     STRING,<CLEAR:>
CLEARC: SHLD    TEMP            ;SAVE [H,L] IN TEMP
IFN     STRING,<
        LHLD    MEMSIZ
        SHLD    FRETOP>         ;FREE UP STRING SPACE
        CALL    RESTORE         ;RESTORE DATA
        LHLD    VARTAB          ;GET START OF VARIABLE SPACE
        SHLD    ARYTAB          ;SAVE IN START OF ARRAY SPACE
        SHLD    STREND          ;AND END OF VARIABLE STORAGE
;
; STKINI RESETS THE STACK POINTER ELIMINATING
; GOSUB & FOR CONTEXT.  STRING TEMPORARIES ARE FREED
; UP, SUBFLG IS RESET, CONTINUING IS DISALLOWED,
; AND A DUMMY ENTRY IS PUT ON THE STACK. THIS IS SO
; FNDFOR WILL ALWAYS FIND A NON-"FOR" ENTRY AT THE BOTTOM
; OF THE STACK. [A]=0 AND [D,E] IS PRESERVED
;
STKINI: POP     B               ;GET RETURN ADDRESS HERE
        LHLD    STKTOP          ;[H,L] POINTER TO END OF MEMORY
        SPHL                    ;INITIALIZE STACK
IFN     STRING,<
        LXI     H,TEMPST
        SHLD    TEMPPT>         ;INITIALIZE STRING TEMPORARIES
        LXI     H,$CODE         ;PUT ZERO (NON NEXT, FOR GOSUB TOKEN)
        PUSH    H               ;ON STACK
IFN     LENGTH,<SHLD    OLDTXT> ;MAKE CONTINUING ILLEGAL
IFN     LPTSW,<
        CALL    FINLPT>
        LHLD    TEMP            ;GET SAVED [H,L]
IFN     LENGTH,<
IFE     CONTRW,<XRA     A>
        STA     SUBFLG>         ;ALLOW SUBSCRIPTS
        PUSH    B               ;PUT RETURN ADDRESS BACK ON
        RET                     ;GO BACK
QINLIN: MVI     A,"?"           ;GET A QMARK
        OUTCHR                  ;TYPE IT
        MVI     A," "           ;SPACE
        OUTCHR                  ;TYPE IT TOO
IFE     STRING,<CALL    INLIN   ;IN THE NON-STRING VERSION ALL
                                ;INPUT IS CRUNCHED
        INX     H>              ;GET A LINE OF INPUT FROM TTY
IFN     STRING,<JMP     INLIN>  ;NO CRUNCHING IN THIS CASE
;
; ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME
; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
; RESERVED WORD LIST IN THE SAME
; ORDER THEY APPEAR IN IN STMDSP.
;
CRUNCH: IFN     STRING,<
        XRA     A
        STA     DORES>          ;ALLOW CRUNCHING
        MVI     C,5             ;COUNT OF CHARS AT LEAST 5
        LXI     D,BUF           ;SETUP DESTINATION POINTER
KLOOP:  MOV     A,M             ;GET CHARACTER FROM BUF
        CPI     " "             ;IS IT A SPACE WE WANT TO SAVE
        JZ      STUFFH          ;YES, STUFF IN DESTINATION LINE.
        MOV     B,A             ;GET A CHARACTER FROM THE LINE
                                ;SETUP B WITH A QUOTE IF IT IS A STRING
        CPI     34              ;QUOTE SIGN?
        JZ      STRNG           ;YES, GO TO SPECIAL STRING HANDLING
        ORA     A               ;END OF LINE?
        JZ      CRDONE          ;YES, DONE CRUNCHING
IFN     STRING,<
        LDA     DORES           ;IN DATA STATEMENT AND NO CRUNCH?
        ORA     A
        MOV     B,A             ;INITIALIZE RESERVED WORD COUNT
        MOV     A,M             ;GET THE CHARACTER AGAIN
        JNZ     STUFFH>         ;IF NO CRUNCHING JUST STORE
                                ;THE CHARACTER
IFN     LENGTH,<                ;NOT FOR 4K VERSION
        CPI     "?"             ;A QMARK?
        MVI     A,PRINTK
        JZ      STUFFH          ;THEN USE A "PRINT" TOKEN
        MOV     A,M
        CPI     "0"             ;SKIP NUMERICS
        JC      MUSTCR          ;SINCE CRUNCHING IS SLOW
        CPI     60              ;":" ALSO PUT IN QUICKLY
        JC      STUFFH
MUSTCR: >
        PUSH    D               ;SAVE STORE POINTER
IFE     STRING,<
        MVI     B,0>            ;INIT RESERVED WORD COUNT
        LXI     D,RESLST-1      ;INIT TO RESERVED WORD LIST
        PUSH    H               ;SAVE IN BUF POINTER
        XWD     ^O1000,^O76     ;"MVI" AROUND CHRGET
NEXRES: CHRGET                  ;GET CHAR FROM LINE
        INX     D               ;BUMP DEPOSIT POINTER
RESER:  LDAX    D               ;GET A BYTE FROM RESERVED WORD LIST
        ANI     127             ;GET RID OF SIGN BIT
        JZ      TABEND          ;END OF RESERVED WORD TABLE
        CMP     M               ;TWO CHARS THE SAME?
        JNZ     NTHIS           ;NO, DIFFERENT
        LDAX    D               ;GET RESERVED WORD BYTE
        ORA     A               ;SET CONDITION CODES
        JP      NXTRES          ;IF SIGN SET, RESERVED WORD FOUND
FOUND:  POP     PSW             ;TAKE OFF GARBAGE ORIG POINTER
        MOV     A,8             ;GET RESERVED WORD #
        ORI     128             ;SET MSB TO FLAG AS RESERVED WORD
        XWD     ^O1000,^O362    ;"JP" AROUND THE POP H AND MOV A,M
TABEND: POP     H               ;GET BACK ORIG POINTER
        MOV     A,M             ;GET BACK ORIG CHAR
        POP     D               ;GET STUFF POINTER BACK
IFE     LENGTH-2,<
        XCHG                    ;[H,L]=STUFF POINTER
        CPI     ELSETK          ;HAVE TO PUT A HIDDEN
                                ;COLON IN FRONT OF "ELSE"S
        MVI     M,":"           ;STORE IT
        CZ      INXHRT##        ;ADVANCE POINTER ON "ELSE"
                                ;SO ONLY ON "ELSE" THE COLON IS NOT OVERWRITTEN
        XCHG>                   ;[D,E]=STUFF POINTER
STUFFH: INX     H               ;ENTRY TO BUMP [H,L]
        STAX    D               ;SAVE CHARACTER IN CRUNCHED LINE
        INX     D               ;BUMP SAVE POINTER
        INR     C               ;BUMP CRUNCHED CHARACTER COUNT
IFN     STRING,<
        SUI     ":"             ;SEE IF IT IS A COLON
        JZ      COLIS           ;IF SO ALLOW CRUNCHING AGAIN
        CPI     DATATK-":"
        JNZ     NODATT          ;SEE IF IT IS A DATA TOKEN
COLIS:  STA     DORES           ;SETUP FLAG
NODATT: SUI     REMTK-":">
IFE     STRING,<SUI     REMRK>  ;WAS IT A REM STATEMENT
        JNZ     KLOOP           ;KEEP LOOPING
        MOV     B,A             ;REM DOESN'T STOP ON ":", ONLY ON A ZERO
STR1:   MOV     A,M             ;GET A CHAR
        ORA     A               ;SET CONDITION CODES
        JZ      CRDONE          ;IF END OF LINE THEN DONE
        CMP     B               ;END OF GOBBLE
        JZ      STUFFH          ;IF YES, DONE WITH STRING
STRNG:  INX     H               ;INCREMENT TEXT POINTER
        STAX    D               ;STORE CHAR
        INR     C               ;BUMP COUNT
        INX     D               ;AND POINTER
        JMP     STR1            ;KEEP LOOPING
NTHIS:  POP     H               ;RESTORE TEXT STRING
        PUSH    H               ;AND SAVE IT BACK
        INR     B               ;INCREMENT RESERVED WORD #
        XCHG                    ;RESLST POINTER INTO [H,L]
NTHIS1: ORA     H               ;TEST BITS IN THE RESERVED WORD LIST
        INX     H
        JP      NTHIS1          ;SKIP MORE
        XCHG                    ;RESLST POINTER INTO [H,L]
                                ;TEXT POINTER INTO [H,L]
        JMP     RESER           ;DONE, MOVE TO NEXT RESERVED WORD
CRDONE: LXI     H,BUFMIN        ;LEAVE WITH [H,L] POINTER TO START OF LINE
        STAX    D               ;NEED THREE 0'S ON THE END
        INX     D               ;ONE FOR END-OF-LINE
        STAX    D               ;AND 2 FOR A ZERO LINK
        INX     D               ;SINCE IF THIS IS A DIRECT STATEMENT
        STAX    D               ;ITS END MUST LOOK LIKE THE END OF A PROGRAM
        RET                     ;END OF CRUNCHING
;
; THIS IS THE LINE INPUT ROUTINE
; IT READS CHARACTERS INTO BUF USING _ AS THE
; CHARACTER DELETE CHARACTER AND # AS THE LINE DELETE CHARACTER
; IF MORE THAN BUFLEN CHARACTER ARE TYPED, NO ECHOING
; IS DONE UNTIL A  _ # OR CARRIAGE-RETURN IS TYPED.
; CONTROL-G WILL BE TYPED FOR EACH EXTRA CHARACTER.
; THE ROUTINE IS ENTERED AT INLIN
;
LINLIN: DCR     B               ;BACK ARROW SO DECREMENT COUNT
        DCX     H               ;BACK UP POINTER
IFN     REALIO,<
        OUTCHR>
        JNZ     INLINC          ;NOT TOO MANY SO CONTINUE
INLINN: IFN     REALIO,<
        OUTCHR>                 ;PRINT THE #, OR A SECOND _ IF THERE
                                ;WERE TOO MANY
        CALL    CRDO            ;TYPE A CRLF
INLIN:  LXI     H,BUF
        MVI     B,1             ;CHARACTER COUNT
INLINC: CALL    INCHR           ;GET A CHARACTER
IFN     LENGTH,<
        CPI     7               ;IS IT BOB ALBRECHT RINGING THE BELL
        JZ      GOODCH>         ;FOR SCHOOL KIDS?
        CPI     13              ;IS IT A CARRIAGE RETURN?
        JZ      FININL          ;IF SO FINISH UP
        CPI     32              ;CHECK FOR FUNNY CHARACTERS
        JC      INLINC
        CPI     125
        JNC     INLINC          ;BIG ONES BAD TOO
        CPI     "#"             ;LINE DELETE?
        JZ      INLINN
        CPI     "_"             ;CHARACTER DELETE
        JZ      LINLIN
GOODCH: MOV     C,A
        MOV     A,B
        CPI     BUFLEN
        MVI     A,7             ;GET A BELL IN CASE LINE TOO LONG.
        JNC     OUTBEL          ;LINE TOO LONG, RING BELL.
        MOV     A,C
        MOV     M,C             STORE THIS CHARACTER
        INX     H
        INR     B
OUTBEL:
IFN     REALIO,<
        OUTCHR>
        JMP     INLINC
OUTCON:
IFN     CONTRW,<
        JNZ     PPSWRT>         ;NO, DO OUTPUT
IFN     REALIO,<                ;MITS I/O
IFN     LPTSW,<
        LDA     PRTFLG          ;SEE IF WE WANT TO TALK TO LPT
        ORA     A               ;TEST BITS
        JZ      TTYCHR          ;IF ZERO THEN NOT
        POP     PSW             ;GET CHARACTER WE WANT TO PRINT
        PUSH    PSW
        CPI     13              ;IS IT CARRIAGE RETURN?
        CZ      PRINTW          ;FORCE OUT A LINE
        JC      PPSWRT          ;IF FUNNY CONTROL CHARACTER (LF) DO NOTHING
        LDA     LPTPOS          ;WHERE ARE WE?
        CPI     LPTLEN          ;AT THE END?
        CNC     PRINTW          ;YES, START OVER
        INR     A
        STA     LPTPOS
LPTWAT: IN      2
        ANI     2
        JZ      LPTWAT
        POP     PSW
        OUT     3               ;SEND OUT CHAR
        RET                     ;RETURN
PATLPT: BLOCK   20
FINLPT: XRA     A               ;RESET PRINT FLAG SO OUTPUT
        STA     PRTFLG          ;GOES TO THE TERMINAL
        LDA     LPTPOS          ;SEE IF ANY LEFTOVERS MUST BE
        ORA     A               ;FORCED OUT
        RZ                      ;BY LOOKING AT LPTPOS
PRINTW: IN      2               ;MAKE SURE LAST PRINT
        ANI     2               ;FINISHED BY TESTING DONE
        JZ      PRINTW          ;BIT
;SEE IF BUFFER MUST BE EMPTIED
        LDA     LPTPOS
        ORA     A               ;CHARACTERS IN THE BUFFER?
        JNZ     PRINTR          ;IF SO DON'T CLEAR THE BUFFER
        MVI     A,4             ;OTHERWISE BUFFER MUST BE EMPTIED
        OUT     2               ;CLEAR THE BUFFER
                                ;TO PRINT A BLANK LINE
PRINTR: MVI     A,1             ;TELL LPT TO PRINT
        OUT     2               ;STATUS REG
        DCR     A               ;[A]=0
        STA     LPTPOS          ;RESET LINE PRINT POSITION
        RET>
TTYCHAR:>
IFN     STRING,<
        POP     PSW             ;GET THE CHARACTER
        PUSH    PSW             ;AND SAVE IT AGAIN
        CPI     32              ;IS THIS A MEANINGFUL CHARACTER?
        JC      TRYOUT>         ;IF IT'S A NON-PRINTING CHARACTER
                                ;DON'T INCLUDE IT IN TTYPOS
IFN     LENGTH!CONTRW!LPTSW,<
        LDA     TTYPOS>         ;SEE IF PRINT READ IS AT THE END OF THE LINE
        CPI     LINLEN          ;MODIFIED BY "TERMINAL WIDTH?" QUESTION IN INIT
LINPT1==:.-1
        CZ      CRDO            ;TYPE CRLF AND SET TTYPOS AND [A]=O IF SO
        INR     A               ;INCREMENT TTYPOS SINCE WE'RE
                                ;GOING TO PRINT A CHARACTER.
        STA     TTYPOS          ;STORE NEW PRINT HEAD POSITION
TRYOUT:
IFN     REALIO,<
NOPRIN: IN      0               ;GET STATUS
CNLCA1==.-1                     ;CONSOLE COMMAND CHANGE LOC
        ANI     ODONE           ;OK TO SEND CHAR
        JNZ     NOPRIN>         ;KEEP LOOKING
        POP     PSW             ;GET CHARACTER BACK
        OUT     TTOCHN          ;SEND OUT THE CHAR
CNLCB1==.-1                     ;CONSOLE COMMAND CHANGE LOC
        RET                     ;RETURN FROM OUTCHR
INCHR:  IFN     REALIO,<
TRYIN:  IN      0               ;GET STATUS
CNLCA2==.-1                     ;CONSOLE COMMAND CHANGE LOC
        ANI     IDONE           ;TEST BIT
        JNZ     TRYIN>          ;GO BACK & DO IT AGAIN
        IN      TTICHN          ;GET A CHAR
CNLCB2==.-1                     ;CONSOLE COMMAND CHANGE LOC
        ANI     127             ;GET RID OF PARITY BIT
IFN     CONTRW,<
        CPI     CONTW           ;IS IT SUPRESS OUTPUT?
        RNZ
        LDA     CNTWFL
        CMA                     ;COMPLEMENT ITS STATE
        STA     CNTWFL>         ;SAVE BACK
        RET
PAGE
SUBTTL  THE "LIST" COMMAND
IFN     LENGTH-2,<
IFN     LPTSW,<
LLIST:  MVI     A,1             ;GET NON ZERO VALUE
        STA     PRTFLG>         ;ASVE IN I/O FLAG
LIST:   CALL    LINGET          ;GET LINE NUMBER INTO [D,E]
        RNZ                     ;MUST BE A TERMINATOR OR ERROR
        POP     B               ;GET RID OF NEWSTT RETURN ADDT
        CALL    FNDLIN          ;FIND LINE GREATER THAN OR EQUAL TO [D,E]
        PUSH    B               ;SAVE START POINTER
LIST4:  POP     H               ;GET POINTER TO LINE
        PUSHM                   ;PUSH LINK
        POP     B               ;TAKE OFF FOR A SECOND
        MOV     A,B             ;SEE IF END OF CHAIN
        ORA     C
        JZ      READY
IFN     LISTEN,<
        CALL    ISCNTC>         ;CHECK FOR CONTROL-C
        PUSH    B               ;PUT BACK ON
        CALL    CRDO            ;DO CRLF TO START OUT
        PUSHM                   ;PUSH LINE #
        XTHL                    ;GET LINE # INTO [H,L]
                                ;AND WE WANT [H,L] ON THE STACK
        CALL    LINPRT          ;PRINT AS INT WITOUT LEADING SPACE
        MVI     A," "
PRIT4:  POP     H               ;RESTORE POINTER TO START OF TEXT
PLOOP:  OUTCHR                  ;ALWAYS A SPACE AFTER THE LINE #
        MOV     A,M             ;GET A CHARACTER FROM LINE.
        ORA     A               ;IS IT A RESERVED WORD
        INX     H               ;INCREMENT POINTER INTO TEXT
        JZ      LIST4           ;ZERO, END OF LINE, GET NEXT LINE
        JP      PLOOP           ;REGULAR CHAR, JUST PRINT IT
        SUI     127             ;GET RID OF SIGN BIT AND ADD ONE
        MOV     C,A             ;GET RESERVED WORD # IN C
        PUSH    H               ;SAVE CURRENT POSIT
        LXI     D,RESLST        ;GET RESLST POINTER.
RESRCH: PUSH    D               ;SAVE

RESCR1: LDAX    D               ;GET CHARACTER FROM RESLST
        INX     D               ;BUMP RESLST POINTER
        ORA     A               ;TEST BITS
        JP      RESCR1          ;NOT AT END OF RESERVED WORD YET
        DCR     C               ;DECREMENT CHAR
        POP     H               ;POP START POINTER HERE
        JNZ     RESRCH          ;NOT AT END OF RESLST YET.
;HERE WHEN FOUND RIGHT RESERVED WORD
PRIT3:  MOV     A,M             ;GET A CHARACTER FROM RESERVED WORD
        ORA     A               ;SET CONDITION CODES
        JM      PRIT4
        OUTCHR
        INX     H               ;BUMP RESLST POINTER
        JMP     PRIT3>          ;PRINT THE REST
PAGE
SUBTTL  "FOR" STATEMENT
;
; NOTE:
;
; A FOR ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
;
; LOW ADDRESS
;       TOKEN (FORTK IN HIGH BYTE)  1 BYTE
;       A POINTER TO THE LOOP VARIABLE  2 BYTES
;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
;       THE STEP 4 BYTES
;       THE UPPER VALUE 4 BYTES
;       THE LINE # OF THE "FOR" STATEMENT 2 BYTES
;       A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
; HIGH ADDRESS
;
; TOTAL 16 BYTES
;
FOR:    IFN     LENGTH,<
        MVI     A,100
        STA     SUBFLG>         ;DONT RECOGNIZE SUBSCRIPTED VARIABLES
        CALL    LET             ;EAD THE VARIABLE AND ASSIGN IT
                                ;THE CORRECT INTIAL VALUE
                                ;AND STORE A POINTER
                                ;TO THE VARIABLE IN [TEMP]
        XTHL                    ;SAVE TEXT PTR ON THE STACK
        CALL    FNDFOR          ;MUST HAVE VARIABLE POINTER IN [D,E]
        POP     D               ;[D,E]=TEXT POINTER
        JNZ     NOTOL           ;IF NO MATCHING ENTRY, DON'T
                                ;ELIMINATE ANYTHING
        DAD     B               ;IN THE CASE OF "FOR"
                                ;WE ELIMINATE THE MATCHING ENTRY
                                ;AS WELL AS EVERYTHING AFTER IT
        SPHL                    ;DO THE ELIMINATION
                                ;SINCE A MATCHING ENTRY WAS FOUND
NOTOL:  XCHG                    ;[H,L]=TEXT POINTER
        CALL    GETSTK
        8                       ;MAKE SURE 16 BYTES ARE AVAILABLE
                                ;OFF OF THE STACK
        PUSH    H               ;REALLY SAVE THE TEXT POINTER
        CALL    DATA            ;GET AN [H,L] THAT POINTS
                                ;JUST BEYOND THE TERMINATOR
        XTHL                    ;PUT [H,L] POINTER TO TERMINATOR ON THE STACK
                                ;AND RESTORE [H,L] AS TEXT POINTER AT
                                ;VARIABLE NAME
        PUSH    H               ;PUSH THE TEXT POINTER ONTO THE STACK
        LHLD    CURLIN          ;[H,L] GET THE CURRENT LINE #
        XTHL                    ;NOW THE CURRENT LINE # IS ON THE STACK AND
                                ;[H,L] IS THE TEXT POINTER
IFN     LENGTH-2,<
IFN     STRING,<CALL    CHKNUM>>
        SYNCHK  TOTK            ;"TO" IS NECESSARY
IFN     LENGTH-2,<              ;READ FINAL VALUE
        CALL    FRMNUM>
IFE     LENGTH-2,<
        CALL    FRCSNG>
        PUSH    H               ;SAVE THE TEXT POINTER
IFE     LENGTH-2,<
        CALL    FRCSNG>
        CALL    MOVRF           ;GET THE STUFF
        POP     H               ;REGAIN TEXT POINTER
        PUSH    B               ;OPPOSITE OF PUSHR
        PUSH    D               ;SAVE THE SIGN OF THE INCREMENT
        LXI     B,$CODE+^O201*256
        MOV     D,C
        MOV     E,D             ;GET 1.0 IN THE REGISTERS
        MOV     A,M             ;GET TERMINATING CHARACTER
        CPI     STEPTK          ;DO WE HAVE "STEP" ?
        MVI     A,1             ;SETUP DEFAULT SIGN
        JNZ     ONEON           ;PUSH SOME CONSTANTS ON IF NOT
IFN     LENGTH-2,<
IFN     STRING,<
        CHRGET
        CALL    FRMNUM>>        ;READ THE STEP
IFE     <LENGTH-2>&STRING,<
        CALL    FRMCHK>         ;DON'T NEED TO CHECK THE TYPE
        PUSH    H
IFE     LENGTH-2,<
        CALL    FRCSNG>
        CALL    MOVRF           ;SET UP THE REGISTERS
        POP     H
        FSIGN                   ;GET THE SIGN OF THE INCREMENT
ONEON:  PUSH    B               ;PUT VALUE ON BACKWARDS
        PUSH    D               ;OPPOSITE OF PUSHR
IFORDN: PUSH    PSW             ;SAVE THE SIGN OF THE INCREMENT
        INX     SP              ;A ONE BYTE ENTRY ONLY
        PUSH    H
        LHLD    TEMP            ;GET THE POINTER TO THE VARIABLE BACK
        XTHL                    ;PUT THE POINTER TO THE VARIABLE
                                ;ONTO THE STACK AND RESTORE THE TEXT POINTER
NXTCON: MVI     B,FORTK         ;PUT A "FOR" TOKEN ONTO THE STACK
        PUSH    B
        INX     SP              ;THE "TOKEN" ONLY TAKES ONE BYTE OF
                                ;STACK SPACE
;       JMP     NEWSTT          ;ALL DONE
PAGE
SUBTTL NEW STATEMENT FETCHER
;
;
;
;
;
;
NEWSTT:
IFN     LISTEN,<
IFN     LENGTH,<
        IN      0               ;CHECK FOR A CHARACTER WITHOUT
                                ;DOING A "CALL" FOR SPEED
CNLCA4==:.-1
        ANI     IDONE           ;CHARACTER THERE?
        CZ      CNTCCN>         ;SEE IF IT'S A CONTROL-C
IFE     LENGTH,<
        CALL    ISCNTC>>
IFN     LENGTH,<
        SHLD    TEMP>           ;USED BY CONTINUE AND INPUT AND CLEAR
                                ;TO REMEMBER HOW TO RESTART THIS
                                ;STATEMENT
IFN     LPTSW,<XRA      A       ;FOR PRINT TO GO TO TTY AFTER LPRINT
        STA     PRTFLG>
        MOV     A,M             ;GET CURRENT CHARACTER
                                ;WHICH TERMINATED THE LAST STATEMENT
        CPI     ":"             ;IS IT A COLON
        JZ      GONE
        ORA     A
        JNZ     SNERR           ;MUST BE ZERO
        INX     H
        MOV     A,M             ;CHECK POINTER TO SEE IF
                                ;IT IS ZERO, IF SO WE ARE AT THE
                                ;END OF THE PROGRAM
        INX     H
        ORA     M               ;OR IN HIGH PART
        INX     H
        JZ      ENDCON          ;RAN OFF THE END -- OK
        MOVE    E,M
        INX     H
        MOV     D,M             ;GET LINE # IN [D,E]
        XCHG                    ;[H,L]=LINE #
        SHLD    CURLIN          ;SETUP CURLIN WITH THE CURRENT LINE #
IFE     LENGTH-2,<              ;TRACE FEATURE
        LDA     TRCFLG          ;SEE IF TRACE IT ON
        ORA     A               ;NON-ZERO MEANS YES
        JZ      NOTTRC          ;SKIP THIS PRINTING
        PUSH    D               ;SAVE THE TEXT POINTER
        MVI     A,"["           ;FORMAT THE LINE NUMBER
        OUTCHR                  ;OUTPUT IT
        CALL    LINPRT          ;PRINT THE LINE # IN [H,L]
        MVI     A,"]"           ;SOME MORE FORMATING
        OUTCHR
        POP     D               ;[D,E]=TEXT POINTER
NOTTRC:>
        XCHG                    ;RESTORE THE TEXT POINTER
GONE:   CHRGET                  ;GET THE STATEMENT TYPE
        LXI     D,NEWSTT        ;PUSH ON A RETURN ADDRESS OF NEWSTT
        PUSH    D               ;STATEMENT
GONE3:  RZ                      ;IF A TERMINATOR TRY AGAIN
                                ;"IF" COMES HERE
GONE2:  SUI     ENDTK           ;"ON ... GOTO" AND "ON ... GOSUB"
        JC      LET             ;MUST BE A LET
NUMCMD=SCRATK-ENDTK+1
        CPI     NUMCMD
        JNC     SNERR           ;SOME RESERVED WORD,BUT NOT
                                ;A STATEMENT RESERVED WORD
        RLC                     ;MULTIPLY BY 2
        MOV     C,A
        MVI     B,0
        XCHG
        LXI     H,STMDSP        ;STATEMENT DISPATCH TABLE
        DAD     B               ;ADD ON OFFSET
        MOV     C,M             ;PUSH THE ADDRESS TO GO TO ONTO
        INX     H               ;THE STACK
        MOV     B,M             ;PUSHM SAVES BYTES BUT NOT SPEED
        PUSH    B
        XCHG                    ;RESTORE THE TEXT POINTER
IFE     LENGTH,<
        CHRGET                  ;EAT THE FIRST CHARACTER
        RET>                    ;GO DO THE STATEMENT
IFN     LENGTH,<
CHRGTR: INX     H               ;DUPLICATION OF CHRGET RST FOR SPEED
        MOV     A,M             ;SEE CHRGET RST FOR EXPLANATION
        CPI     ":"
        RNC>
;
; CHRCON IS THE CONTINUATION OF THE CHRGET RST
;
CHRCON: CPI     " "             ;MUST SKIP SPACES
        JZ      CHRGTR          ;GET ANOTHER CHARACTER
        CPI     "0"             ;ALL CHARACTERS GREATER THAN
                                ;"9" HAVE RETURNED, SO SEE IF NUMERIC
        CMC                     ;MAKE NUMERICS HAVE CARRY ON
        INR     A               ;SET ZERO IF [A]=0
        DCR     A
        RET
PAGE
SUBTTL RESTORE,STOP,END,LINGET,CHRCON
RESTOR: XCHG                    ;SAVE [H,L] IN [D,E]
        LHLD    TXTTAB
        DCX     H               ;INITIALIZE DATPTR TO [TXTTAB]-1
RESFIN: SHLD    DATPTR          ;READ FINISHES COME TO RESFIN
        XCHG                    ;GET THE TEXT POINTER BACK
        RET
IFN     LISTEN,<
ISCNTC: IN      0
CNLCA3==.-1                     ;CONSOLE COMMAND CHANGE LOC
        ANI     IDONE
        RNZ                     ;IF NO CHARACTERS THAN NO ^C
CNTCCN: CALL    INCHR
        CPI     3               ;STOP CHARACTER IS ^C
IFE     LENGTH,<
        JMP     STOP>>
IFN     LENGTH,<
STOP:   RNZ                     ;RETURN IF NOT CONTROL-C AND MAKE
                                ;SURE "STOP" STATEMENTS HAVE A TERMINATOR
        XWD     ^O1000,^O366    ;SETUP [A] AS A FLAG WHETHER
                                ;TO TYPE THE BREAK MESSAGE
END:    RNZ                     ;MAKE SURE "END" STATEMENTS HAVE A TERMINATOR
        SHLD    TEMP            ;SAVE FOR "CONTINUE"
STPEND: POP     B               ;POP OFF NEWSTT ADDRESS
ENDCON: PUSH    PSW             ;SAVE THE MESSAGE FLAG
                                ;ZERO MEANS DON'T PRINT "BREAK"
        LHLD    CURLIN          ;SAVE CURLIN
        MOV     A,L
        ANA     H               ;SEE IF IT WAS DIRECT
        INR     A
        JZ      DIRIS           ;IF NOT SET UP FOR CONTINUE
        SHLD    DLDLIN          ;SAVE OLD LINE #
        LHLD    TEMP            ;GET POINTER TO START OF STATEMENT
        OLDTXT                  ;SAVE IT
DIRIS:
IFN     CONTRW,<
        XRA     A
        STA     CNTWFL>         ;FORCE OUTPUT
        POP     PSW             ;GET BACK ^C FLAG
        LXI     H,BRKTXT        ;"BREAK"
        JNZ     ERRFIN          ;CALL STROUT AND FALL INTO READY
        JMP     READY>          ;TYPE "READY"
IFE     REALIO,<
DDT:    POP     B
        HRRZ    14,JOBDDT##
        JRST    0(14)>
IFN     LENFTH,<
CONT:   RNZ                     ;MAKE SURE THERE IS A TERMINATOR
        MVI     E,ERRCN
        LHLD    OLDTXT          ;A STORED TEXT POINTER OF
                                ;ZERO IS SETUP BY STKINI
                                ;AND INDICATES THERE IS NOTHING
                                ;TO CONTINUE
        MOV     A,H             ;"STOP","END",TYPING CRLF
        ORA     L               ;TO "INPUT" AND ^C SETUP OLDTXT
        JNZ     ERROR
        XCHG                    ;SAVE [H,L]
        LHLD    OLDLIN
        SHLD    CURLIN          ;SET UP OLD LINE # AS CURRENT LINE #
        XCHG                    ;RESTORE [H,L]
        RET>
IFN     LENGTH,<
NULL:   CALL    GETBYT
        RNZ                     ;MAKE SURE THERE IS A TERMINATOR
        INR     A
        CPI     LINLEN          ;MAKE SURE THE NUMBER IS REASONABLE
                                ;CRDO WON'T WORK IF IT ISN'T
LINPT2==:.-1                    ;TERMINAL WIDTH CHANGE LOCATION
        JNC     FCERR           ;"FUNCTION CALL" ERROR
        STA     NULCNT          ;CHANGE NUMBER OF NULLS
        RET>
IFE     LENGTH-2,<
TON:    XWD     ^O1000,^O76     ;"MVI A," NON-ZERO QUANTITY
TOFF:   XRA     A               ;MAKE [A]=0 FOR NO TRACE
        STA     TRCFLG          ;UPDATE THE TRACE FLAG
        RET>
;
;TEST FOR A LETTER / CARRY ON=NOT A LETTER
;                    CARRY OFF=A LETTER
;
ISLET:  MOV     A,M
        CPI     "A"
        RC                      ;IF LESS THAN "A", RETURN EARLY
        CPI     91              ;91="Z"+1
        CMC
        RET
;
; INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
; TURNS IT INTO A POSITIVE INTEGER
; LEAVING THE RESULT IN [D,E].  NEGATIVE ARGUMENTS
; ARE NOT ALLOWED. [H,L] POINTS TO THE TERMINATING
; CHARACTER OF THE FORMULA ON RETURN.
;
IFN     LENGTH-2,<
INTIDX: CHRGET
INTID2: CALL    FRMNUM
POSINT: FSIGN
        JM      FCERR           ;IF NEGATIVE BLOW HIM OUT
DEINT:  LDA     FAC             ;SEE IF ARG GREATER THAN 32767
        CPI     144
        JC      QINT
IFN     LENGTH,<
        MOVRI   144,128,0,0     ;REGISTERS = FLOATING -32768
        CALL    FCOMP           ;SEE IF FAC=REGISTERS
        MOV     D,C             ;SETUP D=200 E=0 FOR -32768
        RZ>                     ;WAS -32768. [D,E] IS SET UP
ILLFUN:
FCERR:  MVI     E,ERRFC         ;TOO BIG. FUNCTION CALL ERROR
        JMP     ERROR>
IFE     LENGTH-2,<
INTIDX: CHRGET
INTID2: CALL    FRMEVL          ;EVALULATE A FORMULA
        PUSH    H               ;SAVE THE TEXT POINTER
        CALL    FRCINT          ;CONVERT THE FAC TO AN INTEGER
        MOV     A,H             ;SEE IF THE RESULT IS NEGATIVE
        ORA     A               ;BY LOOKING AT [H]'S MSB
        JM      FCERR           ;DON'T ALLOW NEGATIVE NUMBERS
        XCHG                    ;RETURN THE INTEGER IN [D,E]
        POP     H               ;RESTORE THE TEXT POINTER
        RET>
;
; LINGET READS A LINE # FROM THE CURRENT TEXT POSITION
;
; LINE NUMBERS RANGE FROM 0 TO 65529
;
; [D,E] IS SMASHED.
;
; ANSWER RETURNED IN [D,E].
; [H,L] IS UPDATED TO POINT TO THE TERMINATING CHARACTER
; AND [A] CONTAINS THE TERMINATING CHARCATER WITH CONDITION
; CODES SET UP TO REFLECT ITS VALUE.
;
LINGET: DCX     H
LINGT2: LXI     D,$CODE         ;ZERO ACCUMULATED LINE #
MORLIN: CHRGET
        RNC                     ;WAS IT A DIGIT
        PUSH    H
        PUSH    PSW
        LXI     H,$CODE+6552    ;SEE IF THE LINE # IS TOO BIG
        COMPAR
        JC      SNERR           ;YES, SYNTAX ERROR
        MOV     H,D             ;SAVE [D,E]
        MOV     L,E
        DAD     D
        DAD     H
        DAD     D
        DAD     H               ;PUTTING [D,E]*10 INTO [H,L]
        POP     PSW
        SUI     "O"
        MOV     E,A
        MVI     D,0
        DAD     D               ;ADD THE NEW DIGIT
        XCHG
        POP     H               ;GET BACK TEXT POINTER
        JMP     MORLIN
IFN     LENGTH,<
CLEAR:  JZ      CLEARC          ;IF NO FORMULA JUST CLEAR
        CALL    INTID2          ;GET AN INTEGER INTO [D,E]
        DCX     H
        CHRGET                  ;SEE IF ITS THE END
        RNZ                     ;SHOULD FINISH THERE
        PUSH    H               ;SAVE TXTPTR
        LHLD    MEMSIZ          ;GET HIGHEST ADDRESS
        MOV     A,L             ;SUBTRACT [H,L]-[D,E] INTO [D,E]
        SUB     E
        MOV     E,A
        MOV     A,H
        SBB     D
        MOV     D,A
        JC      SNERR           ;WANTED MORE THAN TOTAL!
        LHLD    VARTAB          ;TOP LOCATION IN USE
        LXI     B,$CODE+40      ;LEAVE BREATHING ROOM
        DAD     B
        COMPAR                  ;ROOM?
        JNC     OMERR           ;NO, DON'T EVEN CLEAR
        XCHG                    ;NEW STACK LOCATION [H,L]
        SHLD    STKTOP          ;SET UP NEW STACK LOCATION
        POP     H               ;REGAIN THE TEXT POINTER
        JMP     CLEARC>         ;GO CLEAR
PAGE
SUBTTL  RUN,GOTO,GOSUB,RETURN
IFN     LENGTH,<
RUN:    JZ      RUNC            ;NO LINE # ARGUMENT
                                ;CLEAN UP,SET [H,L]=[TXTTAB]-1 AND
                                ;RETURN TO NEWSTT
        CALL    CLEARC          ;CLEAN UP -- RESET THE STACK
                                ;DATAPTR,VARIABLES ...
                                ;[H,L] IS THE ONLY THING PRESERVED
        LXI     B,NEWSTT
        JMP     RUNC2>          ;PUT "NEWSTT" ON AND FALL INTO "GOTO"
;
; A GOSUB ENTRY ON THE STACK HAS THE FOLLOWING FORMAT
;
; LOW ADDRESS
;
;       A TOKEN EQUAL TO GOSUTK 1 BYTE
;       THE LONE # OF THE THE GOSUB STATEMENT 2 BYTES
;       A POINTER INTO THE TEXT OF THE GOSUB 2 BYTES
;
; HIGH ADDRESS
;
; TOTAL 5 BYTES
;
GOSUB:  CALL    GETSTK          ;MAKE SURE THERE IS ROOM
        3
        POP     B               ;POP OFF RETURN ADDRESS "NEWSTT"
        PUSH    H               ;REALLY PUSH THE TEXT POINTER
        PUSH    H               ;SAVE TEXT POINTER
        LHLD    CURLIN          ;GET THE CURRENT LINE #
        XTHL                    ;PUT CUTLIN ON THE STACK AND [H,L]=TEXT PTR
        MVI     D,GOSUTK        ;LEAVE A GOSUB TOKEN
                                ;ON THE STACK
        PUSH    D
        INX     SP              ;THE GOSUB TOKEN TAKES ONLY ONE BYTE
RUNC2:  PUSH    B               ;RESTORE RETURN ADDRESS
                                ;OF "NEWSTT"
;
; IN THE 4K VERSION WE START AT THE BEGINNING
; AND SEARCH. IN THE 8K WE START WHERE WE
; ARE IF WE ARE  GOING TO A FORWARD LOCATION.
;
GOTO:   CALL    LINGET          ;PICK UP THE LINE #
                                ;AND PUT IT IN [D,E]
IFE     LENGTH,<RNZ             ;SHOULD END WITH A LINE
                                ;TERMINATOR -- BLOW HIM UP
                                ;IF IT DOESN'T
                                ;(ON GOTO MAKES THIS WRONG
                                ;IN OTHER VERSONS)
        CALL    FNDLIN>
IFN     LENGTH,<
        CALL    REM             ;SKIP TO THE END OF THIS LINE
        PUSH    H               ;SAVE THE POINTER
        LHLD    CURLIN          ;GET THE CURRENT LINE #
        COMPAR                  ;[D,E] CONTAINS WHERE WE ARE GOING
                                ;[H,L] CONTAINS THE CURRENT LINE#
                                ;SO COMPARING THEM TELL US WHETHER TO
                                ;START SEARCHING FROM WHERE WE ARE OR
                                ;TO START SEARCHING FROM THE BEGINNING
                                ;OF TXTTAB
        POP     H               ;[H,L]=CURRENT POINTER
        INX     H               ;POINT AT THE LINK BEYOND IT
        CC      LOOP            ;SEARCH FROM THIS POINT
        CNC     FNDLIN>         ;SEARCH FROM THE BEGINNING -- ACTUALLY
                                ;SEARCH AGAIN IF ABOVE SEARCH FAILED
        MOV     H,B
        MOV     L,C
        DCX     H
        RC                      ;IF A MATCH WE ARE DONE
USERR:  MVI     E,ERRUS
        JMP     ERROR           ;C=MATCH,SO IF NO MATCH WE
                                ;GIVE A "US" ERROR
;
; SEE "GOSUB" FOR THE FORMAT OF THE STACK ENTRY
; "RETURN" RESTORES THE LINE NUMBER AND TEXT POINTER ON THE STACK
; AFTER ELIMINATING ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB"
; ENTRY
;
RETURN: RNZ                     ;BLOW HIM UP IF THERE ISN'T A TERMINATOR
        MVI     D,255           ;MAKE SURE THIS VARIABLE POINTER

                                ;IF [D,E] NEVER GETS MATCHED
        CALL    FNDFOR          ;GO PAST ALL THE "FOR" ENTRIES
        SPHL                    ;UPDATE THE STACK
        CPI     GOSUTK
        MVI     E,ERRRG         ;ERROR ERRRG IS "RETURN WITHOUT GOSUB"
        JNZ     ERROR
        POP     H               ;GET LINE # "GOSUB" WAS FROM
        SHLD    CURLIN          ;PUT IT INTO CURLIN
        LXI     H,NEWSTT
        XTHL                    ;PUT RETURN ADDRESS OF "NEWSTT"
                                ;BACK ONTO THE STACK. GET TEXT POINTER
                                ;FROM "GOSUB"
                                ;SKIP OVER SOME CHARACTERS
                                ;SINCE WHEN "GOSUB" STUCK THE TEXT POINTER
                                ;ONTO THE STACK THE LINE # ARGUMENT HADN'T
                                ;BEEN READ IN YET.
IFN     STRING,<
DATA:   XWD     ^O1000,^O1      ;"LXI B," TO PICK UP ":" INTO C AND SKIP
        ":"                     ;"DATA" TERMINATES ON ":"
                                ;AND 0. ":" ONLY APPLIES IF
                                ;QUOTES HAVE MATCHED UP
IFE     LENGTH-2,<ELSE:>        ;EXECUTED "ELSE"S ARE SKIPPED
;
; NOTE: REM MUST PRESERVE [D,E] BECAUSE OF "GO TO" AND ERROR
;
REM:    XWD     ^O1000,^O16     ;MVI C,   THE ONLY TERMINATOR IS 0
        XWD     ^O1000,0        ;NO-OPERATION
                                ;"DATA" ACTUALLY EXECUTES THIS 0
        MVI     B,0             ;INSIDE QUOTES THE ONLY TERMINATOR IS ZERO
EXCHQT: MOV     A,C             ;WHEN A QUOTE IS SEEN THE SECOND
        MOV     C,B             ;TERMINATOR IS TRADED, SO IN "DATA"
        MOV     B,A             ;COLONS INSIDE QUOTATIONS WILL HAVE NO EFFECT
REMER:  MOV     A,M             ;GET THE CHARACTER
        ORA     A               ;ZERO IS ALWAYS A TERMINATOR
        RZ
        CMP     B               ;TEST FOR THE OTHER TERMINATOR
        RZ
        INZ     H
        CPI     34              ;IS IT A QUOTE?
        JZ      EXCHQT          ;IF SO TIME TO TRADE
IFE     LENGTH-2,<
;
; WHEN AN "IF" TAKES A FALSE BRANCH IT MUST FIND THE APPROPRIATE "ELSE"
; TO START EXECUTION AT. "DATA" COUNTS THE NUMBER OF "IF"S
; IT SEES SO THAT THE "ELSE" CODE CAN MATCH "ELSE"S WITH
; "IF"S. THE COUNT IS KEPT IN [D]
;
        SUI     IFTK            ;IS IT AN "IF"
        JNZ     REMER           ;IF NOT, CONTINUE ON
        CMP     B               ;SINCE "REM" CAN'T SMASH
                                ;[D,E] WE HAVE TO BE CAREFUL
                                ;SO ONLY IF B DOESN'T EQUAL
                                ;ZERO WE CAN INCREMENT D. (THE "IF" COUNT)
        ADC     D               ;CARRY ON IF [B] NOT ZERO
        MOV     D,A>            ;UPDATE [D]
        JMP     REMER>
;
; WITHOUT STRINGS THERE IS NO NEED TO WATCH QUOTATIONS
; SO [B] IS SET UP AS THE SECONDARY TERMINATOR
; AND A SCAN IS MADE FOR [B] OR ZERO
;
IFE     STRING,<
DATA:   XWD     ^O01000,1       ;MAKE [C]=":" AND SKIP
        ":"
REM:    XWD     ^O1000,16       ;MAKE [C]=0
        XWD     ^O1000,0        ;ZERO AND NO-OPERATION
LOOPDR: MOV     A,M
        ORA     A               ;ALWAYS STOP ON ZERO
        RZ
        CMP     C               ;CHECK FOR ":" IN DATA
        RZ
        INX     H               ;LOOK AT NEXT CHARACTER
        JMP     LOOPDR>
PAGE
SUBTTL "LET"
LET:    CALL    PTRGET          ;GET THE POINTER TO THE VARIABLE
                                ;NAMED IN TEXT AND PUT
                                ;IT ON THE STACK. [H,L] REMAINS
                                ;THE TEXT POINTER AND A,PSW ARE SETUP
                                ;AS THE TERMINATING CHARACTER.
        SYNCHK  EQULTK          ;CHECK FOR "="
REDINP:
IFN     STRING,<
        LDA     VALTYP
        PUSH    PSW>
        PUSH    D
        CALL    FRMEVL          ;GET THE VALUE OF THE FORMULA
                                ;INTO FAC
        XTHL                    ;[H,L]=POINTER TO VARIABLE
                                ;TEXT POINTER TO ON TOP OF STACK
        SHLD    TEMP            ;SAVE VARIABLE POINTER ON "FOR"
IFN     STRING,<
        POP     D               ;GET TEXT POINTER OFF
        POP     PSW             ;GET THE VALTYP OF THE
                                ;VARIABLE INTO [A]
        PUSH    D               ;RESAVE THE TEXT-POINTER
IFE     LENGTH-2,<
        CPI     3               ;SEE IF ITS A STRING
INPCOM: PUSH    H               ;SAVE THE POINTER AT THE VALUE POSITION
        JNZ     COPNUM          ;NUMERIC, SO FORCE IT AND COPY
        CALL    CHKSTR>         ;MAKE SURE THE FORMULA WAS A STRING
IFN     LENGTH-2,<
        RAR                     ;CARRY SET FOR STRING OFF
                                ;FOR NUMERIC
        CALL    CHKVAL          ;MAKE SURE VALTYP MATCHES CARRY
                                ;AND SET THE ZERO FLAG
                                ;ON A NUMERIC VALTYP
        JZ      COPNUM          ;IF A NUMBER COPY
INPCOM: PUSH    H>              ;SAVE POINTER AT VARIABLE
        LHLD    FACLO           ;GET POINTER TO THE DESCRIPTOR OF THE RESULT
        PUSH    H               ;SAVE THE POINTER AT THE DESCRIPTOR
        INX     H
        INX     H
        PUSHM
        POP     D
        LHLD    STKTOP          ;SEE IF IT POINTS INTO STRING SPACE
        COMPAR                  ;IF NOT DON'T COPY
        POP     D               ;GET BACK THE POINTER AT THE DESCRIPTOR
        JNC     DNTCPY          ;DON'T COPY LITERALS
        LHLD    VARTAB          ;NOW, SEE IF ITS A VARIABLE
        COMPAR                  ;BY SEEING IF THE  DESCRIPTOR
        MOV     L,E
        MOV     H,D
        CC      STRCPY          ;IS BEYOND [VARTAB], IF SO COPY
DNTCPY: LDAX    D               ;GET THE LENGTH AND SAVE IT
        PUSH    PSW             ;SINCE WE ARE GOING TO SET IT TO
                                ;0 SO FRETMP DOESN'T UPDATE FRETOP
        XRA     A               ;SET IT TO 0 -- ELIMINATING NNULL
                                ;STRING IN FRETMP IS HARMLESS
        STAX    D               ;PUT 0 IN THE LENGTH FIELD
        CALL    FRETMP          ;FREE IT UP
        POP     PSW             ;GET LENGTH BACK
        MOV     M,A             ;REPLACE IT [ FRETMP RETURNS [D,E] IN [H,L] ]
        XCHG                    ;PUT THE DESCRIPTOR POINTER BACK IN [D,E]
        POP     H               ;GET THE PLACE OF THE NEW VARIABLE
IFN     LENGTH-2,<
        CALL    MOVE>           ;COPY THE DESCRIPTOR
IFE     LENGTH-2,<
        CALL    VMOVE>
        POP     H               ;GET THE TEXT POINTER BACK
        RET>
COPNUM:
IFE     LENGTH-2,<
        ANI     6               ;SETUP DISPATCH TO FORCE
                                ;FORMULA TYPE TO CONFORM
                                ;TO THE VARIABLE ITS BEING ASSIGNED TO
        LXI     H,FRCTBL        ;TABLE OF FORCE ROUTINES
        MOV     C,A             ;[B,C]=TWO BYTE OFFSET
        MVI     B,0
        DAD     B
        MOV     A,M             ;[H,L]=ADDRESS TO GO TO
        INX     H
        MOV     H,M
        MOV     L,A
        LXI     B,PUTVAL        ;RETURN TO PUTVAL
        PUSH    B
        PCHL                    ;DISPATCH TO FORCE
PUTVAL: POP     H               ;GET THE POINTER OF WHERE TO STORE
                                ;THE VALUE
        PUSH    H               ;SAVE IT BACK
        CALL    VMOVMF>         ;MOVE THE VALUE IN
IFN     LENGTH-2,<
        PUSH    H               ;SAVE THE VARIABLE POINTER FOR "FOR"
        CALL    MOVMF>          ;TRANSFER THE VALUE
        POP     D               ;"FOR" WANTS VARIABLE POINTER IN
                                ;[D,E] FOR FNDFOR
        POP     H               ;GET THE TEXT POINTER
        RET
PAGE
SUBTTL ON GOTO CODE
IFN     LENGTH,<
ONGOTO: CALL    GETBYT          ;GET VALUE INTO [E]
        MOV     A,M             ;GET THE TERMINATOR BACK
        MOV     B,A             ;SAVE THIS CHARACTER FOR LATER
        CPI     GOSUTK          ;AN "ON ... GOSUB" PERHAPS?
        JZ      ISGOSU          ;YES, SOME FEATURE USE
        SYNCHK  GOTOTK          ;OTHERWISE MUST BE "GOTO"
        DCX     H               ;BACK UP CHARACTER POINTER
ISGOSU: MOV     C,E             ;GET COUNT INTO  [C]
LOOPON: DCR     C               ;SEE IF ENOUGH SKIPS
        MOV     A,B             ;PUT DISPATCH CHARACTER IN PLACE
        JZ      GONE2           ;IF DONE, GO OFF
        CALL    LINGT2          ;SKIP OVER A LINE #
        CPI     44              ;A COMMA
        RNZ                     ;IF A COMMA DOESN'T DELIMIT THE END OF
                                ;THE LAST LINE # MUST BE THE END OF THE LINE
        JMP     LOOPON>         ;CONTINUE GOBBLING LINE #S
PAGE
SUBTTL IF ... THEN CODE
IF:     CALL    FRMEVL          ;EVALUATE A FORMULA
IFE     LENGTH,<
IFN     STRING,<
        LDA     VALTYP          ;GET VALUE TYPE INTO [A]
        PUSH    PSW>>           ;SAVE THE VALUE TYPE ON THE STACK
        MOV     A,M             ;GET TERMINATING CHARACTER OF FORMULA
IFE     LENGTH,<
        CALL    PUSHF           ;ONTO THE STACK
        MVI     D,0             ;KEEPS RELATIONAL OPERATOR MEMORIES
                                ;LESS THAN #4
                                ;EQUAL     #2
                                ;GREATER THAN #1
LOOPIF: SUI     GREATK          ;CHECK FOR A RELATIONAL OPERATOR
        JC      ENDREL          ;NOPE
NUMREL=LESSTK-GREATK+1          ;NUMBER OF RELATIONAL OPERATORS
        CPI     NUMREL          ;IS THIS ONE OF THEM?
        JNC     ENDREL          ;NO SEE WHAT WE HAVE
        CPI     1               ;SETUP BITS BY MAPPING
        RAL                     ;0 TO 1, 1 TO 2, AND 2 TO 4
        ORA     D               ;OR WITH EARLIER BITS
        MOV     D,A             ;STORE NEW BITS
        CHRGET                  ;GET NEW CHARACTER
        JMP     LOOPIF          ;SEE IF RELATIONAL
ENDREL: MOV     A,D             ;GET RELATIONAL MEMORIES
        ORA     A               ;SEE IF THERE ARE ANY
        JZ      SNERR           ;NO RELATIONAL OPERATORS!
        PUSH    PSW             ;SAVE RELATIONAL MEMORIES
        CALL    FRMEVL>         ;PICK UP FIRST NON-RELATIONAL
                                ;CHARACTER AGAIN AND INTERPRET FORMULA
                                ;ANSWER LEFT IN FAC
IFE     LENGTH-2,<CPI   44      ;A COMMA?
        CZ      CHRGTR>         ;IF SO SKIP IT
IFN     LENGTH,<
        CPI     GOTOTK          ;ALLOW "GOTO" AS WELL
        JZ      OKGOTO>
        SYNCHK  THENTK          ;MUST HAVE A THEN
        DCX     H
OKGOTO:
IFE:    LENGTH,<
        POP     PSW
        POPR                    ;POP OFF NUMBER
IFN     STRING,<
        XTHL>                   ;COMPARE FORMULA TYPES
IFE     STRING,<PUSH    H>      ;SAVE THE TEXT POINTER
        PUSH    PSW             ;RESAVE RELATIONAL MEMORIES
IFN     STRING,<
        LDA     VALTYP          ;GET VALUE TPYE
        CMP     H               ;[H] HAS OLD VALTYP ARE THEY =?
        JNZ     TMERR           ;IF NOT ITS A TYPE ERROR
        ORA     A               ;SEE WHAT TYPE IT WAS
        JZ      NUMCMP          ;ZERO MEANS IT WAS NUMERIC
        CALL    STRCMP          ;MUST BE A STRING SO STRING COMPARE
        JMP     SKPNCM>         ;SKIP OVER NUMERIC COMPARE
NUMCMP: CALL    FCOMP           ;COMPARE THE 2 SIDE OF THE RELATION STATMENT
SKPNCM: INT     A               ;BUILD RELATIONAL BITS
        RAL                     ;LESS=4 EQUAL=2 GREATER=1
                                ;SINCE CARRY IS ON ONLY IN
                                ;377  CASE (FCOMP & STRCMP)
        POP     B               ;POP OFF WHAT RELATIONAL OPERATOR HAS
        ANA     B>              ;SEE IF WE MATCHED
IFN     LENGTH,<
IFE     LENGTH-2,<
        CALL    VSIGN##>
IFN     LENGTH-2,<
        FSIGN>>                 ;0=FALSE ALL OTHERS=TRUE
IFE     LENGTH,<
        POP     H>              ;POP OFF TEXT POINTER
IFE     LENGTH-2,<
        JZ      FALSIF>         ;HANDLE POSSIBLE "ELSE"
IFN     LENGTH-2,<
        JZ      REM>            ;IF TEST FAILED -- JUST SKIP REST OF THE LINE
DOCOND: CHRGET                  ;PICK UP THE FIRST LINE # CHARACTER
        JC      GOTO            ;LINE NUMBER MEANS "GOTO"
        JMP     GONE3           ;INTERPRET NEW STATEMENT
IFE     LENGTH-2,<
;
; "ELSE" HANDLER. HERE ON FALSE "IF" CONDITION
;
FALSIF: MVI     D,1             ;NUMBER OF "ELSE"S THAT MUST
                                ;BE SEEN. "DATA" INCREMENTS THIS
                                ;COUNT EVERY TIME AN "IF" IS SEEN
SKPMRF: CALL    DATA            ;SKIP A STATEMENT
                                ;":" IS STUCK IN FRONT OF "ELSE"S
                                ;SO THAT "DATA" WILL STOP BEFORE "ELSE" CLAUSES
        ORA     A               ;END OF LINE?
        RZ                      ;IF SO, NO "ELSE" CLAUSE
        CHRGET                  ;SEE IF WE HIT AN "ELSE"
        CPI     ELSETK
        JNZ     SKPMRF          ;NO, STILL IN THE "THEN" CLAUSE
        DCR     D               ;DECREMENT THE NUMBER OF "ELSE"S THAT
                                ;MUST BE SEEN
        JNZ     SKPMRF          ;SKIP MORE IF HAVEN'T SEEN
                                ;ENOUGH
        JMP     DOCONO>         ;FOUND THE RIGHT "ELSE" -- GO EXECUTE
PAGE
SUBTTL PRINT CODE
IFN     LPTSW,<
LPRINT: MVI     A,1             ;SAY NON ZERO
        STA     PRTFLG>         ;SAVE AWAY
NEWCHR: DCX     H
MORPR:  CHRGET                  ;GET ANOTHER CHARACTER
PRINT:  JZ      CRDO            ;IF WE SEE A TERMINATOR
                                ;GO TYPE A CRLF
PRINTC: RZ                      ;HERE AFTER SEEING TAB(X) OR , OR ;
                                ;IN WHICH CASE A TERMINATOR DOES NOT
                                ;MEAN WE SHOULD TYPE A CRLF
                                ;BUT JUST RETURN
IFE     STRING,<
        CPI     34              ;A TERMINATING QUOTE?
        CZ      STROUI
        JZ      NEWCHR>         ;A QUOTATION -- JUST PRINT IT
        CPI     TABTK
        JZ      TABER           ;THE TAB FUNCTION?
IFN     LENGTH,<
        CPI     SPCTK
        JZ      TABER>          ;THE SPC FUNCTION?
        PUSH    H               ;SAVE THE TEXT POINTER
        CPI     44
        JZ      COMPRT          ;IS IT A COMMA?
        CPI     59              ;IS IT A ";"
        JZ      NOTABR
        POP     B               ;GET RID OF OLD TEXT POINTER
        CALL    FRMEVL          ;BACK UP ONE CHARACTER AND READ THAT ONE
                                ;AGAIN SO THE CONDITION CODES ARE RIGHT
                                ;EVALUATE THE FORMULA
        DCX     H               ;BACKUP FROM TERMINATOR
        PUSH    H               ;SAVE TEXT POINTER
IFN     STRING,<
IFE     LENGTH-2,<
        CALL    GETYPE          ;SEE IF WE HAVE A STRING
        JZ      STRDON>         ;IF SO, PRINT SPECIALY
IFN     LENGTH-2,<
        LDA     VALTYP
        ORA     A
        JNZ     STRDON>>        ;WAS IT A STRING FORMULA?
        CALL    FOUT            ;MAKE A NUMBER INTO A STRING
IFE     STRING,<CALL    STROUT> ;IF STRINGS OFF JUST OUTPUT IT
IFN     STRING,<
        CALL    STRLIT          ;MAKE IT  A STRING
        LHLD    FACLO           ;GET THE POINTER
IFN     LPTSW,<
        LDA     PRTFLG
        ORA     A
        JZ      ISTTY           ;LPT OR TTY?
        LDA     LPTPOS
        ADD     M
        CPI     LPTLEN          ;WILL THIS NUMBER OVERLAP?
        JMP     LINCHK
ISTTY:>
        LDA     TTYPOS          ;SEE WHERE WE ARE
        ADD     M               ;ADD THIS LENGTH
        CPI     LINLEN          ;SEE IF GREATER THAN THE LINE LENGTH
LINPT3==:.-1
LINCHK: CNC     CRDO            ;IF SO CRLF
        CALL    STRPRT>         ;PRINT THE NUMBER
        MVI     A," "           ;ALWAYS END WITH A SPACE
        OUTCHR
IFN     STRING,<
IFE     LENGTH-2,<
        ORA     A               ;TURN OFF THE ZERO FLAG
STRDON: CZ      STRPRT>
IFN     LENGTH-2,<
        XRA     A
STRDON: CNZ     STRPRT>>        ;JUST PRINT STRINGS
        POP     H
        JMP     MORPR           ;PRINT SOME MORE
FININL: MVI     M,0             ;PUT A ZERO AT THE END OF BUF
        LXI     H,BUFMIN        ;SETUP POINTER
CRDO:   IFN      LPTSW, <
        LDA     PRTFLG
        ORA     A
        JNZ     PRINTW>
        MVI     A,13
        STA     TTYPOS          ;MAKE TTYPOS LESS THAN LINE LENGTH
                                ;SO CRDO DOESN'T GET CALLED AGAIN
        OUTCHR
        MVI     A,10
        OUTCHR
CRFIN:  LDA     NULCNT          ;GET NUMBER OF NULLS
PRTNUL: DCR     A
        STA     TTYPOS          ;EVENTUALLY SETUP TTYPOS=0
        RZ                      ;ALL NULLS DONE [A]=0
                                ;SOME ROUTINES DEPEND ON CRDO
                                ;AND CRFINS RETURN [A]=0 AND Z  TRUE
        PUSH    PSW             ;SAVE THE COUNT
        XRA     A               ;[A]= A NULL
        OUTCHR                  ;SEND IT OUT
        POP     PSW             ;RESTORE THE COUNT
        JMP     PRTNUL          ;LOOP PRINTING NULLS
IFE     STRING,<
STROUI: INX     H
STROUT: MOV     A,M
        ORA     A               ;CHECK FOR END OF LINE
        RZ                      ;LET IT END THAT WAY
        INX     H
        CPI     34              ;A TERMINATING QUOTE?
        RZ                      ;DONE IF SO
        OUTCHR                  ;PRINT THE CHARACTER IN [A]
        CPI     CR              ;IF IT'S A CARRIAGE RETURN
        CZ      CRDO            ;TYPE LINE-FEED AND SET [TTYPOS]=0
        JMP     STROUT>         ;PRINT MORE CHARACTERS
COMPRT: IFN     LPTSW,<
        LDA     PRTFLG          ;OUTPUT TO THE LINE PRINTER?
        ORA     A               ;NON-ZERO MEANS YES
        JZ      ISCTTY          ;NO, DO TELETYPE COMMA
        LDA     LPTPOS          ;GET LINE PRINTER POSITION
NLPPOS==<<<LPTLEN/CLMWID>-1>*CLMWID>;POSITION BEYOND WHICH THERE ARE
                                ;NO MORE COMMA FIELDS, SO
        CPI     NLPPOS          ;COMMA JUST DOES A "CRDO"
        JMP     CHKCOM          ;USE TELETYPE CHECK
ISCTTY:>
        LDA     TTYPOS          ;GET TELETYPE POSITION
NUTPOS==<<<LINLEN/CLMWID>-1>*CLMWID>;POSITION BEYOND WHICH THERE ARE
                                ;NO MORE COMMA FIELDS
        CPI     NUTPOS          ;SO ALL COMMA DOES IS A "CRDO"
LINPT4==:.-1                    ;FIXED UP BY "TERMINAL WIDTH" QUESTION
CHKCOM: CNC     CRDO            ;TYPE CRLF
        JNC     NOTABR          ;AND QUIT IF BEYOND THE LAST COMMA FIELD
MORCOM: SUI     CLMWID          ;GET [A] MODULUS CLMWID
        JNC     MORCOM
        CMA                     ;WE WANT TO  FILL
                                ;THE PRINT POSITION OUT
                                ;TO AN EVEN CLMWID, SO
                                ;WE PRINT CLMWID=[A] MOD CLMWID SPACES
        JMP     ASPA2           ;GO PRINT [A]+1 SPACES
TABER:
IFN     LENGTH,<PUSH    PSW>    ;REMEMBER IF [A]=SPCTK OR TABTK
IFE     LENGTH,<
        CALL    INTIDX>         ;INTEGERIZE A FORMULA INTO [D,E]
IFN     LENGTH,<
        CALL    GTBYTC>         ;GET VALUE INTO [E]
        SYNCHK  ")"
        DCX     H
IFN     LENGTH,<
        POP     PSW             ;GET BACK SPCTK OR TABTK
        CPI     SPCTK>          ;WAS IT SPCTK?
        PUSH    H               ;SAVE THE TEXT POINTER
IFN     LENGTH,<
        MOV     A,E             ;FOR "SPC" PUT THE FORMULA
        JZ      ASPAC>          ;VALUE IN [A]
IFN     LPTSW,<
        LDA     PRTFLG          ;LINE PRINTER OR TTY?
        ORA     A               ;NON-ZERO MEANS LPT
        JZ      TTYIST
        LDA     LPTPOS          ;GET LINE PRINTER POSITION
        JMP     DOSIZT>
TTYIST: LDA     TTYPOS          ;GET TELETYPE PRINT POSITION
DOSIZT: CMA                     ;PRINT [E]-[A] SPACES
        ADD     E
        JNC     NOTABR          ;IF NEGATIVE, DON'T PRINT ANY
                                ;SPACES
ASPA2:  INR     A
ASPAC:  MOV     B,A             ;[B]=NUMBER OF SPACES TO PRINT
        MVI     A," "           ;[A]=SPACE
REPOUT: OUTCHR                  ;PRINT [A]
        DCR     B               ;DECREMENT THE COUNT
        JNZ     REPOUT
NOTABR: POP     H               ;PICK UP TEXT POINTER
        CHRGET                  ;AND THE NEXT CHARACTER
        JMP     PRINTC          ;AND SINCE WE JUST PRINTED
                                ;SPACES, DON'T CALL CRDO
                                ;IF IT'S THE END OF THE LINE
PAGE
SUBTTL INPUT AND READ CODE
IFN     LENGTH,<
TRYAGN: DC"?REDO FROM START"
        ACRLF
        0
;
; HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
; IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
; FOR "DATA" WE GIVE A SYNTAX ERROR AT THE DATA LINE
;
TRMNOK: LDA     FLGINP          ;WAS IT READ OR INPUT?
        ORA     A               ;ZERO=INPUT
        JNZ     DATSNE          ;GIVE ERROR AT DATA LINE
        POP     B               ;GET RID OF THE POINTER INTO THE VARIABLE LIST
        LXI     H,TRYAGN
        CALL    STROUT          ;PRINT "?REDO FROM START"
        LHLD    TEMP            ;START ALL OVER BY GOING BACK
        RET>                    ;TO NEWSTT POINTING AT THE START OF
                                ;OF THE "INPUT" STATEMENT
INPUT:
IFN     LENGTH,<
        CPI     34              ;IS IT A QUOTE?
IFN     CONTRW,<
        MVI     A,0             ;BE TALKATIVE
        STA     CNTWFL>         ;FORCE OUTPUT
        JNZ     NOTQTI          ;IF NOT NO MESSAGE
IFN     STRING,<
        CALL    STRLTI          ;MAKE THE MESSAGE A STRING
        SYNCHK  59              ;MUST END WITH SEMI-COLON
        PUSH    H               ;REMEMBER WHERE IT ENDED
        CALL    STRPRT          ;PRINT IT OUT
        POP     H>
IFE     STRING,<
        CALL    STROUI
        SYNCHK  59>>            ;ENDS WITH SEMI-COLON
NOTQTI: PUSH    H
IFE     FUNCTS,<
        LHLD    CURLIN          ;IS IT DIRECT?
        MVI     E,ERRID         ;IF SO "ILLEGAL DIRECT" ERROR
        INX     H               ;DIRECT MEANS THAT
        MOV     A,L             ;CURLIN=65535
        ORA     H               ;ADDED ONE AND GOT 0?
        JZ      ERROR>          ;IF SO,GO COMPLAIN
IFN     FUNCTS,<
        CALL    ERRDIR>         ;USE COMMON ROUTINE SINCE DEF
                                ;DIRECT IS ALSO ILLEGAL
GETAGN: CALL    QINLIN          ;TYPE '?' AND INPUT A LINE OF TEXT
IFN     LENGTH,<INX     H       ;IF NO INPUT WE QUIT
        MOV     A,M
        ORA     A
        DCX     H
        POP     B               ;TAKE OFF SINCE MAYBE LEAVING
        JZ      STPEND          ;IF EMPTY LEAVE
        PUSH    B>              ;PUT BACK SINCE DIDN'T LEAVE
        JMP     INPCON
READ:   PUSH    H               ;SAVE THE TEXT POINTER
        LHLD    DATPTR          ;GET LAST DATA LOCATION
        XWD     ^O1000,^O366    ;"ORI" TO SET [A] NON-ZERO
INPCON: XRA     A               ;SET FLAG THAT THIS IS AN INPUT
        STA     FLGINP          ;STORE THE FLAG
;
; IN THE PROCESSING OF DATA AND READ STATEMENTS:
; ONE POINTER POINTS TO THE DATA (IE THE NUMBERS BEING FETCHED)
; AND ANOTHER POINTS TO THE LIST OF VARIABLES
;
; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
; TERMINATOR -- A, :, OR END-OF-LINE
;
        XTHL                    ;[H,L]=VARIABLE LIST POINTER
                                ;DATA POINTER GOES ON THE STACK
        XWD     ^O1000,1        ;"LXI B," OVER THIS CHECK
LOPDT2: SYNCHK  44              ;MAKE SURE THERE IS A ","
        CALL    PTRGET          ;READ THE VARIABLE LIST
                                ;AND GET THE POINTER TO A VARIABLE INTO [D,E]
        XTHL                    ;PUT THE VARIABLE LIST POINTER ONTO THE
                                ;STACK AND TAKE THE
                                ;DATA LIST POINTER OFF
;
; NOTE AT THIS POINT WE HAVE A VARIABLE WHICH WANTS DATA
; AND SO WE MUST GET DATA OR COMPLAIN
;
        PUSH    D               ;SAVE THE POINTER TO THE VARIABLE WE
                                ;ARE ABOUT TO SET UP WITH A VALUE
        MOV     A,H             ;SINCE THE DATA LIST POINTER ALWAYS POINTS
                                ;AT A TERMINATOR LETS READ THE
                                ;TERMINATOR INTO [A] AND SEE WHAT
                                ;IT IS
        CPI     44
        JZ      DATBK           ;A COMMA SO A VALUE MUST FOLLOW
IFE     LENGTH,<
        ORA     A               ;IN THE 4K VERSION
        JNZ     SNERR>          ;DATA MUST BE ALONE ON A LINE
        LDA     FLGINP          ;SEE WHAT TYPE OF STATEMENT THIS WAS
        ORA     A
IFE     LENGTH,<
        INX     H               ;POINT AT POINTER TO THE NEXT LINE
        JNZ     DATFND>         ;IF IT IS A READ GO
                                ;SEARCH FOR ANOTHER DATA STATEMENT
IFN     LENGTH,<JNZ     DATLOP>
        MVI     A,"?"
        OUTCHR                  ;DOUBLE PROMPT WHEN WE NEED MORE INPUT
        CALL    QINLIN          ;GET A WHOLE LINE AFTER TYPING "?"
                                ;THE DATA NOW STARTS AT THE BEGINNING
                                ;OF THE BUFFER
                                ;AND QINLIN LEAVES [H,L]=BUF
DATBK:
IFE     LENGTH,<POP     D       ;POP OFF POINTER TO THE VARIABLE
        INX     H               ;FUDGE CHARACTER POINTER
        CALL    REDINP>         ;READ A VALUE USING "LET" CODE
IFN     LENGTH,<
IFN     STRING,<
        LDA     VALTYP          ;SEE IF ITS NUMERIC OR STRING
IFE     LENGTH-2,<
        CPI     3               ;IS IT A STRING ?
        PUSH    PSW             ;SAVE THE TYPE INFORMATION
        JNZ     NUMINS>         ;IF NUMERIC,USE FIN TO GET IT
IFN     LENGTH-2,<
        ORA     A
        JZ      NUMINS>         ;INPUT A NUMBER IF NUMERIC
                                ;ONLY THE VARIABLE TYPE IS
                                ;CHECKED SO AN UNQUOTED STRING
                                ;CAN BE ALL DIGITS
        CHRGET
        MOV     D,A             ;ASSUME QUOTED STRING
        MOV     B,A             ;SETUP TERMINATORS
        CPI     34              ;QUOTE ?
        JZ      NOWGET          ;TERMINATORS OK
        MVI     D,":"           ;UNQUOTED STRING TERINATORS
        MVI     B,44            ;ARE COLON AND COMMA
        DCX     H               ;BACKUP SINCE START CHARACTER MUST BE INCLUDED
                                ;IN THE QUOTES STRING CASE WE SON'T WANT TO
                                ;INCLUDE THE STARTING OR ENDING QUOTE
NOWGET: CALL    STRLT2          ;MAKE A STRING DESCRIPTOR FOR THE VALUE
                                ;AND COPY IF NECESSARY
IFE     LENGTH-2,<
DDASIG: POP     PSW>            ;POP OFF THE TYPE INFORMATION
        XCHG                    ;[D,E]=TEXT POINTER
        LXI     H,STRDN2        ;RETURN LOC
        XTHL                    ;[H,L]=PLACE TO STORE VARIABLE VALUE
        PUSH    D               ;TEXT POINTER GOES ON
        JMP     INPCON>         ;DO ASSIGNMENT
NUMINS: CHRGET
        CALL    FIN
IFE     LENGTH-2,<
        JMP     DDASIG>         ;ASSIGNMENT IS COMPLCATD
                                ;EVEN FOR NUMERICS SO USE THE "LET" CODE
IFN     LENGTH-2,<
        XTHL                    ;[H,L] GET POINTER AT BARIABLE
        CALL    MOVMF           ;DO THE ASSIGNMENT
        POP     H>>             ;GET BACK THE TEXT POINTER
STRDN2:
IFN     LENGTH,<
        DCX     H
        CHRGET
        JZ      TRMOK
        CPI     44
        JNZ     TRMNOK          ;ENDED PROPERLY?
TRMOK:  XTHL
        DCX     H               ;LOOK AT TERMINATOR
        CHRGET                  ;AND SET UP CONDITION CODES
        JNZ     LOPDT2          ;NOT ENDING, CHECK FOR COMMA
                                ;AND GET ANOTHER VARIABLE
                                ;TO FILL WITH DATA
        POP     D               ;POP OFF THE POINTER INTO DATA
        LDA     FLGINP          ;FETCH THE STATEMENT TYPE FLAG
        ORA     A
IFE     LENGTH,<RZ>             ;DON'T UPDATE DATPTR IF IT WAS AN
                                ;INPUT STATEMENT
        XCHG
        JNZ     RESFIN          ;UPDATE DATPTR
IFN     LENGTH,<
        ORA     M               ;COULD HAVE ENDED WITH COMMA OR
                                ;COLON, BUT SHOULD BE A ZERO
        LXI     H,EXIGNT        ;TEXT FOR "EXTRA"
        PUSH    D               ;SAVE THE TEXT POINTER
        CNZ     STROUT          ;IF WASN'T REAL END SAY SOMETHING
        POP     H               ;GET BACK THE TEXT POINTER
        RET
EXIGNT: DC"?EXTRA IGNORED"
        ACRLF
        O>
;
; SUBROUTINE TO FIND DATA
; IN THE 4K "DATA" MUST BE AT THE START OF THE LINE
; SO THE SEARCH IS MADE USING THE LINKS AT THE START OF EACH LINE.
;
; IN THE 8K AND EXTENDED THE SEARCH IS MADE BY USING THE EXECUTION CODE
; FOR DATA TO SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
; IS COMPARED WITH DATATK. EACH NEW LINE NUMBER
; IS STORED IN DATLIN SO THAT IF AN ERROR OCCURS WHILE READING
; DATA THE ERROR MESSAGE WILL GIVE THE LINE NUMBER OF THE
; ILL-FORMATTED DATA
;
DATLOP: IFN     LENGTH,<CALL    DATA>
        IFE     LENGTH,<POP     H>
DATFND: IFN     LENGTH,<
        ORA     A
        JNZ     NOWLIN>
IFN     LENGTH,<
        INX     H>
        PUSHM                   ;SAVE POINTER TO THE NEXT STATEMENT
        MOV     A,C             ;SEE IF WE ARE AT THE END
        ORA     B
        MVI     E,ERROD         ;NO DATA IS ERROR ERROD
        JNZ     ERROR           ;IF SO COMPLAIN
IFE     LENGTH,<INX     H>      ;SKIP PAST LINE #
IFN     LENGTH,<POP     B>
        MOV     E,M             ;GET DATA LINE #
        INX     H
        MOV     D,M
        XCHG
        SHLD    DATLIN
        XCHG>                   ;RESTORE TEXT POINTER
NOWLIN: CHRGET                  ;GET THE STATEMENT TYPE
        CPI     DATATK          ;IS IS "DATA"?
        JNZ     DATLOP          ;NOT DATA SO LOOK SOME MORE
IFE     LENGTH,<POP     B>
        JMP     DATBK           ;CONTINUE READING
PAGE
SUBTTL NEXT CODE
;
; NOTE:
;
;
; A FOR ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
;
; LOW ADDRESS
;       TOKEN (FORTK IN HIGH BYTE)  1 BYTES
;       A POINTER TO THE LOOP VARIABLE  2 BYTES
;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
;       THE STEP 4 BYTES
;       THE UPPER VALUE 4 BYTES
;       THE LINE # OF THE "FOR" STATEMENT 2 BYTES
;       A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
; HIGH ADDRESS
;
; TOTAL 16 BYTES
;
NEXT:
IFN     LENGTH,<LXI     0,$CODE>;FOR THE "NEXT"
                                ;STATEMENT WITHOUT ANY ARGS
                                ;WE CALL FNDFOR WITH [D,E]=0
NEXTC:
IFE     LENGTH,<
        CALL    PTRGET>         ;MUST HAVE A VARIABLE
IFN     LENGTH,<
        CNZ     PTRGET>         ;GET A POINTER TO THE
                                ;LOOP VARIABLE INTO [D,E]
        SHLD    TEMP            ;PUT THE TEXT POINTER
                                ;IN A TEMP LOCATION
                                ;IN CASE THE LOOP TERMINATES
        CALL    FNDFOR          ;TRY TO FIND A FOR ENTRY
                                ;ON THE STACK WHOSE VARIABLE NAME
                                ;MATCHES THIS ONES
IFN     LENGTH,<
        JNZ     NFERR>          ;"NEXT WITHOUT FOR"
        SPHL                    ;SETUP STACK POINTER BY CHOPPING
                                ;AT THIS POINT
        PUSH    D               ;PUT THE VARIABLE PTR BACK ON
        MOV     A,M             ;STEP ONTO THE STACK
        INX     H
        PUSH    PSW
        PUSH    D               ;PUT THE POINTER TO THE LOOP
                                ;VARIABLE ONTO THE STACK
IFE     LENGTH,<
        MVI     E,ERRNF
        JNZ     ERROR>
        CALL    MOVFM           ;STEP VALUE INTO THE FAC
        XTHL                    ;PUT THE POINTER INTO THE
                                ;FOR ENTRY ONTO THE STACK
        PUSH    H               ;PUT THE POINTER TO THE LOOP
                                ;VARIABLE BACK ONTO THE STACK
        CALL    FADDS           ;ADD THE STEP AND LOOP VARIABLE
        POP     H               ;POP OFF THE POINTER TO
                                ;THE LOOP VARIABLE
        CALL    MOVMF           ;MOV FAC INTO LOOP VARIABLE
        POP     H               ;GET THE ENTRY POINTER
        CALL    MOVRM           ;GET THE FINAL INTO THE REGISTERS
        PUSH    H               ;SAVE THE ENTRY POINTER
        CALL    FCOMP           ;COMPARE THE NUMBERS
        POP     H               ;STILL POINTING TO THE FINAL VALUE
        POP     B               ;GET THE SIGN  OF THE INCREMENT
        SUB     B               ;SUBTRACT THE INCREMENTS SIGN FROM THAT
                                ;OF (CURRENT VALUE-FINAL VALUE)
        CALL    MOVRM           ;GET LINE # OF "FOR" INTO [D,E]
                                ;GET TEXT POINTER OF "FOR" INTO [B,C]
        JZ      LOOPON          ;IF SIGN(FINAL-CURRENT)+SIGN(STEP)=0
                                ;THEN THE LOOP IS FINISHED
        XCHG
        SHLD    CURLIN          ;STORE THE LINE #
        MOV     L,C             ;SETUP THE TEXT POINTER
        MOV     H,B
        JMP     NXTCON
LOOPON: SPHL                    ;ELIMINATE THE FOR ENTRY
                                ;SINCE [H,L] MOVED ALL
                                ;THE WAY DOWN THE ENTRY
        LHLD    TEMP            ;RESTORE THE TEXT POINTER
IFE     LENGTH,<JMP     NEWSTT>
IFN     LENGTH,<
        MOV     A,M             ;IS THERE A COMMA AT THE END
        CPI     44              ;IF SO LOOK AT ANOTHER
        JNZ     NEWSTT          ;VARIABLE NAME TO "NEXT"
        CHRGET                  ;READ FIRST CHARACTER
        CALL    NEXTC>          ;DO NEXT, BUT DON'T ALLOW
                                ;BLANK VARIABLE NAME [D,E]=STK PTR
                                ;AND WILL NEVER MATCH ANY VARPTR
                                ;USE CALL TO PUT DUMMY "NEWSTT" ENTRY ON
PAGE
SUBTTL FORMULA EVALUATION CODE
IFN     LENGTH-2,<
IFN     STRING,<
;
; THESE ROUTINES CHECK FOR A CERTAIN VALTYP
; [A] IS NOT PRESERVED
;
FRMNUM: CALL    FRMEVL          ;EVALUATE A FORMULA
CHKNUM: XWD     ^O1000,^O366    ;TURN CARRY OFF WITH ORI
CHKSTR: STC                     ;SET CARRY
CHKVAL: LDA     VALTYP          ;0 MEANS NUMERIC 1 MEANS STRING
        ADC     A               ;RESULT SHOULD BE 0 OR 3
                                ;BAD RESULTS ARE 2 AND 1
        RPE                     ;RETURN IF CORRECT RESULT
TMERR:  MVI     E,ERRTM         ;"TYPE MISMATCH ERROR"
        JMP     ERROR>>
;
; THE FORMULA EVALUATOR STARTS WITH
; [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
; AT THE END [H,L] POINTS TO THE TERMINATOR.
; THE RESULT IS LEFT IN THE FAC.
;
; THE FORMULA EVALUATOR USES THE OPERATOR TABLE (OPTAB)
; TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
; EACH OPERATOR.
; A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT
;
; THE ADDRESS OF "RETAOP" -- THE PLACE TO RETURN ON COMPLETION
; OF OPERATOR APPLICATION
;
; THE FLOATING POINT TEMPORARY RESULT
;
; THE ADDRESS OF THE OPERATOR ROUTINE
;
; THE PRECEDENCE OF THE OPERATOR
;
; TOTAL 10 BYTES
;
IFE     STRING,<FRMNUM:>
FRMEVL: DCX     H               ;BACK UP CHARACTER POINTER
FRMCHK: MVI     D,0             ;INITIAL DUMMY PRECEDENCE IS 0
LPOPER: PUSH    D               ;SAVE PRECEDENCE
        CALL    GETSTK          ;MAKE SURE THERE IS ROOM FOR RECURSIVE CALLS
        1
        CALL    EVAL            ;EVALUATE SOMETHING
        SHLD    TEMP2           ;SAVE TEXT POINTER
RETAOP: LHLD    TEMP2           ;RESTORE TEXT PTR
TSTOP:  POP     B               ;POP OFF THE PRECEDENCE
IFN     LENGTH-2,<
IFN     STRING,<
        MOV     A,B             ;LOOK AT PRECEDENCE
        CPI     120             ;IF ITS SOME ARITHMETIC
                                ;TYPE THING WE SHOULDN'T
                                ;SEE STRINGS
        CNC     CHKNUM>>        ;TYPE MISMATCH ERROR IF NOT NUMERIC
NOTSTV: MOV     A,M             ;GET NEXT CHARACTER
IFN     LENGTH,<
        MVI     D,0             ;ASSUME NO RELATION OPS
LOPREL: SUI     GREATK          ;IS THIS ONE RELATION?
        JC      ENDREL          ;RELATIONS ALL THROUGH
NMREL==LESSTK-GREATK+
        CPI     NMREL           ;IS IT REALLY RELATIONAL?
        JNC     ENDREL          ;NO JUST BIG
        CPI     1               ;SET UP BITS BY MAPPING
        RAL                     ;0 TO 1 1 TO 2 AND 2 TO 4
        XRA     D               ;BRING IN THE OLD BITS
        CMP     D               ;MAKE SURE RESULT IS BIGGER
        MOV     D,A             ;SAVE THE MASK
        JC      SNERR           ;DON'T ALLOW TWO OF THE SAME
        SHLD    TEMP3           ;SAVE CHARACTER POINTER
        CHRGET                  LGET THE NEXT CANDIDATE
        JMP     LOPREL
ENDREL: MOV     A,D             ;GET THE MASK
        ORA     A               ;WERE THERE ANY?
        JNZ     FINREL          ;IF SO, HANDLE AS A SPECIAL OP
        MOV     A,M             ;GET THE CHARACTER AGAIN
        SHLD    TEMP3>          ;SAVE UPDATED CHARACTER POINTER
        SUI     PLUSTK          ;AN OPERATOR?
        RC                      ;RETURN IF NOT
                                ;THIS CAN RESULT IN OPERATOR
                                ;APPLICATION OR ACTUAL RETURN
        CPI     LSTOPK          ;HIGHER THAN THE LAST OP?
        RNC
        MOV     E,A             ;MUST MUTIPLY BY 3 SINCE
                                ;OPTAB ENTRIES ARE 3 LONG
IFN     STRING,<
        LDA     VALTYP          ;SEE IF LEFT PART IS STRING
IFE     LENGTH-2,<
        CPI     3>              ;SEE IF ITS A STRING
IFN     LENGTH-2,<
        DCR     A>
        ORA     E               ;SET CONDITION CODES
IFN     LENGTH-2,<
        MOV     A,E>            ;REFETCH OP-VALUE
        JZ      CAT>            ;MUST BE CAT
IFN     LENGTH-2,<
        RLC                     ;A=ORIGINAL A*2
        ADD     E               ;ADD IN ORIGINAL A
        MOV     E,A>            ;CREATE TWO BYTE VALUE
IFE     LENGTH,<
        MVI     D,0>            ;HIGH ORDER #0
        LXI     H,OPTAB         ;CREATE INDEX INTO OPTAB
        DAD     D               ;ADD IN CALCULATED OFFSET
        MOV     A,B             ;[A] GETS OLD PRECEDENCE
        MOV     D,M             ;REMEMBER NEW PRECEDENCE
        CMP     D               ;OLD-NEW
        RNC                     ;MUST APPLY OLD OP
                                ;IF HAS GREATER OR = PRECEDENCE
IFN     LENGTH-2,<
        INX     H               ;NOW POINTING AT ROUTINE ADDRESS
IFN     STRING,<CALL    CHKNUM> ;CAN'T BE STRING HERE
                                ;SINCE THE ONLY STRING OPERATOR
                                ;IS PLUS AND RELATIONALS
                                ;DON'T COME THROUGH HERE
DOPREC: PUSH    B               ;SAVE OLD PRECEDENCE
        LXI     B,RETAOP        ;OPERATOR RETURN ADDRESS
        PUSH    B               ;FIRST PART OF "TEMP" ENTRY
IFN     LENGTH,<
        MOV     B,E>            ;SAVE SECOND BYTE OF PRECEDENCE
                                ;SINCE FOR RELATIONAL OPERATORS
                                ;IT GIVES THE VALUE TYPE OF
                                ;THE LEFT SIDE AND IT TELLS
                                ;WHICH RELATIONAL-OPERATOR
                                ;IT WAS
        MOV     C,D
        CALL    PUSHF
IFN     LENGTH,<
        MOV     E,B>            ;GET SECOND BYTE OF PRECEDENCE AGAIN
        MOV     D,C             ;[D] GETS PRECEDENCE
        PUSHM                   ;PUT ROUTINE ADDRESS ON THE STACK
IFN     LENGTH,<
        LHLD    TEMP3>
IFE     LENGTH,<
        LHLD    TEMP2>          ;IF WE DON'T HAVE "LENGTH"
                                ;ON OPERATORS CAN ONLY
                                ;BE ONE CHARACTER SO TO "REREAD"
                                ;AN OPERATOR THAT WE LOOKED
                                ;AT BEFORE AND DECIDED NOT TO
                                ;APPLY WE JUST "DCX H"
                                ;IF LENGTH IS ON WE HAVE TO
                                ;REMEMBER THE TEXT POINTER BEFORE
                                ;THE OPERATOR AND AFTER SO WE CAN
                                ;EITHER RESCAN THE OPERATOR
                                ;LATER IF IT DOESN'T GET APPLIED
                                ;OR GO BEYOND IT WHEN IT DOES
        JMP     LPOPER>         ;PUT ON PRECEDENCE AND LOOK AT A
                                ;NEW OPERATOR
IFE     LENGTH-2,<
        PUSH    B               LSAVE THE OLD PRECEDENCE
        LXI     B,RETAOP        ;PUT ON THE ADDRESS OF THE
        PUSH    B               ;PLACE TO RETURN TO AFTER OPERATOR APPLICATION
        MOV     A,D             ;SEE IF THE OPERATOR IS EXPONENTIATION
        CPI     127             ;WHICH AHS PRECEDENCE 127
        JZ      EXPSTK          ;IF SO, "FRCSNG" AND MAKE A SECPIAL STACK ENTRY
        CPI     81              ;SEE IF THE OPERATOR IS "AND" OR "OR"
        JC      ANDORD          ;AND IF SO "FRCINT" AND
                                ;MAKE A SPECIAL STACK ENTRY
;
; THIS CODE PUSHES THE CURRENT VALUE IN THE FAC
; ONTO THE STACK, EXCEPT IN THE CASE OF STRINGS IN WHICH IT CALLS
; TYPE MISMATCH ERROR. [D] AND [E] ARE PRESERVED.
;
NUMREL: LDA     VALTYP          ;GET THE VALUE TYPE
        CPI     3               ;AND SET THE CONDITION CODES BASED ON IT
        JZ      TMERR           ;BLOW UP ON STRINGS
        LXI     H,FACLO         ;GET POINTER TO LO IN FAC
        MOV     C,M
        INX     H
        MOV     B,M
        INX     H
        PUSH    B               ;PUSH FACLO+0,1 ON THE STACK
        JM      VPUSHD          ;ALL DONE IF THE DATA WAS AN INTEGER
        MOV     C,M
        INX     H
        MOV     B,M
        INX     H
        PUSH    B               ;PUSH FAC-1,0 ON THE STACK
        JPO     VPUSHD          ;ALL DONE IF WE HAD A SNG
        LXI     H,DFACLO        ;WE HAVE A DOUBLE PRECISON NUMBER
        PUSHM                   ;PUSH ITS 4 LO BYTES ON THE STACK
        PUSHM
VPUSHD: MOV     C,E             ;[C]=OPERATOR NUMBER
        MOV     B,A             ;[B]TYPE OF VALUE ON THE STACK
        PUSH    B               ;SAVE THESE THINGS FOR APPLOP
        LXI     B,APPLOP        ;GENERAL OPERATOR APPLICATION
                                ;ROUTINE -- DOES TYPE CONVERSIONS
FINTMP: PUSH    B               ;SAVE PLACE TO GO
        LHLD    TEMP3           ;REGET THE TEXT POINTER
        JMP     LPOPER          ;PUSH ON THE PRECEDENCE AND READ MORE
                                ;FORMULA
;
; FOR EXPONENTIATION WE WANT TO FORCE THE CURRENT VALUE IN THE FAC
; TO BE SINGLE PRECISION. WHEN APPLICATION TIME COMES WE FORCE
; THE RIGHT HAND OPERAND TO SINGLE PRECISION AS WELL
;
EXPSTK: CALL    FRCSNG          ;COERCE LEFT HAND OPERAND
        CALL    PUSHF           ;PUT IT ON THE STACK
        LXI     B,FPWRQ##       ;PLACE TO COERCE RIGHT HAND
                                ;OPERAND AND DO EXPONENTIATION
        MVI     D,127           ;RESTORE THE PRECEDENCE
        JMP     FINTMP          ;FINISH ENTRY AND EVALUATE MORE FORMULA
;
; FOR "AND" AND "OR" WE WANT TO FORCE THE CURRENT VALUE IN THE
; FAC TO BE AN INTEGER, AND AT APPLICATION TIME FORCE THE RIGHT
; HAND OPERAND TO BE AN INTEGER
;
ANDORD: PUSH    D               ;SAVE THE PRECEDENCE (70 OR 80)
        CALL    FRCINT
        POP     D               ;[D]=PRECEDENCE
        PUSH    H               ;PUSH THE LEFT HAND OPERAND
        LXI     FINTMP          ;"AND" AND "OR" DOER
        JMP     FINTMP          ;PUSH ON THIS ADDRESS,PRECEDENCE
                                ;AND CONTINUE EVALUATION
;
; HERE TO BUILD AN ENTRY FOR A RELATIONAL OPERATOR
; STRINGS ARE TREATED SPECIALLY. NUMERIC COMPARES ARE DIFFERENT
; FROM MOST OPERATOR ENTRIES ONLY IN THE FACT THAT AT THE
; BOTTOM INSTEAD OF HAVING RETAOP, DOCMP AND THE RELATIONAL
; BITS ARE STORED. STRINGS HAVE STRCMP,THE POINTER AT THE STRING DESCRIPTOR,
; DOCMP AND THE RELATIONAL BITS.
;
FINREL: MOV     A,B             ;[A]=OLD PRECEDENCE
        CPI     100             ;RELATIONALS HAVE PREDENCE 100
        RNC                     ;APPLY EARLIER OPERATOR IF IT HAS
                                ;HIGHER PRECEDENCE
        PUSH    B               ;SAVE THE OLD PRECEDENCE
        PUSH    D               ;SAVE [D]=RELATIONAL BITS
        LXI     D,$CODE+25604   ;[D]=PRECEDENCE=100
                                ;[E]=DISPATCH OFFSET FOR
                                ;COMPARES IN APPLOP=4
                                ;IN CASE THIS IS A NUMERIC COMPARE
        LXI     H,DOCMP         ;ROUTINE TO TAKE COMPARE ROUTINE RESULT
                                ;AND RELATIONAL BITS AND RETURN THE ANSWER
        PUSH    H               ;DOES A JMP TO RETAOP WHEN DONE
        CALL    GETYPE          ;SEE IF WE HAVE A NUMERIC COMPARE
        JNZ     NUMREL          ;YES, BUILD AN APPLOP ENTRY
        LHLD    FACLO           ;GET THE POINTER AT THE STRING DESCRIPTOR
        PUSH    H               ;SAVE IT FOR STRCMP
        LXI     B,STRCMP        ;STRING COMPARE ROUTINE
        JMP     FINTMP          ;PUSH THE ADDRESS, REGET THE TEXT POINTER
                                ;SAVE THE PRECEDENCE AND SCAN
                                ;MORE OF THE FORMULA
;
; APPLOP IS RETURNED TO WHEN IT IS TIME TO APPLY AN ARITHMETIC
; OR NUMERIC COMPARISON OPERATION.
; THE STACK HAS A DOUBLE BYTE ENTRY WITH THE OPERATOR
; NUMBER AND THE VALTYP OF THE VALUE ON THE STACK.
; APPLOP DECIDES WHAT VALUE LEVEL THE OPERATION
; WILL OCCUR AT, AND CONVERTS THE ARGUMENTS. APPLOP
; USES DIFFERENT CALLING CONVENTIONS FOR EACH VALUE TYPE.
; INTEGERS: LEFT IN [D,E] RIGHT IN [H,L]
; SINGLES:  LEFT IN [B,C,D,E] RIGHT IN THE FAC
; DOUBLES:  LEFT IN FAC   RIGHT IN ARG
;
APPLOP: POP     B               ;[B]=STACK OPERAND VALUE TYPE
                                ;[C]=OPERATOR OFFSET
        MOV     A,C             ;SAVE IN MEMORY SINCE THE STACK WILL BE BUSY
        STA     OPRTYP          ;A RAM LOCATION
        MOV     A,B             ;CHECK FOR DOUBLE
        CPI     8               ;PRECISION ENTRY ON THE STACK
        JZ      STKDBL          ;FORCE FAC TO DOUBLE
        LDA     VALTYP          ;SEE IF THE FAC IS DOUBLE PRECISION
        CPI     B               ;AND IF SO, CONVERT THE STACK OPERAND
        JZ      FACDBL          ;TO DOUBLE PRECISION
        MOV     D,A             ;SAVE THE VALUE TYPE OF THE FAC
        MOV     A,B             ;SEE IF THE STACK ENTRY IS SINGLE
        CPI     4               ;PRECISION AND IF SO, CONVERT
        JZ      STKSNG          ;THE FAC TO SINGLE PRECISION
        MOV     A,D             ;SEE IF THE FACT IS SINGLE PRECISION
        CPI     3               ;AND IF SO CONVERT THE STACK TO SINGLE
        JNC     FACSNG          ;PRECISION
                                ;NOTE: THE STACK MUST BE INTEGER AT THIS POINT
        JZ      TMERR           ;BLUE UP ON RIGHT HAND STRING OPERAND
        LXI     H,INTOSP        ;INTEGER INTEGER CASE
        MVI     B,0             ;SPECIAL DISPAYCH FOR SPEED
        DAD     B               ;[H,L] POINTS TO THE ADDRESS TO GO TO
        DAD     B
        MOV     C,M             ;[B,C]=ROUINE ADDRESS
        INX     H
        MOV     B,M
        POP     D               ;[D,E]=LEFT HAND OPERAND
        LHLD    FACLO           ;[H,L]=RIGHT HAND OPERAND
        PUSH    B               ;DISPATCH
        RET
;
; THE STACK OPERAND IS DOUBLE PRECISION, SO
; THE FAC MUST BE FORCED TO DOUBLE PRECISION, MOVED INTO ARG
; AND THE STACK VALUE POPED INTO THE FAC
;
STKDBL: CALL    FRCDBL          ;MAKE THE FAC DOUBLE PRECISION
        CALL    VMOVAF          ;MOVE THE FAC INTO ARG
        POP     H               ;POP OFF THE STACK OPERAND INTO THE FAC
        SHLD    DFACLO+2
        POP     H
        SHLD    DFACLO          ;STORE LOW BYTES AWAY
SNGDBL: POPR                    ;POP OFF A FOUR BYTE VALUE
        CALL    MOVFR           ;INFO THE FAC
SETDBL: CALL    FRCDBL          ;MAKE SURE THE LEFT OPERAND IS
                                ;DOUBLE PRECISION
        LXI     H,DBLDSP        ;DISPATCH TO A DOUBLE PRECISION ROUTINE
DODSP:  LDA     OPRTYP          ;RECALL WHICH OPERAND IT WAS
        RLC                     ;CREATE A DISPATCH OFFSET, SINCE
                                ;TABLE ADDRESSES ARE TWO BYTES
        PUSH    B               ;SAVE [B,C] FOR SINGLE PRECISION
        MOV     C,A             ;DOUBLE BYTE OFFSET
        MVI     B,0             ;INTO [B,C]
        DAD     B               ;CALCULATE LOCATION OF ROUTINE TO GO TO
        POP     B               ;GET BACK [B,C] FOR SINGLE PRECISION
        MOV     A,M             ;GET THE ADDRESS
        INX     H
        MOV     H,M
        MOV     L,A
        PCHL                    ;AND PERFORM THE OPERATION, RETURNING
                                ;TO RETAOP, EXCEPT FOR COMPARES WHICH
                                ;RETURN TO DOCMP
;
; THE FAC IS DOUBLE PRECISION AND THE STACK IS EITHER
; INTEGER OR SINGLE PRECISION AND MUST BE CONVERTED
;
FACDBL: PUSH    B               ;SAVE THE STACK VALUE TYPE
        CALL    VMOVAF          ;MOVE THE FAC INTO ARG
        POP     PSW             ;POP THE STACK VALUE TYPE INTO [A]
        STA     VALTYP          PUT IT IN VALTYP FOR THE FORCE
                                ;ROUTINE
        CPI     4               ;SEE IF ITS SINGLE, SO WE KNOW
                                ;HOW TO POP THE VALUE OFF
        JZ      SNGDBL          ;IT'S SINGLE PRECISION
                                ;SO DO A POPR / CALL MOVFR
        POP     H               ;POP OFF THE INTEGER VALUE
        SHLD    FACLO           ;SAVE IT FOR CONVERSION
        JMP     SETDBL          ;SET IT UP
;
; THIS IS THE CASE WHERE THE STACK IS SINGLE PRECISION
; AND THE FAC IS EITHER SINGLE PRECISION OR INTEGER
;
STKSNG: CALL    FRCSNG          ;CONVERT THE FAC IF NECESSARY
        POPR                    ;PUT THE LEFT HAND OPERAND IN THE REGISTERS
SNG00:  LXI     H,SNGDSP        ;SETUP THE DISPATCH ADDRESS
                                ;FOR THE SINGLE PRECISION OPERATOR ROUTINES
        JMP     DODSP           ;DISPATCH
;
; THIS IS THE CASE WHERE THE FAC IS SINGLE PRECISION AND THE STACK
; IS AN INTEGER
;
FACSNG: POP     H               ;POP OFF THE INTEGER ON THE STACK
        CALL    PUSHF           ;SAVE THE FAC ON THE STACK
        CALL    CONSIM          ;CONVERT [H,L] TO A SINGLE PRECISION
                                ;NUMBER IN THE FAC
        CALL MOVRF              ;PUT THE LEFT HAND OPERAND IN THE REGISTERS
        POP     H               ;RESTORE THE FAC
        SHLD    FAC-1           ;FROM THE STACK
        POP     H
        SHLD    FACLO
        JMP     SNGDO>          ;ERFORM THE OPERATION
EVAL:
IFN     LENGTH-2,<
IFN     STRING,<
        XRA     A
        STA     VALTYP>>        ;ASSUME THE VALUE WILL BE NUMERIC
        CHRGET
        JC      FIN             ;IF NUMERIC, INTERPRET CONSTANT
        CALL    ISLET           ;VARIABLE NAME?
        JNC     ISVAR           ;AN ALPHABETIC CHARACTER MEANS YES
        CPI     PLUSTK          ;IGNORE "+"
        JZ      EVAL
        CPI     "."             ;"." AS LEADING CHARACTER OF A
                                ;CONSTANT?
        JZ      FIN
        CPI     MINUTK          ;NEGATION?
        JZ      DOMIN
IFN     STRING,<
        CPI     34              ;STRING CONSTANT?
        JZ      STRLTI>         ;IF SO BUILD A DESCRIPTOR IN A TEMPORARY
                                ;DESCRIPTOR LOCATION AND PUT A POINTER TO THE
                                ;DESCRIPTOR IN FACLO
IFN     LENGTH,<
        CPI     NOTTK           ;CHECK FOR "NOT" OPERATOR
        JZ      NOTER>
IFN     FUNCTS,<
        CPI     FNTK            ;USER-DEFINED FUNCTION?
        JZ      FNDDER>
        SUI     ONEFUN          ;IS IT A FUNCTION NAME?
        JNC     ISFUN           ;FUNCTIONS ARE THE HIGHEST
                                ;NUMBERED CHARACTERS ALLOWED
                                ;SO THERE IS NO NEED TO CHECK
                                ;THE UPPER BOUND
PATCHK: SYNCHK  "("             ;ONLY POSSIBILITY LEFT
                                ;IS A FORMULA IN PARENTHESES
        CALL    FRMEVL          ;RECURSIVELY EVALUATE THE FORMULA
        SYNCHK  ")"
        RET
DOMIN:
IFE     EXTFNC,<
        CALL    EVAL>           ;NO ^ OPERATOR IN THIS CASE
IFN     EXTFNC,<
        MVI     D,125           ;A PRECEDENCE BELOW ^
                                ;BUT ABOVE ALL ELSE
        CALL    LPOPER          ;SO ^ GREATER THAN UNARY MINUS
        LHLD    TEMP2>          ;GET TEXT POINTER
        PUSH    H
IFE     LENGTH-2,<
        CALL    VNEG>
IFN     LENGTH-2,<
        CALL    NEG>            ;NEGATE THE FAC.
LABBCK:                         ;FUNCTIONS THAT DON'T RETURN
                                ;STRING VALUES COME BACK HERE
IFN     LENGTH-2,<
IFN     STRING,<
        CALL    CHKNUM>>
        POP     H
        RET
ISVAR:  CALL    PTRGET          ;GET A POINTER TO THE
                                ;VARIABLE IN [D,E]
        PUSH    H               ;SAVE THE TEXT POINTER
IFE     STRING,<
        XCHG                    ;TRANSFER THE POINTER AT THE VALUE
                                ;INTO [H,L]
        CALL    MOVFM>          ;SETUP FAC WITH VARIABLE VALUE
IFN     STRING,<
        XCHG                    ;PUT THE POINTER TO THE VARIABLE VALUE
                                ;INTO [H,L]. IN THE CASE OF A STRING
                                ;THIS IS A POINTER TO A DESCRIPTOR AND NOT
                                ;AN ACTUAL VALUE
        SHLD    FACLO           ;IN CASE IT'S STRING STORE THE POINTER
                                ;TO THE DESCRIPTOR IN FACLO
IFE     LENGTH-2,<
        CALL    GETYPE          ;FOR STRINGS WE JUST LEAVE
        CNZ     VMOVFM>         ;A POINTER IN THE FAC
IFN     LENGTH-2,<
        LDA     VALTYP
        ORA     A
        CZ      MOVFM>>         ;IF NOT,ACTUALLY TRANSFER THE VALUE INTO
                                ;THE FAC USING [H,L] AS THE POINTER.
        POP     H               ;RESTORE THE TEXT POINTER
        RET
ISFUN:  MVI     B,0
        RLC                     ;MULTIPLY BY 2
        MOV     C,A
        PUSH    B               ;SAVE THE FUNCTION # ON THE STACK
        CHRGET
IFN     STRING,<
        MOV     A,C             ;LOOK AT FUNCTION #
NUMGFN==2*LASNUM-2*ONEFUN+1
        CPI     NUMGFN          ;IS IT PAST LASNUM?
        JC      OKNORM          ;NO,MUST BE NORMAL FUNCTION
;
; MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
; THE RETURN ADDRESS OF THESE FUNCTIONS IS A SMALL ROUTINE
; THAT CHECKS TO MAKE SURE VALTYP IS 0 (NUMERIC) AND POPS OFF
; THE TEXT POINTER. SO NORMAL FUNCTIONS THAT RETURN STRING RESULTS (I.E. CHR$)
; MUST POP OFF THE RETURN ADDRESS OF LABBCK, AND POP OFF THE
; TEXT POINTER AND THEN RETURN TO FRMEVL.
;
; THE SO CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT.
; THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH
; MUST BE A NUMBER BETWEEN 0 AND 256. THE TEXT POINTER IS
; PASSED TO THESE FUNCTIONS SO ADDITIONAL ARGUMENTS
; CAN BE READ. THE TEXT POINTER IS PASSED IN [D,E].
; THE CLOSE PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
; TO FRMEVL WITH [H,L] SETUP AS THE TEXT POINTER POINTING BEYOND THE ")".
; THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
; IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE INTEGER
; ARGUMENT (2 BYTES)
;
        SYNCHK  "("             ;FIRST ARGUMENT ALWAYS
                                ;STRING -- SECOND INTEGER
        CALL    FRMEVL          ;EAT OPEN PAREN AND FIRST ARG
        SYNCHK  44              ;TWO ARGS SO COMMA MUST DELIMIT
        CALL    CHKSTR          ;MAKE SURE THE FIRST ONE WAS STRING
        XCHG                    ;[D,E]=TXTPTR
        LHLD    FACLO           ;GET PTR AT STRING DESCRIPTOR
        XTML                    ;GET FUNCTION #
                                ;SAVE THE STRING PTR
        PUSH    H               ;PUT THE FUNCTION # ON
        XCHG                    ;[H,L]=TXTPTR
        CALL    GETBYT          ;[E]=VALUE OF FORMULA
        XCHG                    ;TEXT POINTER INTO [D,E]
                                ;[H,L]=INT VALUE OF SECOND ARGUMENT
        XTML                    ;SAVE INT VALUE OF SECOND ARG
                                ;[H,L]=FUNCTION NUMBER
        JMP     FINGO>          ;DISPATCH TO FUNCTION
OKNORM: CALL    PARCHK          ;MAKE SURE ITS THERE.
                                ;READ THE FORMULA INSIDE
                                ;AND MAKE SURE ITS FOLLOWED BY ")"
        XTHL                    ;[H,L]=FUNCTION # AND SAVE TEXT POINTER
IFE     LENGTH-2,<
;
; CHECK IF SPECIAL COERCION MUST BE DONE FOR ONE OF THE TRANSCENDENTAL
; FUNCTIONS (RND, SQR, COS, SIN, TAN, ATN, LOG, AND EXP)
;
        MOV     A,L             ;[A]=FUNCTION NUMBER
BOTCON==<SQRTK-ONEFUN>*2
        CPI     BOTCON          ;LESS THAN SQUARE ROOT?
        JC      NOTFRF          ;DON'T FORCE THE ARGUMENT
TOPCON==<ATNTK-ONEFUN>*2+1
        CPI     TOPCON          ;BIGGER THAN ARC-TANGENT?
        PUSH    H               ;SAVE THE FUNCTION NUMBER
        CC      FRCSNG          ;IF NOT, FORCE FAC TO SINGLE-PRECISION
        POP     H               ;RESTORE THE FUNCTION NUMBER
NOTFRF: >
        LXI     D,LABBCK        ;RETURN ADDRESS
        PUSH    D               ;MAKE THEM REALLY COME BACK
FINGO:  LXI     B,FUNDSP        ;FUNCTION DISPATCH TABLE
        DAD     B               ;ADD ON THE OFFSET
CIFE    LENGTH,<
        PUSHM
        RET>                    ;GO TO THE ADDRESS POINTED TO BY [H,L]
IFN     LENGTH,<
        MOV     C,M             ;FASTER THAN PUSHM
        INX     H
        MOV     H,M
        MOV     L,C
        PCHL>                   ;GO PERFORM THE FUNCTION
IFE     LENGTH-2,<
;
; GET THE VALTYP AND SET CONDITION CODES AS FOLLOWS:
; CONDITION CODE        TRUE SET        FALSE SET
;
; SIGN                  INT=2           STR,SNG,DBL
; ZERO                  STR=3           INT,SNG,DBL
; ODD PARITY            SNG=4           INT,STR,DBL
; NO CARRY              DBL=10          INT,STR,SNG
;
GETYPE: LDA     VALTYP          ;GET THE VALTYP
        CPI     B               ;SET CARRY CORRECTLY
        DCR     A               ;SET THE OTHER CONDITION CODE CORRECTLY
        DCR     A               ; WITHOUT AFFECTING CARRY
        DCR     A
        RET>
IFN     LENGTH-2,<
IFN     LENGTH,<
OR:     XWD     ^O1000,^O366    ;"ORI" , FLAG AS "OR"
                                ;AND USE COMMON "AND" CODE
AND:    XRA     A               ;FLAG AS "AND"
ANDCON:
        PUSH    PSW
IFN     STRING,<CALL    CHKNUM>
        CALL    DEINT           ;GET [D,E]=INT VALUE AND CHECK SIZE
        POP     PSW
        XCHG                    [H,L]=INT VALUE
        POP     0               ;GET HIGH ORDER OFF
        XTHL                    ;PUT INT VALUE ON
                                ;GET LOW OF SECOND ARG OFF
        XCHG                    ;[D,E]=LOW OF SECOND ARG
        CALL    MOVFR
        PUSH    PSW
        CALL    DEINT           ;GET [D,E]=INT VALUE
        POP     PSW
                                ;OF FIRST ARG AND CHECK SIZE
        POP     B               ;[B,C]=INT VALUE OF SECOND ARG
        MOV     A,C             ;[A]=LOW OF SECOND ARG
        LXI     H,GIVACF        ;SETUP JUMP ADDRESS
        JNZ     ORFIN           ;IT WAS "OR" SO FINISH UP
        ANA     E               ;AND TWO LOW ORDERS
        MOV     C,A             ;SAVE ANSWER IN [C]
        MOV     A,B             ;[A]=HIGH ORDER SECOND ARG
        ANA     D               ;[A]=HIGH ORDER OF ANSWER
        PCHL                    ;FLOAT [A,C] AS ANSWER
ORFIN:  ORA     E               ;OR TWO LOW ORDERS
        MOV     C,A             ;SAVE ANSWER LOW ORDER IN [C]
        MOV     A,B             ;[A]=HIGH ORDER SECOND ARG
        ORA     D               ;OR TWO HIGH ORDERS
                                ;[A]=HIGH ORDER OF ANSWER
        PCHL                    ;FLOAT [A,C] AS ANSWER
FINREL: LXI     H,PTDORL        ;MAKE [H,L] POINT AT OPERATOR ADDRESS
IFN     STRING,<
        LDA     VALTYP          ;STORE VALUE TYPE AS LOW
        RAR                     ;ORDER BIT OF [E]
        MOV     A,D             ;GET RELATIONAL MEMORIES IN [A]
        RAL                     ;MOVE CARRY BIT IN
        MOV     E,A>            ;KEEP THIS BYTE IN [E]
IFE     STRING,<MOV    E,D>
        MVI     D,100           ;PRECEDENCE OF ALL RELATIONAL
                                ;OPERATORS IS 100
        MOV     A,B             ;[A]=PRECEDENCE OF OLD OPERATOR
        CMP     D               ;SEE WHETHER TO APPLY OLD OPERATOR
        RNC                     ;IF OLD OPERATOR HAS EQUAL OR GREATER
                                ;PRECEDENCE THAN IT MUST BE APPLIED
        JMP     DOPREC          ;SEE IF TIME TO APPLY
                                ;AND IF NOT SAVE INFO ON THE STACK

PTDORL: ADR(DOREL)              ;ADDRESS OF RELATIONAL
                                ;OPERATOR APPLICATION
                                ;ROUTINE
;
; TIME TO PERFORM A RELATIONAL OPERATOR
; [C] CONTAINS THE BITS AS TO WHICH RELATIONAL
; OPERATOR IT WAS (IF STRINGS ON
; LOW ORDER BIT SAYS WHETHER IT WAS STRING OR NOT)
;
DOREL:  MOV     A,C             ;GET MEMORIES INTO [A]
IFN     STRING,<
        ORA     A
        RAR>                    ;CARRY=WHETHER WAS STRING OR NOT
        POPR                    ;POP OFF LEFT RESULT
        PUSH    PSW             ;SAVE WHICH OPERATOR IT WAS
IFE     STRING,<
        CALL    FCOMP>          ;DO A NUMERIC COMPARE
IFN     STRING,<
        CALL    CHKVAL          ;SEE IF VALTYP MATCHES
                                ;CARRY AND SET ZERO IN THE
                                ;NUMERIC CASE
        LXI     H,DOCMP         ;COME BACK TO COMPARE
        PUSH    H
        JZ      FCOMP           ;DO NUMERIC COMPARE
        XRA     A               ;SET VALUE TYPE AS NUMERIC
        STA     VALTYP>>>
IFN     STRING,<
;
; THE FOLLOWING ROUTINE COMPARES TWO STRINGS
; ONE WITH DESC IN [D,E] OTHER WITH DESC. IN [FACLO, FACLO+1]
; A=0 IF STRINGS EQUAL
; A=377 IF B,C,D,E POINTER FACLO
; A=1 IF B,C,D,E .LT. FACLO
;
IFN     LENGTH-2,<
STRCMP: PUSH    D               ;SAVE DESC. POINTER TO FIRST STR.
        CALL    FREFAC          ;FREE THE FACLO STR
        POP     D               ;RESTORE 1ST DESC. POINTER
        PUSHM                   ;SAVE LENGTH
        PUSHM                   ;SAVE POINTER
        CALL    FRETMP          ;FREES 1ST DESC. POINTER
        CALL    MOVRM           ;[B,C] POINT AT FIRST CHAR
                                ;[E] HAS THE LENGTH
        POP     H               ;GET 2ND CHARACTER POINTER IN H
        XTHL                    ;GET 2ND CHARACTER COUNTER IN L
        MOV     D,L>            ;SAVE IN D
IFN     LENGTH-2,<
STRCMP: CALL    FRESTR          ;FREE UP THE FAC STRING, AND GET THE
                                ;POINTER TO THE FAC DESCRIPTOR IN [H,L]
        MOV     A,M             ;SAVE THE LENGTH OF THE FAC STRING IN [A]
        INX     H
        MOV     C,M             ;SAVE THE POINTER AT THE FAC STRING
                                ;DATA IN [B,C]
        INX     H
        MOV     B,M
        POP     D               ;GET THE STACK STRING POINTER
        PUSH    B               ;SAVE THE POINTER AT THE FAC STRING DATA
        PUSH    PSW             ;SAVE THE FAC STRING LENGTH
        CALL    FRETMP          ;FREE UP THE STACK STRING AND RETURN
                                ;THE POINTER TO THE STACK STRING DESCRIPTOR
                                ;IN [H,L]
        POP     D               ;[D]=LENGTH OF FAC STRING
        MOV     E,M             ;[E]=LENGTH OF STACK STRING
        INX     H
        MOV     C,M             ;[B,C]=POINTER AT STACK STRING
        INX     H
        MOV     B,M>
        POP     H               ;GET BACK 2ND CHARACTER POINTER
CSLOOP: MOV     A,E             ;BOTH STRINGS ENDED
        ORA     D               ;TEST BY OR'ING THE LENGTHS TOGETHER
        RZ                      ;IF SO, RETURN WITH A ZERO
        MOV     A,D             ;GET FACLO STRING LENGTH
        ORA     A               ;IF IT ENDED, OTHER MUST NOT HAVE
        CMA                     ;MAKE -1
        RZ                      ;TEST
        XRA     A               ;MUST NOT HAVE BEEN ZERO, TEST CASE
        CMP     E               ;OF B,C,D,E STRING HAVING ENDED FIRST
        INR     A               ;RETURN WITH A=1
        RNC                     ;TEST THE CONDITION
;HERE WHEN NETIHER STRING ENDED
        DCR     D               ;DECREMENT BOTH CHARACTER COUNTS
        DCR     E
        LDAX    B               ;GET CHARACTER FROM B,C,D,E STRING
        CMP     M               ;COMPARE WITH FACLO STRING
        INX     H               ;BUMP POINTERS (INX DOESNT CLOBBER CC'S)
        INX     B
        JZ      CSLOOP          ;IF BOTH THE SAME, MUST BE MORE TO STRINGS
        CMC                     ;HERE WHEN STRINGS DIFFER
        JMP     SIGNS>          ;SET [A] ACCORDING TO CARRY
IFN     LENGTH,<
DOCMP:  INR     A               ;SETUP BITS
        ADC     A               ;4=LESS 2=EQUAL 1=GREATER
        POP     B               ;WHAT DID HE WANT?
        ANA     B               ;ANY BITS MATCH?
        ADI     255             ;MAP 0 TO 0
        SBB     A               ;AND ALL OTHERS TO 377
IFE     LENGTH-2,<
        CALL    CONIA##         ;CONVERT [A] TO AN INTEGER SIGNED
        JMP     RETAOP          ;RETURN FROM OPERATOR APPLICATION
IFN     LENGTH-2,<
        JMP     FLOAT           ;MAKE FAC=[A] SIGNED
                                ;COULD FALL INTO FLOAT BUT MESSY (SAVES
                                ;TWO BYTES)

NOTER:  MVI     D,90            ;"NOT" HAS PRECEDENCE 90
        CALL    LPOPER          ;GO PERFORM
IFN     STRING,<CALL    CHKNUM> ;MAKE SURE ITS INT
        CALL    DEINT           ;GET VALUE IN [D,E]
        MOV     A,E
        CMA                     ;COMPLEMENT
        MOV     C,A             ;[C] LOW ORDER OF ANSWER
        MOV     A,D
        CMA                     ;COMPLEMENT HIGH ORDER TOO
        CALL    GIVACF          ;FLOAT [A,C] AS RESULT
        POP     B               ;TAKE RETURN ADDRESS OF FRMEVL
        JMP     RETAOP>>        ;OFF AND RETURN TO THE RIGHT
                                ;PLACE SO THE TEXT POINTER
                                ;WILL GET SET UP TO WHAT IT WAS
                                ;WHEN LPOPER RETURNED.
IFE     LENGTH-2,<
NOTER:  MVI     D,90            ;"NOT" HAS PRECEDENCE OF 90, SO
        CALL    LPOPER          ;FORMULA EVALUATION IS ENTERED WITH A DUMMY
                                ;ENTRY OF 90 ON THE STACK
        CALL    FRCINT          ;COERCE THE ARGUMENT TO INTEGER
        MOV     A,L             ;COMPLEMENT [H,L]
        CMA
        MOV     L,A
        MOV     A,H
        CMA
        MOV     H,A
        SHLD    FACLO           ;UPDATE THE FAC
        POP     0               ;FRMEVL, AFTER SEEING THE PRECEDENCE
                                ;OF 90 THINKS IT IS APPLYING AN OPERATOR
                                ;SO IT HAS THE TEXT POINTER IN TEMP2 SO
        JMP     RETAOP          ;RETURN TO REFETCH IT
;
; DANDOR APPLIES THE "AND" AND "OR" OPERATORS
; AND SHOULD BE USED TO IMPLEMENT ALL LOGICAL OPERATORS.
; WHENEVER AN OPERATOR IS APPLIED, ITS PRECEDENCE IS IN[B].
; THIS FACT IS USED TO DISTINGUISH BETWEEN "AND" AND "OR".
; THE RIGHT HAND ARGUMENT IS COERCED TO INTEGER, JUST AS
; THE LEFT HAND ONE WAS WHEN IT WAS PUSHED ON THE STACK.
;
DANDOR: PUSH    B               ;SAVE THE PRECEDENCE "OR"=70
        CALL    FRCINT          ;COERCE RIGHT HAND ARGUMENT TO INTEGER
        POP     PSW             ;GET BACK THE PRECEDENCE TO DISTINGUISH
                                ;"AND" AND "OR"
        POP     D               ;POP OFF THE LEFT HAND ARGUMENT
        CPI     70              ;SET ZERO FOR "OR"
        MOV     A,E             ;SETUP LOW IN [A]
        JZ      ORFIN           ;DO "OR" IF PRECEDENCE WAS 70
        ANA     L
        MOV     L,A
        MOV     A,H
        ANA     D
        MOV     H,A
        JMP     MAKINT          ;RETURN THE INTEGER [H,L]
                                ; AS THE "AND"ED RESULT
ORFIN:  ORA     L
        MOV     L,A
        MOV     A,H
        ORA     D
        MOV     H,A
        JMP     MAKINT>         ;RETURN THE INTEGER [H,L]
                                ; AS THE "OR"ED RESULT
PAGE
SUBTTL  DIMENSION & VARIABLE SEARCHING
DIMCON: DCX     H               ;SEE IF COMMA ENDED THIS VARIABLE
        CHRGET
        RZ                      ;IF TERMINATOR, GOOD BYE
        SYNCHK  44              ;MUST BE COMMA
;
; THE "DIM" CODE SETS DIMFLG AND THEN FALLS INTO THE VARIABLE
; SEARCH ROUTINE. THE VARIABLE SEARCH ROUTIME LOOKS AT
; DIMFLG AT THREE DIFFERENT POINTS:
;
;       1) IF AN ENTRY IS FOUND, DIMFLG BEING ON INDICATES
;               A "DOUBLY DIMENSIONED" VARIABLE
;       2) WHEN A NEW ENTRY IS BEING BUILT DIMFLG'S BEING ON
;               INDICATES THE INDICES SHOULD BE USED FOR
;               THE SIZE OF EACH INDICE. OTHERWISE THE DEFAULT
;               OF TEN IS USED.
;       3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF DIMFLG IS
;               OFF WILL INDEXING BE DONE
;
DIM:    LXI     B,DIMCON        ;PLACE TO COME BACK TO
        PUSH    B
        XWD     ^O1000,^O366    ;"ORI" NON ZERO THING
;
; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
; AND PUT A POINTER TO ITS VALUE IN [D,E]. [H,L] IS UPDATED
; TO POINT TO THE CHARACTER AFTER THE VARIABLE NAME.
; VALTYP IS SETUP. NOTE THAT EVALUATING SUBSCRIPTS IN
; A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO PTRGET SO AT
; THAT POINT ALL VALUES MUST BE STORED ON THE THE STACK.
;
PTRGET: XRA     A               ;MAKE [A]=0
        STA     DIMFLG          ;FLAG IT AS SUCH
        MOV     B,M             ;GET FIRST CHARACTER IN [B]
PTRGT2: CALL    ISLET           ;CHECK FOR LETTER
        JC      SNERR           ;MUST HAVE A LETTER
        XRA     A
        MOV     C,A             ;ASSUME NO SECOND CHARACTER
IFN     LENGTH-2,<
IFN     STRING,<
        STA     VALTYP>>        ;DEFAULT IS ZERO (NUMERIC)
        CHRGET                  ;GET THE FOLLOWING CHARACTER
IFE     LENGTH,<
        JNC     NOSEC>          ;ONLY NUMBERS ALLOWED
IFN     LENGTH,<
        JC      ISSEC           ;CARRY SET BY CHRGET IF CHARACTER IS
                                ;NUMERIC
        CALL    ISLET           ;SET CARRY IF NOT ALPHABETIC
        JC      NOSEC>          ;ALLOW ALPHABETICS
ISSEC:  MOV     C,A             ;IT IS A NUMBER--SAVE IN C
EATEM:  CHRGET                  ;LOOK AT NEXT CHARACTER
IFN LENGTH,<
        JC      EATEM           ;SKIP NUMERICS
        CALL    ISLET
        JNC     EATEM>          ;SKIP ALPHABETICS
NOSEC:
IFE     LENGTH-2,<
        LXI     D,HAVTYP        ;SAVE JUMPS BY USING RETURN ADDRESS
        PUSH    D
        MVI     D,B             ;ASSUME ITS DOUBLE PRECISION
        CPI     "#"             ;CHECK THE CHARACTER
        RZ                      ;WHEN WE MATCH, SETUP VALTYP
        MVI     D,2             ;CHECK FOR INTEGER
        CPI     "%"
        RZ
        INR     D               ;CHECK FOR STRING
        CPI     "$"
        RZ
        INR     D               ;SINGLE PRECISION IS THE DEFAULT
        DCX     H               ;NO MARKING CHARACTER
        RET                     ;GET RID OF RETURN ADDRESS
HAVTYP: MOV     A,D             ;SETUP VALTYP
        STA     VALTYP
        CHRGET>                 ;READ PAST TYPE MARKER
IFN     LENGTH-2,<
IFN     STRING,<
        SUI     "$"             ;IS IT A STRING?
        JNZ     NOTSTR          ;IF NOT VALTYP ALREADY
        INR     A               ;[A]=1
        STA     VALTYP          ;FLAG THIS AS A STRING
        RRC                     ;MAKE [A]=128
        ADD     C               ;MAKE [A]=SECOND CHARACTER
        MOV     C,A             ;BACK INTO [C] WITH STRING BIT ON
        CHRGET                  ;GET CHARACTER AFTER "$"
NOTSTR: >>
IFN     LENGTH,<
        LDA     SUBFLG          ;GET FLAG WHETHER TO ALLOW ARRAYS
        ADD     M>              ;ADD ONTO CHARACTER
        CPI     "("             ;ARRAY PERHAPS (IF SUBFLG SET NEVER WILL MATCH)
        JZ      ISARY           ;IT IS!
IFN     LENGTH,<
        XRA     A               ;ALLOW PARENS AGAIN
        STA     SUBFLG>         ;SAVE IN FLAG LOCATION
        PUSH    H               ;SAVE THE TEXT POINTER
IFE     LENGTH-2,<
        MOV     A,D             ;VALUE TYPE INTO [A]
        LHLD    VARTAB          ;[H,L]=PLACE TO START THE SEARCH
LOPFND: PUSH    PSW             ;SAVE THE VALUE TYPE
        XCHG                    ;[D,E]=POINTER INTO SIMPLE VARIABLES
        LHLD    ARYTAB          ;[H,L]=END OF SIMPLE VARIABLES
        COMPAR                  ;SEE IF THE END HAS BEEN REACHER
        POP     H               ;[H]=VALTYP
        JZ      NOTFNS          ;COULDN'T FIND IT, SO MAKE A NEW ENTRY
        LDAX    D               ;GET THE VALTYP OF THIS SIMPLE VARIABLE
        MOV     L,A             ;SAVE SO WE KNOW HOW MUCH TO SKIP
        CMP     H               ;COMPARE WITH OUT VALTYP
        INX     D
        JNZ     NOTIT1          ;NOT RIGHT KIND -- SKIP IT
        LDAX    D               ;[A]=FIRST CHARACTER OF THIS VARIABLE
        CMP     C               ;SEE IF OUR VARIABLE MATCHES
        JNZ     NOTIT1
        INX     D
        LDAX    D               ;SEE IF SECOND CHARACTER MATCHES
        CMP     B
        JZ      FINPTR          ;THAT WAS IT, ALL DONE
        XWD     ^O1000,^O76     ;"MVI A," AROUND THIS INX SINCE THE POINTER
                                ;IS ALREADY INCREMENTED
NOTIT1: INX     D
        INX     D
        MOV     A,H             ;SKIP OVER THE
                                ;CURRENT VARIABLE SINCE WE DIDN'T MATCH
                                ;SAVE THE VALTYP IN [A]
        MVI     H,0             ;[H,L]=NUMBER OF BYTES TO SKIP
        DAD     D               ;ADD ON THE POINTER
        JMP     LOPFND          ;AND SEARCH SOME MORE
NOTFNS: PUSH    B               ;SAVE THE LOOKS
        MOV     C,H             ;[B,C]=LENGTH OF THIS VARIABLE
        MOV     B,A             ;[B]=0
        PUSH    B               ;SAVE THE VALTYP ON THE STACK
        INX     B               ;MAKE THE LENGTH INCLUDE
                                ;THE LOOKS TOO
        INX     B
        INX     B>
IFN     LENGTH-2,<
        LHLD    ARYTAB          ;PLACE TO STOP SEARCHING
        XCHG
        LHLD    VARTAB          ;GET THE PLACE TO START
LOPFND: COMPAR                  ;SEE IF WE ARE THERE
        JZ      NOTFNS          ;COULDN'T FIND THIS VARIABLE
                                ;SO MAKE ROOM FOR IT
        MOV     A,C
        SUB     M               ;IS THIS VARIABLE THE ONE?
        INX     H
        JNZ     NOTIT           ;NOPE
        MOV     A,B
        SUB     M               ;TRY SECOND CHARACTER MATCHING
NOTIT:  INX     H
        JZ      FINPTR          ;THAT WAS IT!
        INX     H               ;SKIP OVER THAT ONE--NOT IT
        INX     H
        INX     H
        INX     H
        JMP     LOPFND          ;TRY AGAIN
NOTFNS: PUSH    B               ;REMEMBER WHAT THIS
                                ;VARIABLE LOOKS LIKE
        LXI     B,6+$CODE>      ;THE AMOUNT TO SHOVE
                                ;EVERYTHING UP BY
        LHLD    STREND          ;THE CURRENT END OF STORAGE
        PUSH    H               ;SAVE THIS #
        DAD     B               ;ADD ON THE AMOUNT OF SPACE
                                ;EXTRA NOW BEING USED
        POP     B               ;POP OFF HIGH ADDRESS TO MOVE
        PUSH    H               ;SAVE NEW CANDDIATE FOR STREND
        CALL    BLTU            ;BLOCK TRANSFER AND MAKE SURE
                                ;WE ARE NOT OVERFLOWING THE
                                ;STACK SPACE
        POP     H               ;[H,L]=NEW STREND
        SHLD    STREND          ;STORE SINCE WAS OK
                                ;THERE WAS ROOM, AND BLOCK TRANSFER
                                ;WAS DONE, SO UPDATE POINTERS
        MOV     H,B             ;GET BACK [H,L] POINTING AT THE END
        MOV     L,C             ;OF THE NEW VARIABLE
        SHLD    ARYTAB          ;UPDATE THE ARRAY TABLE POINTER
ZEROER: DCX     H               ;[H,L] IS RETURNED POINTING TO THE
        MVI     M,0             ;END OF THE VARIABLE SO WE
        COMPAR                  ;ZERO BACKWARDS TO [D,E] WHICH
        JNZ     ZEROER          ;POINTS TO THE START OF THE VARIABLE
IFE     LENGTH-2,<
        POP     D               ;[E]=VALTYP
        MOV     M,E             ;STORE AS PART OF THE LOOKS
        INX     H>
        POP     D
        MOV     M,E             ;PUT DESCRIPTION
        INX     H
        MOV     M,D             ;OF THIS VARIABLE
                                ;INTO MEMORY
IFE     LENGTH-2,<
        XCHG                    ;POINTER AT VARIABLE INTO [D,E]
FINPTR: INX     D>              ;POINT AT THE VALUE
IFN     LENGTH-2,<
        INX     H
FINPTR: XCHG>                   ;VARIABLE POINTER INTO [D,E]
        POP     H               ;RESTORE THE TEXT POINTER
        RET
IFE     MULDIM,<
ISARY:  PUSH    B               ;REMEMBER WHAT VARIABLE LOOKS
                                ;LIKE
IFN     STRING,<
        PUSH    H               ;SAVE THE TXTPTR
        LHLD    DIMFLG          ;[L]=DIMFLG [H]=VALTYP
        XTHL>                   ;PUT VALTYP AND DIMFLG ON THE STACK
                                ;AND RESTORE THE TEXT POINTER
IFE     STRING,<
        LDA     DIMFLG          ;SINCE THIS CALL IS RECURSIVE
        PUSH    PSW>            ;DIMFLG MUST BE SAVED ON THE STACK
        CALL    INTIDX          ;EVALUATE THE INDEX INTO [D,E]
        SYNCHK  ")"             ;MAKE SURE HE CLOSED IT
IFN     STRING,<
        XTHL                    ;[L]=DIMFLG [H]=VALTYP
                                ;TEXT POINTER ONTO THE STACK
        SHLD    DIMFLG          ;SAVE BOTH VALUES BACK
        POP     H>              ;RESTORE THE TEXT POINTER
IFE     STRING,<
        POP     PSW             ;GET DIMFLG OFF THE STACK
        STA     DIMFLG>         ;RESTORE IT
        XTHL                    ;[H,L] GET VARIABLE DESCRIPTOR
                                ;TEXT POINTER IS PUT ONTO
                                ;THE STACK
        XCHG                    ;[D,E]=DESCRIPTOR
                                ;[H,L]=INDEX
        DAD     H               ;MULTIPLY BY 4 TO GET
        DAD     H               ;BYTE OFFSET
        PUSH    H               ;SAVE THE INDEX
        LHLD    ARYTAB          ;PLACE TO START SEARCH
        XWD     ^O1000,1        ;"LXI B," OVER THE NEXT 2
LOPFD2: POP     B               ;[B,C]=LENGTH OF LAST VARIABLE
        DAD     B               ;SKIP OVER LAST VARIABLE BY ADDING ITS
                                ;LENGTH ONTO [H,L]
        XCHG                    ;[D,E] GET CURRENT SEARCH POINT
        PUSH    H               ;SAVE THE VARIABLE LOOK
        LHLD    STREND          ;GET PLACE TO STOP
        COMPAR                  ;SEE IF WE ARE THERE
        XCHG                    ;[H,L] GETS SEARCH POINT
        POP     D               ;POP OFF VARIABLE LOOKS
        JZ      NOTFDO          ;COULDN'T FIND IT
        PUSHM                   ;PUT ON LOOKS OF VARIABLE
                                ;WE ARE EXAMINING
        XTHL                    ;PUT [H,L] ON THE STACK AND
                                ;LOOKS OF VARIABLE WE ARE
                                ;EXAMINING INTO [H,L]
        COMPAR                  ;IS THIS THE VARIABLE
        POP     H               ;POP OFF SEARCH POINTER
        PUSHM                   ;PUSH LENGTH OF VARIABLE
                                ;BEING EXAMINED ONTO THE STACK
        JNZ     LOPFD2          ;IF NO MATCH,GO LOOK SOMEMORE
        LDA     DIMFLG          ;IS THIS VARIABLE TRYING TO BE
                                ;DIMENSIONED AND ALREADY
        ORA     A               ;EXISTS?
        MVI     E,ERRDD         ;THATS ERROR ERRDD
        JNZ     ERROR
MAKDFN: POP     D               ;POP OFF LENGTH OF THIS VARIABLE
        DCX     D               ;DECREMENT LENGTH SO WE CAN
                                ;JUST LOOK AT 'CARRY' AFTER
                                ;CALLING COMPAR
        XTHL                    ;TRADE POINTER AT VARIABLE WITH
                                ;INDEX INTO THE VARIABLE
        COMPAR                  ;SEE IF INDEX IS TOO BIG
        MVI     E,ERRBS         ;THATS ERROR ERRBS
        JNC     ERROR           ;SINCE LENGTH REALLY HAS AN
                                ;EXTRA ONE ADDED TO IT
                                ;IF INDEX-LENGTH DOESN'T CARRY
                                ;HE IS IN TROUBLE
        POP     D               ;POP OFF POINTER AT VARIABLE
        DAD     D               ;ADD IT TO THE INDEX
        POP     D               ;POP OFF TEXT POINTER
        XCHG                    ;TEXT POINTER INTO [H,L]
        RET                     ;VARIABLE POINTER INTO [D,E]

NOTFOD: MOV     M,E             ;PUT LOOKS DOWN
        INX     H
        MOV     M,D
        INX     H
        LXI     D,$CODE+44      ;DEFAULT SIZE IS 10
        LDA     DIMFLG          ;ARE WE DIMENSIONING
        ORA     A
        JZ      NOTDIM
        POP     D               ;POP OFF INDEX
        PUSH    D               ;PUT INDEX BACK ON
        INX     D
        INX     D
        INX     D
        INX     D
NOTDIM: PUSH    D
        MOV     M,E             ;PUT LENGTH DOWN
        INX     H
        MOV     M,D
        INX     H
        PUSH    H
        DAD     D
        CALL    REASON          ;MAKE SURE WE'RE NOT RUNNING
                                ;INTO THE STACK
        SHLD    STREND          ;SETUP NEW STORAGE END
        POP     D
ZERIT2: DCX     H
        MVI     M,0
        COMPAR
        JNZ     ZERIT2
        JMP     MAKDFN>         ;FINISH UP
PAGE
SUBTTL  MULTIPLE DIMENSION CODE
IFN     MULDIM,
;
; FORMAT OF ARRAYS IN CORE
;
; DESCRIPTOR
;       LOW BYTE = SECOND CHARACTER
;       HIGH BYTE = FIRST CHARACTER
; LENGTH OF ARRAY IN CORE IN BYTES (DOES NOT INCLUDE DESCRIPTOR)
; NUMBER OF DIMENSIONS 1 BYTE
; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
; (2 BYTES EACH) OF THE MAX INDICE+1
; THE VALUES
;
ISARY:  PUSH    H               ;SAVE DIMFLG AND VALTYP FOR RECURSION
        LHLD    DIMFLG
        XTHL                    ;TEXT POINTER BACK INTO [H,L]
        MVI     D,0             ;SET # DIMENSIONS =0
INDLOP: PUSH    D               ;SAVE NUMBER OF DIMENSIONS
        PUSH    B               ;SAVE LOOKS
        CALL    INTIDX          ;EVALUATE INDICE INTO [D,E]
        POP     B               ;POP OFF THE LOOKS
        POP     PSW             ;[A] = NUMBER OF DIMENSIONS SO FAR
        XCHG                    ;[D,E]=TEXT POINTER
                                ;[H,L]=INDICE
        XTHL                    ;PUT THE INDICE ON THE STACK
                                ;[H,L]=VALTYP & DIMFLG
        PUSH    H               ;RESAVE VALTYP AND DIMFLG
        XCHG                    ;[H,L]=TEXT POINTER
        INR     A               ;INCREMENT # OF DIMENSIONS
        MOV     D,A             ;[D]=NUMBER OF DIMENSIONS
        MOV     A,M             ;GET TERMINATING CHARACTER
        CPI     44              ;A COMMA SO MORE INDICES FOLLOW?
        JZ      INDLOP          ;IF SO, READ MORE
        SYNCHK  ")"             ;MAKE SURE IT ENDED PROPERLY
        SHLD    TEMP2           ;SAVE THE TEXT POINTER
        POP     H               ;[H,L]= VALTYP & DIMFLG
        SHLD    DIMFLG          ;SAVE VALTYP AND DIMFLG
        PUSH    D               ;SAVE NUMBER OF DIMENSIONS
;
; AT THIS POINT [B,C]=LOOKS. THE TEXT POINTER IS IN TEMP2.
; THE INDICES ARE ALL ON THE STACK, FOLLOWED BY THE NUMBER OF DIMENSIONS.
;
        LHLD    ARYTAB          ;[H,L]=PLACE TO START THE SEARCH
        XWD     ^O1000,^O76     ;"MVI A," AROUND THE NEXT BYTE
LOPFDA: DAD     D               ;SKIP OVER THIS ARRAY SINCE IT'S
                                ;NOT THE ONE
        XCHG                    ;[D,E]=CURRENT SEARCH POINT
        LHLD    STREND          ;GET THE PLACE TO STOP INTO [H,L]
        XCHG                    ;[H,L]=SEARCH POINT
        COMPAR                  ;STOPPING TIME?
IFE     LENGTH-2,<
        LDA     VALTYP>
        JZ      NOTFDO          ;YES,COULDN'T FIND THIS ARRAY
IFE     LENGTH-2,<
        CMP     M               ;SEE IF THE VALTYPS ARE THE SAME
        INX     H
        JNZ     NMARY2>
        MOV     A,M             ;GET FIRST CHARACTER
        CMP     C               ;SEE IF IT MATCHES
        INX     H
        JNZ     NMARY1          ;NOT THIS ONE
        MOV     A,M             ;GET SECOND CHARACTER
        CMP     B               ;ANOTHER MATCH?
IFE     LENGTH-2,<
        XWD     ^O1000,^O76     ;SKIP THIS INCREMENT WITH "MVI A,"
NMARY2: INX     H>
NMARY1: INX     H               ;POINT TO SIZE ENTRY
        MOV     E,M             ;[D,E]=LENGTH
        INX     H               ;OF THE ARRAY BEING LOOKED AT
        MOV     D,M
        INX     H
        JNZ     LOPFDA          ;IF NO MATCH, SKIP THIS ONE
                                ;AND TRY AGAIN
        LDA     DIMFLG          ;SEE IF CALLED BY "DIM"
        ORA     A               ;ZERO MEANS NO
        MVI     E,ERRDD         ;"DOUBLY DIMENSIONED" ERROR
        JNZ     ERROR
;
; TEMP2=THE TEXT POINTER
; WE HAVE LOCATED THE VARIABLE WE WERE LOOKING FOR
; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
; THE INDICES ARE ON THE STACK FOLLOWED BY THE NUMBER OF DIMENSIONS
;
        POP     PSW             ;[A]=NUMBER OF DIMENSIONS
        CMP     M               ;MAKE SURE THE NUMBER GIVEN NOW AND
                                ;AND WHEN THE ARRAY WAS SET UP ARE THE
                                ;SAME
        JZ      GETDEF          ;JUMP OFF AND READ
                                ;THE INDICES...
BSERR:  MVI     E,ERRBS         ;"SUBSCRIPT OUT OF RANGE"
        JMP     ERROR
;
; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE
;
; BUILDING AN ENTRY:
;
;       PUT DOWN THE DESCRIPTOR
;       SETUP NUMER OF DIMENSIONS
;       MAKE SURE THERE IS ROOM FOR THE NEW ENTRY
;       REMEMBER VARPTR
;       TALLY=4 (VALTYP FOR THE EXTENDED)
;       SKIP 2 LOCS FOR LATER FILL IN -- THE SIZE
; LOOP: GET AN INDICE
;       PUT NUMBER +1 DOWN AT VARPTR AND INCREMENT VARPTR
;       TALLY= TALLY * NUMBER+1
;       DECREMENT NUMBER-DIMS
;       JNZ     LOOP
;       CALL REASON WITH [H,L] REFLECTING LAST LOC OF VARIABLE
;       UPDATE STREND
;       ZERO BACKWARDS
;       MAKE TALLY INCLUDE MAXDIMS
;       PUT DOWN TALLY
;       IF CALLED BY DIMENSION, RETURN
;       OTHERWISE INDEX INTO THE VARIABLE AS IF IT
;       WERE FOUND ON THE INITIAL SEARCH
;
NOTFDO:
IFE     LENGTH-2,<
        MOV     M,A             ;PUT DOWN THE VARIABLE TYPE
        INX     H
        MOV     E,A
        MVI     D,0>            ;[D,E]-SIZE OF ONE VALUE (VALTYP)
IFN     LENGTH-2,<
        LXI     D,$CODE+4>      ;INITIALIZE TALLY TO FOUR
        MOV     M,C             ;PUT DOWN THE DESCRIPTOR
        INX     H
        MOV     M,B
        INX     H
        POP     PSW             ;[A]=NUMBER OF DIMENSIONS
        STA     TEMP6           ;SETUP GETSTR CALL
        CALL    GETSTK          ;GET SPACE FOR DIMENSION ENTRIES
TEMP6:  PCHL                    ;PLACE TO STORE NUMBER OF DIMENSIONS
                                ;FOR GETSTK AND LATER RECALL
                                ;!!IMPURE!! PCHL TO CONFUSE DISASSEMBLY
        SHLD    TEMP3           ;SAVE THE LOCATION TO PUT THE SIZE
                                ;IN
        INX     H               ;SKIP OVER THE SIZE LOCATIONS
        INX     H
        MOV     B,C             ;[B]=NUMBER OF DIMENSIONS
                                ;THIS DEPENDS ON THE FACT THAT GETSTR
                                ;RETURNS ITS ARGUMENT IN [C]
        MOV     M,B             ;STORE THE NUMBER OF DIMENSIONS
        INX     H
LOPPTA: LDA     DIMFLG          ;CALLED BY DIMENSION?
        ORA     A
        MOV     A,B             ;[A]=NUMBER OF DIMENSIONS
        LXI     B,$CODE+11      ;[ASSUME ITS NOT "DIM"
        JZ      NOTDIM          ;DEFAULT DIMENSIONS TO TEN
        POP     B               ;POP OFF AN INDICE INTO [B,C]
        INX     B               ;ADD ONE TO IT FOR THE ZERO ENTRY
NOTDIM: MOV     M,C             ;PUT THE MAXIMUM DOWN
        INX     H
        MOV     M,B
        INX     H
        PUSH    PSW             ;SAVE THE NUMBER OF DIMENSIONS
        PUSH    H               ;SAVE THE POINTERS INTO THE NEW ENTRY
        CALL    UMULT           ;MULTIPLY [B,C]=NEWMAX BY CURTOL=[D,E]
        XCHG                    ;[D,E]=NEW CURTOL
        POP     H               ;GET THE POINTER INTO ENTRY BACK
        POP     B               ;GET THE NUMBER OF DIMENSIONS BACK
        DCR     B               ;DECREMENT THE NUMBER OF DIMENSIONS LEFT
        JNZ     LOPPTA          ;HANDLE THE OTHER INDICES
        MOV     B,D             ;[B,C]=SIZE
        MOV     C,E
        XCHG                    ;[D,E]=START OF VALUES
        DAD     D               ;[H,L]=END OF VALUES
        JC      BSERR           ;OUT OF MEMORY POINTER BEING GENERATED?
        CALL    REASON          ;SEE IF THERE IS ROOM FOR THE VALUES
        SHLD    STREND          ;UPDATE THE END OF STORAGE
ZERITA: DCX     H               ;ZERO THE NEW ARRAY
        MVI     M,0
        COMPAR                  ;BACK AT THE BEGINNING?
        JNZ     ZERITA          ;NO,ZERO MORE
        INX     B               ;ADD ONE TO THE SIZE TO INCLUDE
                                ;THE BYTE FOR THE NUMBER OF DIMENSIONS
        MOV     H,A             ;[H]=ZERO
        LDA     DIMFLG
        ORA     A               ;ARE WE DIMENSIONING ?
        LDA     TEMP6           ;GET THE NUMBER OF DIMENSIONS
        MOV     L,A             ;[L]=NUMBER OF DIMENSIONS
        DAD     H               ;[H,L]=NUMBER OF DIMENSIONS TIMES TWO
        DAD     B               ;ADD ON THE SIZE
                                ;TO GET THE TOTAL NUMBER OF BYTES USED
        XCHG                    ;[D,E]=TOTAL SIZE
        LHLD    TEMP3           ;PLACE TO STORE SIZE
        MOV     M,E             ;PUT DOWN THE SIZE
        INX     H
        MOV     M,D
        INX     H
        JNZ     FINNOW
;
; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
; STRATEGY:
;       NUMDIM=NUMBER OF DIMENSIONS
;       CURTOL=0
; INLPNM:GET A NEW INDICE
;       POP NEW MAX INTO CURMAX
;       MAKE SURE INDICE IS NOT TOO BIG
;       MULTIPLY CURTOL BY CURMAX
;       ADD INDICE TO CURTOL
;       NUMDIM=NUMDIM-1
;       JNZ     INLPNM
;       USE CURTOL*4 (VALTYP FOR EXTENDED) AS OFFSET
;
GETDEF: INX     H               ;POINT PAST THE NUMBER OF DIMENSIONS
        LXI     B,$CODE         ;CURTOL=ZERO
        XWD     ^O1000,^O26     ;"MVI D," AROUND THE NEXT BYTE
INLPNM: POP     H               ;[H,L]= POINTER INTO VARIABLE ENTRY
        MOV     E,M             ;[D,E]=MAXIMUM FOR THE CURRENT INDICE
        INX     H
        MOV     D,M
        INX     H
        XTHL                    ;[H,L]=CURRENT INDICE
                                ;POINTER INTO THE VARIABLE GOES ON THE STACK
        PUSH    PSW             ;SAVE THE NUMBER OF DIMENSIONS
        COMPAR                  ;SEE IF THE CURRENT INDICE IS TOO BIG
        JNC     BSERR           ;IF SO "BAD SUBSCRIPT" ERROR
        PUSH    H               ;SAVE THE CURRENT INDICE
        CALL    UMULT           ;CURTOL=CURTOL*CURRENT MAXIMUM
        POP     D               ;INDICE INTO [D,C]
        DAD     D               ;ADD THE INDICETO CURTOL
        POP     PSW             ;GET THE NUMBER OF DIMENSIONS IN [A]
        DCR     A               ;SEE IF ALL THE INDICES HAVE BEEN PROCESSED
        MOV     B,H             ;[B,C]=CURTOL IN CASE WE LOOP BACK
        MOV     C,L
        JNZ     INLPNM          ;PROCESS THE REST OF THE INDICES
IFE     LENGTH-2,<
        LDA     VALTYP          ;SEE HOW BIG THE VALUES ARE
                                ;AND MULTIPLY BY THAT SIZE
        MOV     B,H             ;SAVE THE ORIGINAL VALUE FOR MULTIPLYING
        MOV     C,L             ;BY THREE
        DAD     H               ;MULTIPLY BY TWO AT LEAST
        SUI     4               ;FOR INTEGERS AND STRINGS
                                ;NO MORE MULTIPLYING BY TWO
        JC      SMLVAL
        DAD     H               ;NOW MULTIPLIED BY FOUR
        JZ      DONMUL          ;IF SINGLE ALL DONE
        DAD     H               ;BY EIGHT FOR DOUBLES
SMLVAL: JPO     DONMUL          ;FOR STRINGS
        DAD     B               ;ADD IN THE ORIGINAL
DONMUL:>
IFN     LENGTH-2,<
        DAD     H               ;MULTIPLY CURTOL BY FOUR
        DAD     H>
        POP     B               ;POP OFF THE ADDRESS WHERE THE VALUES
                                ;BEGIN
        DAD     B               ;ADD IT ONTO CURTOL TO GET THE
                                ;PLACE THE VALUE IS STORED
        XCHG                    ;RETURN THE POINTER IN [D,E]
FINNOW: LHLD    TEMP2           ;REGET THE TEXT POINTER
        DCX     H               ;REREAD THE TERMINATING CHARACTER
        CHRGET
        RET>
PAGE
SUBTTL FRE  FUNCTION AND INTEGER TO FLOATING  ROUTINES
IFN     LENGTH,<
FRE:    LHLD    STREND          ;GET END OF VARIABLE AND TEXT SPACE
        XCHG                    ;PUT IT IN [D,E] FOR SUBTRACTION
        LXI     H,$CODE         ;ZERO [H,L]
        DAD     SP              ;PUT THE STACK POINTER IN [H,L]
IFN     STRING,<
IFE     LENGTH-2,<
        CALL    GETYPE
        JNZ     GIVDBL
IFN     LENGTH-2,<
        LDA     VALTYP          ;WAS THE ARGUMENT A STRING?
        ORA     A
        JZ      GIVDBL>         ;NO, GIVE FREE VARIABLE SPACE
        CALL    FREFAC          ;FREE UP ARGUMENT AND SETUP
                                ;TO GIVE FREE STRING SPACE
        CALL    GARBA2          ;DO GARBAGE COLLECTION
        LHLD    STKTOP          ;BOTTOM OF FREE AREA
        XCHG
        LHLD    FRETOP>>        ;TOP OF FREE AREA
;
; THIS ROUTINE SUBTRACTS [D,E] FROM [H,L]
; AND FLOATS THE RESULT LEAVING IT IN FAC.
;
IFE     LENGTH-1,<
GIVDBL: MOV     A,L             ;DO THE SUBTRACTION
        SUB     E
        MOV     C,A
        MOV     A,H
        SBB     D
GIVACF: MOV     B,C>
IFN     LENGTH-2,<
GIVABF: MOV     D,B
        MVI     E,0             ;GET ZERO IN LOW
IFN     STRING,<
        LXI     H,VALTYP        ;FLAG VALUE TYPE AS NUMERIC
        MOV     H,E>
        MVI     B,144           ;SETUP TO FLOAT [B,C]
        JMP     FLOATR>
IFE     LENGTH-2,<
GIVDBL: MOV     A,L             ;[H,L]=[H,L]-[D,E]
        SUB     E
        MOV     L,A
        MOV     A,H
        SBB     D
        XWD     ^O1000,^O21     ;SKIP THE NEXT TWO BYTES WITH "LXI D,"
SNGFLT: MOV     L,A             ;MAKE [A] AN UNSIGNED INTEGER
        XRA     A
GIVINT: MOV     H,A
        JMP     MAKINT>
IFN     LENGTH,<
IFN     LPTSW,<
LPOS:   LDA     LPTPOS
        JMP     SNGFLT>
POS:    LDA     TTYPOS          ;GET TELETYPE POSITION
IFN     LENGTH-2,<
SNGFLT: MOV     B,A             ;RETURN FLOATING 1 BYTE
        XRA     A               ;UNSIGNED FROM A
        JMP     GIVABF>>        ;GIVING 0-255
PAGE
SUBTTL  SIMPLE-USER-DEFINED-FUNCTION CODE
IFN     FUNCTS,
;
; NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
; AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
; DEF FNA(X)=X^2+X-2
; NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS
; IDEA: CREATE A FUNNY SIMPLE VARIABLE ENTRY
; WHOSE FIRST CHARACTER (SECOND WORD IN MEMORY)
; HAS THE 200 BIT SET.
; THE VALUE WILL BE:
;
;       A TXTPTR TO THE FORMULA
;       A PTR TO THE ARGUMENT VARIABLE
;
; FUNCTION NAMES CAN BE LIKE "FNA4"
;
DEF:    CALL    GETFNM          ;GET A POINTER TO THE
                                ;FUNCTION VARIABLE
        LXI     B,DATA          ;EVENTUALLY RETURN TO "DATA"
        PUSH    B               ;AND SKIP THE FORMULA
        PUSH    D               ;SAVE A POINTER TO IT
        CALL    ERRDIR          ;DEF IS "ILLEGAL DIRECT"
        SYNCHK  "("             ;MUST HAVE "("
                                ;SINCE WE STORE A TEXT POINTER
        CALL    PTRGET          ;GET POINTER TO ARGUMENT
IFN     LENGTH-2,<
IFN     STRING,<CALL    CHKNUM>>;STRINGS ILLEGAL
        SYNCHK  ")"             ;MUST CLOSE IT WITH ")"
        SYNCHK  EQULTK          ;MUST HAVE EQUAL
        MOV     B,H
        MOV     C,L
        XTHL                    ;PUT THE TXTPTR ON THE STACK
                                ;[H,L]=PTR TO FUNCTION VARIABLE
                                ;[B,C]=TXTPTR
        JMP     DEFFIN          ;PUT DOWN THE TEXT-POINTER
                                ;AND ARUGMENT POINTER IN
                                ;MEMORY, RESTORE THE TXTPTR
                                ;AND GO TO "DATA" SKIPPING THE
                                ;REST OF THE FORMULA
FNDOER: CALL    GETFNM          ;GET A POINTER TO
                                ;THE FUNCTON DEFINITION IN [D,E]
        PUSH    D               ;SAVE THE POINTER
        CALL    PARKCHK         ;EVALUATE THE VALUE TO BE PASSED
IFN     LENGTH-2,<
IFN     STRING,<CALL    CHKNUM>> ;ARG CANNOT BE STRING
        XTHL                    ;[H,L]=POINTER TO FUNCTION DEF
                                ;TEXT POINTER GOES ON THE STACK
        PUSHM                   ;PUSH THE POINTER AT THE FORMULA
                                ;ONTO THE STACK
        POP     D               ;[D,E]=PTR TO FORMULA
        PUSHM                   ;PUT A POINTER TO THE
                                ;ARGUMENT ON THE STACK
        POP     H               ;[H,L]=POINTER TO ARG
        PUSHFM                  ;SAVE ARGS OLD VALUE ON THE STACK
        DCX     H
        DCX     H
        DCX     H               ;POINT TO FRONT OF ARG AGAIN
        DCX     H
        PUSH    H               ;SAVE IT
        COMPAR                  ;SHOULDN'T BE EQUAL UNLESS
                                ;FUNCTION WAS NEVER DEFINED
        PUSH    D               ;SAVE FORMULA TEXT POINTER
        MVI     E,ERRUF         ;NOW [D,E] FREE SO CHECK IF (ZERO) SET
        JZ      ERROR
        CALL    MOVMF           ;PUT CURRENT FAC INTO OUT ARG VARIABLE
                                ;OUT OF FAC INTO [H,L] LOCATION
        POP     H               ;POP OFF FORMULA TXTPTR
IFN     LENGTH-2,<
        CALL    FRMNUM>         ;EVALUATE IT AND MUST SURE ITS NUMERIC
IFE     LENGTH-2,<
        CALL    FRMEVL
        PUSH    H
        CALL    FRCSNG
        POP     H>
        DCX     H
        CHRGET                  ;SEE IF TERMINATED
        JNZ     SNERR           ;IF NOT SYNTAX ERROR
                                ;TO BE NICE SHOULD HAVE NEW CURLIN
                                ;BUT VERY MESSY
        POP     H               ;POP OFF POINTER AT ARG VARIABLE
        POP     D
        POP     B>              ;POP OFF OLD VALUE
IFN     MULDIM!STRING!FUNCTS,<
DEFFIN: MOV     M,C
        INX     H               ;STORE THE OLD VALUE
        MOV     M,B
PUTDEI: INX     H
        MOV     M,E
        INX     H
        MOV     M,D
        POP     H               ;POP OFF OLD TXTPTR
        RET>                    ;VALUE IS IN FAC -- ALL DONE
IFN     FUNCTS,<
;
; SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE AND
; COMPLAIN IF SO
;
ERRDIR: PUSH    H               ;SAVE THEIR [H,L]
        LHLD    CURLIN          ;SEE WHAT THE CURRENT LINE IS
        INX     H               ;DIRECT IS 65,535 SO NOW 0
        MOV     A,H
        ORA     L               ;IS IT ZERO NOW?
        POP     H
        RNZ                     ;RETURN IF NOT
        MVI     E,ERRID         ;"ILLEGAL DIRECT" ERROR
        JMP     ERROR
;
; SUBROUTINE TO GET A POINTER TO A FUNCTION NAME
;
GETFNM: SYNCHK  FNTK            ;MUST START WITH "FN"
        MVI     A,128           ;DONT ALLOW AN ARRAY
        STA     SUBFLG          ;DON'T RECOGNIZE THE "(" AS
                                ;THE START OF AN ARRAY REFERENCE
        ORA     M               ;PUT FUNCTION BIT ON
        MOV     B,A             ;GET FIRST CHARACTER INTO [B]
IFN     LENGTH-2,<
IFN     STRING,<CALL    PTRGT2  ;REALLY GET THE POINTER
        JMP     CHKNUM>>        ;MAKE SURE ITS NOT A STRING NAME
IFE     STRING&<LENGTH-2>,<JMP  PTRGT2>>
PAGE
SUBTTL  STRING FUNCTIONS
IFN     STRING,<                ;STRING HANDLING SUBROUTINES
;
; THE STR$ FUNCTION TAKES A NUMBER AND GIVES
; A STRING WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
; WOULD HAVE GIVEN
;
STR$:
IFN     LENGTH-2,<
        CALL    CHKNUM>         ;MAKE SURE THE ARGUMENT
                                ;IS A NUMERIC
        CALL    FOUT            ;DO ITS OUTPUT
        CALL    STRLIT          ;SCAN IT AND TURN IT INTO A STRING
        CALL    FREFAC          ;FREE UP THE TEMP
        LXI     B,FINBCK
        PUSH    B               ;SET UP ANSWER IN NEW TEMP
;
; STRCPY CREATES A COPY OF THE STRING
; WHOSE DESCRIPTOR IS POINTED TO BY [H,L].
; ON RETURN [D,E] POINTS TO DSCTMP
; WHICH HAS THE STRING INFO (LENGTH,WHERE COPIED TO)
;
STRCPY: MOV     A,M             ;GET LENGTH
        INX     H               ;MOVE UP TO THE POINTER
IFN     LENGTH-2,<
        INX     H>
        PUSH    H               ;GET POINTER TO POINTER OF ARG
        CALL    GETSPA          ;GET THE SPACE
        POP     H               ;FIND OUT WHERE STRING TO COPY
        PUSHM                   ;REALLY IS IN [B,C]
        POP     B
        CALL    STRAD2          ;SETUP DSCTMP
        PUSH    H               ;SAVE POINTER TO DSCTMP
        MOV     L,A             ;GET CHARACTER COUNT INTO [L]
        CALL    MOVSTR          ;MOVE THE CHARS IN
        POP     D               ;RESTORE POINTER TO DSCTMP
        RET                     ;RETURN
STRINI: CALL    GETSPA          ;GET SOME STRING SPACE ([A] CHARS)
STRAD2: LXI     H,DSCTMP        ;GET DESC. TEMP
STRAD1: PUSH    H               ;SAVE DESC. POINTER
        MOV     M,A             ;SAVE CHARACTER COUNT
IFN     LENGTH-2,<
        INX     H>              ;MOVE TO ADDRESS FIELD
        JMP     PUTDEI          ;USE COMMON CODE TO
                                ;STORE [D,E]=POINTER TO FREE SPACE
                                ;AND RESTORE [H,L] AS THE DESCRIPTOR POINTER
;
; STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
; IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.
; THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW
; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
; AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN
; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN [B]
; AND [D]. IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN
; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
; BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE
; NOT SET UP.
;
STRLIT: DCX     H
STRLTI: MVI     B,34            ;ASSUME STR ENDS ON QUOTE
STRLT3: MOV     D,B
STRLT2: PUSH    H               ;SAVE POINTER TO START OF LITERAL
        MVI     C,255           ;INITIALIZE CHARACTER COUNT
STRGET: INX     H
        MOV     A,M             ;GET CHAR
        INR     C               ;BUMP CHARACTER COUNT
        ORA     A               ;IF 0, (END OF LINE) DONE
        JZ      STRFIN          ;TEST
        CMP     D
        JZ      STRFIN
        CMP     0               ;CLOSING QUOTE
        JNZ     STRGET          ;NO, GO BACK FOR MORE
STRFIN: CPI     34              ;IF QUOTE TERMINATES THE STRING
        CZ      CHRGTR          ;SKIP OVER THE QUOTE
        XTHL
        INX     H
        XCHG                    ;GET POINTER TO TEMP
        MOV     A,C             ;GET CHARACTER COUNT IN A
        CALL    STRAD2          ;SAVE STR INFO
                                ;COMPARE DESC. POINTER & STR POINTER
        COMPAR                  ;TO SEE IF STR IN BUF
        CNC     STRCPY          ;IF IN BUF, MUST COPY IT.
                                ;OTHERWISE STR IN PROGRAM.
;
; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP
; WE WANT TO SETUP A TEMP DESCRIPTOR WITH DSCTMP IN IT
; PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE
; RESULT AS TYPE STRING
;
PUTNEW: LXI     D,DSCTMP        ;[D,E] POINT AT RESULT DESCRIPTOR
        LHLD    TEMPPT          ;[H,L]=POINTER TO FIRST FREE TEMP
        SHLD    FACLO           ;POINTER AT WHERE RESULT DESCRIPTOR WILL BE
IFE     LENGTH-2,<
        MVI     A,3
        STA     VALTYP          ;FLAG THIS AS A STRING
        CALL    VMOVE>          ;AND MOVE THE VALUE INTO A TEMPORARY
IFN     LENGTH-2,<
        MVI     A,1             ;FLAG RESULT AS STRING
        STA     VALTYP          ;STORE IN "VALUE-TYPE" LOCATION
        CALL    MOVE>           ;TRANSFER THE DESCRIPTOR IN
        COMPAR                  ;DSCTMP IS JUST BEYOND THE TEMPS
                                ;AND IF TEMPPT POINTS AT IT THERE
                                ;ARE NO FREE TEMPS
        MVI     E,ERRST         ;"STRING TEMPORARY" ERROR
        JZ      ERROR           ;GO TELL HIM
        SHLD     TEMPPT         ;SAVE NEW TEMPORARY POINTER
        POP     H               ;GET THE TEXT POINTER
        MOV     A,M             ;GET CURRENT CHARACTER INTO [A]
        RET
;
; PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO
; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE
;
STROUI: INX     H               ;POINT AT NEXT CHARACTER
STROUT: CALL    STRLIT          ;GET A STRING LITERAL
;
; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO
;
STRPRT: CALL    FREFAC          ;RETURN TEMP POINTER BY FACLO
IFE     LENGTH-2,<
        CALL    GETBCD          ;[D]=LENGTH [B,C]=POINTER AT DATA
        INR     D               ;INCREMENT AND DECREMENT EARLY
                                ;TO CHECK FOR NULL STRING
STRPR2: DCR     D>              ;DECREMENT THE LENGTH
IFN     LENGTH-2,<
        CALL    MOVRM           ;GET LENGTH IN [E]
        INR     E               ;AND POINTER TO CHARACTERS IN [B,C]
STRPR2: DCR     E>
        RZ                      ;ALL DONE
        LDAX    B               ;GET CHARACTER TO PRINT
        OUTCHR
        CPI     CR
        CZ      CRFIN
        INX     B               ;POINT TO THE NEXT CHARACTER
        JMP     STRPR2          ;AND PRINT IT...
;
; GETSPA - GET SPACE FOR CHARACTER STRING
; MAY FORCE GARBAGE COLLECTION.
;
; # OF CHARS (BYTES) IN [A]
; RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE
; BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
;
GETSPA: ORA     A               ;MUST BE NON ZERO. SIGNAL NO GARBAG YET
        XWD     ^O1000,^O016    ;"MVI C" AROUND THE NEXT
TRYGI2: POP     PSW             ;IN CASE COLLECTED WHAT WAS LENGTH?
        PUSH    PSW             ;SAVE IT BACK
        LHLD    STKTOP          ;GET BOTTOM OF STRING SPACE
        XCHG                    ;IN [D,E]
        LHLD    FRETOP          ;GET TOP OF FREE SPACE IN [H,L]
        CMA                     ;-# OF CHARS
        MOV     C,A             ;IN [B,C]
        MVI     B,255
        DAD     B               ;SUBTRACT FROM TOP OF FREE
        INX     H
        COMPAR                  ;COMPARE THE TWO
        JC      GARBAG          ;NOT ENOUGH ROOM FOR STRING, OFFAL TIME
        SHLD    FRETOP          ;SAVE NEW BOTTOM OF MEMORY
        INX     H               ;MOVE BACK TO POINT TO STRING
        XCHG                    ;RETURN WITH POINTER IN [D,E]
PPSWRT: POP     PSW             ;GET CHARACTER COUNT
        RET                     ;RETURN FROM GETSPA
GARBAG: POP     PSW             ;HAVE WE COLLECTED BEFORE?
        MVI     E,ERRSO         ;GET READY FOR OUT OF STRING SPACE ERROR
        JZ      ERROR           ;GO TELL USER HE LOST
        CMP     A               ;SET ZERO FLAG TO SAY WEVE GARBAGED
        PUSH    PSW             ;SAVE FLAG BACK ON STACK
        LXI     B,TRYGI2        ;PLACE FOR GARBAG TO RETURN TO.
        PUSH    B               ;SAVE ON STACK
GARBA2: LHLD    MEMSIZ          ;START FROM TOP DOWN
IFE     REALIO,<
        MVI     A,7             ;RING THE BELL ON GARBAGE COLLECTION
        OUTCHR>
FNDVAR: SHLD    FRETOP          ;LIKE SO
        LXI     H,$CODE         ;GET DOUBLE ZERO
        PUSH    H               ;SAY DIDNT SEE VARS THIS PASS
        LHLD    STKTOP          ;FORCE DVARS TO IGNORE STRINGS
                                ;IN THE PROGRAM TEXT (LITERALS, DATA)
        PUSH    H               ;FORCE FIND HIGH ADDRESS
        LXI     H,TEMPST        ;GET START OF STRING TEMPS
TVAR:   XCHG                    ;SAVE IN [D,E]
        LHLD    TEMPPT          ;SEE IF DONE
        XCHG                    ;FLIP
        COMPAR                  ;TEST
        LXI     B,TVAR          ;FORCE JUMP TO TVAR
        JNZ     DVAR2           ;DO TEMP VAR GARBAGE COLLECT
SVARS:  LHLD    VARTAB          ;GET START OF SIMPLE VARIABLES
SVAR:   XCHG                    ;GET IN [D,E]
        LHLD    ARYTAB          ;GET END OF SIMPS
        XCHG                    ;FLIP
        COMPAR                  ;SEE IF AT END OF SIMPS
        JZ      ARYTAB          ;IF YES, DO ARRAY TYPE STRINGS
        MOV     A,M             ;GET 2ND CHARACTER OF VARIABLE
        INX     H               ;BUMP POINTER TWICE
        INX     H               ;
IFE     LENGTH-2,<
        INX     H               ;POINT AT THE VALUE
        CPI     3               ;SEE IF ITS A STRING
        JNZ     SKPVAR          ;IF NOT, JUST SKIP AROUND IT
        CALL    DVARS           ;COLLECT IT
        XRA     A               ;AND DON'T SKIP ANYTHING MORE
SKPVAR: MOV     E,A
        MVI     D,0             ;[D,E]=AMOUNT TO SKIP
        DAD     D>
IFN     LENGTH-2,<
        ORA     A               ;SET CC'S
        CALL    DVARS>          ;CALL THE VARIABLE GARB ROUT.
        JMP     SVAR            ;GET NEXT ONE
ARYVA2: POP     B               ;GET RID OF STACK GARBAGE
ARYVAR: XCHG                    ;SAVE ARYVAR IN [D,E]
        LHLD    STREND          ;GET END OF ARRAYS
        XCHG                    ;FLIP BACK
        COMPAR                  ;SEE IF DONE WITH ARRAYS
        JZ      GRBPAS          ;YES, SEE IF DONE COLLECTING
IFE     LENGTH-2,<
        MOV     A,M             ;GET THE VALUE TYPE INTO [A]
        INX     H>
        CALL    MOVRM           ;GET LENGTH OF ARRAY IN [B,C]
IFN     LENGTH-2,<
        MOV     A,E>            ;GET 2ND CHAR OF VAR NAME IN A
        PUSH    H               ;SAVE POINTER TO DIMS
        DAD     B               ;ADD TO CURRENT POINTER POSITION
IFE     LENGTH-2,<
        CPI     3               ;SEE IF ITS A STRING
        JNZ     ARYVA2>         ;IF NOT JUST SKIP IT
IFN     LENGTH-2,<
        ORA     A               ;SEE IF STRING VAR
        JP      ARYVA2>         ;NO, KEEP ON TRUCKIN
        SHLD    TEMP3           ;SAVE END OF ARRAY
        POP     H               ;GET BACK CURRENT POSITION
        MOV     C,M             ;PICK UP NUMBER OF DIMS
        MVI     B,0             ;MAKE DOUBLE WITH HIGH ZERO
        DAD     B               ;GO PAST DIMS
        DAD     B               ;BY ADDING ON TWICE #DIMS (2 BYTE GUYS)
        INX     H               ;ONE MORE TO ACCOUNT FOR #DIMS.
ARYSTR: XCHG                    ;SAVE CURRENT POSIT IN [D,E]
        LHLD    TEMP3           ;GET END OF ARRAY
        XCHG                    ;FIX [H,L] BACK TO CURRENT
        COMPAR                  ;SEE IF AT END OF ARRAY
        JZ      ARYVAR          ;END OF ARRAY, TRY NEXT ARRAY
        LXI     B,ARYSTR        ;ADDR OF WHERE TO RETURN TO
DVAR2:  PUSH    B               ;GOES ON STACK
IFE     LENGTH-2,<
DVAR:
DVARS:  XRA     A
        ORA     H               ;SEE IF ITS THE NULL STRING
        INX     H
        MOV     E,M
        INX     H
        MOV     D,M
        INX     H>              ;[D,E]=POINTER AT THE VALUE
IFN     LENGTH-2,<
DVAR:   ORI     128             ;FORCE DVAR TO CALL GRBVAR
DVARS:  PUSHM                   ;SAVE LENGTH
        PUSHM                   ;SKIP NEXT TWO BYTES
        POP     D               ;GET POINTER IN [D,E]
        POP     B               ;POP OF STRING LENGTH
        RP                      ;IF WASNT A STR, RETURN
        MOVE    A,C             ;GET LENGTH OF STRING
        ORA     A>              ;SET CONDITION CODES
        RZ                      ;NULL STRING, RETURN
        MOV     B,H             ;MOVE [H,L] TO [B,C]
        MOV     C,L
        LHLD    FRETOP          ;GET POINTER TO TOP OF STRING FREE SPACE
        COMPAR                  ;IS THIS STRINGS POINTER .LT. FRETOP
        MOV     H,B             ;MOVE [B,C] BACK TO [H,L]
        MOV     L,C
        RC                      ;IF NOT, NO NEED TO MESS WITH IT FURTHUR
        POP     H               ;GET RETURN ADDRESS OFF STACK
        XTHL                    ;GET MAX SEEN SO FAR & SAVE RETURN ADDRESS
        COMPAR                  ;LETS SEE
        XTHL                    ;SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK
        PUSH    H               ;SAVE RETURN ADDRESS BACK
        MOV     H,B             ;MOVE [B,C] BACK TO [H,L]
        MOV     L,C
        RNC                     ;IF NOT, LETS LOOK AT NEXT VAR
        POP     B               ;GET RETURN ADDR OFF STACK
        POP     PSW             ;POP OFF MAX SEEN
        POP     PSW             ;AND VARIABLE POINTER
        PUSH    H               ;SAVE NEW VARIABLE POINTER
        PUSH    D               ;AND NEW MAX POINTER
        PUSH    B               ;SAVE RETURN ADDRESS BACK
        RET                     ;AND RETURN
;
; HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS
;
GRBPAS: POP     D               ;POP OFF MAX POINTER
        POP     H               ;AND GET VARIABLE POINTER
        MOV     A,L             ;GET LOW IN
        ORA     H               ;SEE IF ZERO POINTER
        RZ                      ;IF END OF COLLECTION,
                                ;THEN MAYBE RETURN TO GETSPA
        DCX     H               ;CURRENTLY JUST PAST THE DESCRIPTOR
        MOV     B,M             ;[B]=HIGH BYTE OF DATA POINTER
        DCX     H
        MOV     C,M             ;[B,C]=POINTER AT STRING DATA
        PUSH    H               ;SAVE THIS LOCATION SO THE POINTER
                                ;CAN BE UPDATED AFTER THE STRING IS
                                ;MOVED
        DCX     H
IFN     LENFTH-2,<
        DCX     H>
        MOV     L,M             ;[L]=STRING LENGTH
        MVI     H,0             ;[H,L] GET CHARACTER COUNT
        DAD     B               ;[H,L]=POINTER BEYOND STRING
        MOV     D,0
        MOV     E,C             ;[D,E]=ORIGINAL POINTER
        DCX     H               ;DON'T MOVE ONE BEYOND STRING
        MOV     B,H             ;GET TOP OF STRING IN [B,C]
        MOV     C,L
        LHLD    FRETOP          ;GET TOP OF FREE SPACE
        CALL    BLTUC           ;MOVE STRING
        POP     H               ;GET BACK POINTER TO DESC.
        MOV     M,C             ;SAVE FIXED ADDR
        INX     H               ;MOVE POINTER
        MOV     M,B             ;HIGH PART
        MOV     L,C
        MOV     H,B             ;[H,L]=NEW POINTER
        DCX     H               ;FIX UP FRETOP
        JMP     FNDVAR          ;AND TRY TO FIND HIGH AGAIN
;
; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS
; THE FACLO CONTAINS THE FIRST ONE AT THIS POINT.
; [H,L] POINTS BEYOND THE + SIGN AFTER IT
;
CAT:    PUSH    B               ;PUT OLD PRECEDENCE BACK ON
        PUSH    H               ;SAVE TEXT POINTER
        LHLD    FACLO           ;GET POINTER TO STRING DESC.
        XTHL                    ;SAVE ON STACK & GET TEXT POINTER BACK
        CALL    EVAL            ;EVALUATE REST OF FORMULA
        XTHL                    ;SAVE TEXT POINTER, GET BACK DESC.
        CALL    CHKSTR
        MOV     A,H
        PUSH    H               ;SAVE DESC. POINTER.
        LHLD    FACLO           ;GET POINTER TO 2ND DESC.
        PUSH    H               ;SAVE IT
        ADD     M               ;ADD TWO LENGTHS TOGETHER
        MVI     E,ERRLS         ;SEE IF RESULT .LT. 256
        JC      ERROR           ;ERROR "LONG STRING"
        CALL    STRINI          ;GET INITIAL STRING
        POP     D               ;GET 2ND DESC.
        CALL    FRETMP
        XTHL                    ;SAVE POINTER TO IT
        CALL    FRETM2          ;FREE UP 1ST TEMP
        PUSH    H               ;SAVE DESC. POINTER (FIRST)
        LHLD    DSCTMP+2        ;GET POINTER TO FIRST
        XCHG                    ;IN [D,E]
        CALL    MOVINS          ;MOVE IN THE FIRST STRING
        CALL    MOVINS          ;AND THE SECOND
        LXI     H,TSTOP         ;CAT REENTERS FORMULA EVALUATION AT TSTOP
        XTHL
        PUSH    H               ;TEXT POINTER OFF FIRST
        JMP     PUTNEW          ;THEN RETURN ADDRESS OF TSTOP
MOVINS: POP     H               ;GET RETURN ADDR
        XTHL                    ;PUT BACK, BUT GET DESC.
IFE     LENGTH-2,<
        MOV     A,M             ;[A]=STRING LENGTH
        INX     H
        MOV     C,M             ;[B,C]=POINTER AT STRING DATA
        INX     H
        MOV     B,M
        MOV     L,A>            ;[L]=STRING LENGTH
IFN     LENGTH-2,<
        PUSHM                   ;GET LENGTH ON STACK
        PUSHM                   ;AND POINTER
        POP     B               ;TEXT POINTER HERE
        POP     H>              ;CHARACTER COUNT HERE
MOVSTR: INR     L
MOVLP:  DCR     L               ;SET CC'S
        RZ                      ;0 NO BYTE TO MOVE
        LDAX    B               ;GET CHAR
        STAX    D               ;SAVE IT
        INX     B               ;MOVE POINTERS
        INX     D
        JMP     MOVLP           ;KEEP DOING IT
;
; FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]
; THIS VALUE IS RETURNED IN [H,L]. ALL THE OTHER REGISTERS ARE MODIFIED.
; A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS
; TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.
; IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE
; STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE
; LOWEST PART OF THE STRING SPACE IN USE.
; IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO
; LONGER IS USE. THIS CAUSES DIFFICULTY FOR ASSIGNMENT ("LET") BECAUSE
; THOUGH A TEMPORARY IS BEING FREED UP, NAMELY THE VALUE TO THE RIGHT
; OF THE EQUAL SIGN IN THE "LET", THE ACTUAL DATA
; IS STILL ACTIVE DATA SINCE A VARIABLE IS BEING SET UP TO POINT
; AT IT. "LET" FOOLS FRETMP BY SETTING THE LENGTH OF THE
; TEMPORARY TO ZERO TEMPORARILY.
;
FRESTR: CALL    CHKSTR          ;MAKE SURE ITS A STRING
FREFAC: LHLD    FACLO
FRETM2: XCHG                    ;FREE UP THE TEMP IN THE FACLO
FRETMP: LHLD    TEMPPT          ;GET TEMP POINTER
        DCX     H               ;LOOK AT WHAT IS IN THE LAST TEMP
        MOV     B,M             ;[B,C]=POINTER AT STRING
        DCX     H               ;DECREMENT TEMPPT BY STRSIZ
        MOV     C,M
        DCX     H
IFN     LENGTH-2,<
        DCX     H>
        COMPAR                  ;SEE IF [D,E] POINT AT THE LAST
        XCHG                    ;RETURN WITH [H,L]
                                ;POINTING AT CURRENT DESCRIPTOR
        RNZ                     ;RETURN NOW IF NOW FREEING DONE
        SHLD    TEMPPT          ;UPDATE THE TEMP POINTER SINCE
                                ;ITS BEEN DECREMENTED BY 4
        PUSH    D               ;SAVE [D,E] TO RETURN IN [H,L]
        MOV     D,B             ;[D,E]=POINTER AT STRING
        MOV     E,C
        DCX     D               ;SUBTRACT ONE
        MOV     C,M             ;[C]=LENGTH OF THE STRING FREED UP
        LHLD    FRETOP          ;SEE IF ITS THE FIRST
                                ;ONE IN STRING SPACE
        COMPAR
        JNZ     NOTLST          ;NO SO DON'T ADD
        MOV     B,A             ;MAKE [B]=0
        DAD     B               ;ADD
        SHLD    FRETOP          ;AND UPDATE FRETOP
NOTLST: POP     H               ;GET POINTER AT CURRENT DESCRIPTOR
        RET
;
; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE
; STRING PASSED AS AN ARGUMENT
;
LEN:    LXI     B,SNGFLT        ;CALL SNGFLT WHEN DONE
        PUSH    B               ;LIKE SO
LEN1:   CALL    FRESTR          ;FREE UP TEMP POINTED TO BY FACLO
        XRA     A               ;FORCE NUMERIC FLAG
        MOV     D,A             ;SET HIGH OF [D,E] TO ZERO FOR VAL
IFN     LENGTH-2,<
        STA     VALTYP>
        MOV     A,M
        ORA     A               ;SET CONDITION CODES ON LENGTH
        RET                     ;RETURN
;
; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS AN INTEGER
; WHICH IS THE DECIMAL ASCII EQUIVALENT
;
ASC:    CALL    LEN1            ;SET UP ORIGINAL STR
        JNZ     FCERR           ;NULL STR, BAD ARD.
        INX     H               ;BUMP POINTER
IFN     LENGTH-2,<
        INX     H>              ;BUMP POINTER
        PUSHM                   ;GET ADDRESS
        POP     H               ;GET ADDR IN [H,L]
        MOV     A,M             ;GET FIRST CHAR
        JMP     SNGFLT          ;SNGFLT IT
;
; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARG (#)
; WHICH MUCH BE .LT. 255.
;
CHR$:   MVI     A,1             ;ONE CHARACTER STR
        CALL    STRINI          ;GET STRING IN DSCTMP
        CALL    CONINT          ;GET INTEGER IN RANGE
        LHLD    DSCTMP+2        ;GET ADDR OF STR
        MOV     M,E             ;SAVE ASCII BYTE
FINBCK: POP     B               ;RETURN TO HIGHER LEVEL &
                                ;SKIP THE CHKNUM CALL.
        JMP     PUTNEW          ;GO CALL PUTNEW
;
; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
; IT TAKES THE LEFTMOST # CHARS OF THE STR.
; IF # IS .GR. THAN THE LEN OF THE STR, IT REURNS THE WHOLE STR.
;
LEFT$:  CALL    PREAM           ;TEST THE PARAMETERS
        XRA     A               ;LEFT NEVER CHANGES STRING POINTER
LEFT3:  XTHL                    ;SAVE THE TEXT POINTER
        MOV     C,A             ;OFFSET NOW IN [C]
LEFT2:  PUSH    H               ;SAVE DESC. FOR  FRETMP
        MOV     A,H             ;GET STRING LENGTH
        CMP     B               ;ENTIRE STRING WANTED?
        JC      ALLSTR          ;IF #CHARS ASKED FOR.GE.LENGTH.YES
        MOV     A,B             ;GET TRUNCATED LENGTH OF STRING
        XWD     ^O1000,^O21     ;SKIP OVER MVI USING "LXI D,"
ALLSTR: MVI     C,0             ;MAKE OFFSET ZERO
        PUSH    B               ;SAVE OFFSET ON STACK
        CALL    GETSPA          ;GET SPACE FOR NEW STRING
        POP     B               ;GET BACK OFFSET
        POP     H               ;GET BACK DESC POINTER.
        PUSH    H               ;BUT KEEP ON STACK
        INX     H               ;MOVE TO STRING POINTER FIELD
IFN     LENGTH-2,<
        INX     H>
        MOV     B,M             ;GET POINTER LOW
        INX     H               ;
        MOV     H,M             ;POINTER HIGH
        MOV     L,B             ;GET LOW IN  L
        MVI     B,0             ;GET READY TO ADD OFFSET TO POINTER
        DAD     B               ;ADD  IT
        MOV     B,H             ;GET OFFSET POINTER IN [B,C]
        MOV     C,L
        CALL    STRAD2          ;SAVE INFO IN DSCTMP
        MOV     L,A             ;GET#  OF CHARS TO  MOVE IN L
        CALL    MOVSTR          ;MOVE THEM IN
        POP     D               ;GET BACK DESC. POINTER
        CALL    FRETMP          ;FREE IT UP.
        JMP     PUTNEW          ;PUT TEMP IN TEMP LIST
RIGHT$: CALL    PREAM           ;CHECK ARG
        POP     D               ;GET DESC. POINTER
        PUSH    D               ;SAVE BACK FOR LEFT
        LDAX    D               ;GET PRESENT LEN OF STR
        SUB     B               ;SUBTRACT 2ND PARM
        JMP     LEFT3           ;CONTINUE WITH LEFT CODE
;
; MID ($,#) RETURNS STR WITH CHARS FROM # POSITION
; ONWARD. IF # IS GT LEN($) THEN RETURN NULL STRING.
; MID ($,#,#) RETURNS STR WITH CHARS FROM # POSITION
; FOR #2 CHARS. IF @2 GOES PAST END OF STRING, RETURN
; AS MUCH AS POSSIBLE
;
MID$:   XCHG                    ;PUT THE TEXT POINTER IN [H,L]
        MOV     A,M             ;GET THE FIRST CHARACTER
        CALL    PREAM2          ;GET OFFSET OFF STACK AND MAKE
                                ;SURE DOES NOT = 0
        PUSH    B               ;PUT OFFSET ON TO THE STACK
        MVI     E,255           ;IF TWO ARG GUY, TRUNCATE.
        CPI     ")"
        JZ      MID2            ;[E] SAYS USE ALL CHARS
                                ;IF ONE ARGUMENT THIS IS CORRECT
        SYNCHK  442             ;COMMA? MUST DELINEATE 3RD ARG.
        CALL    GETBYT          ;GET ARGUMENT  IN  [E]
MID2:   SYNCHK  ")"             ;MUST BE FOLLOWED BY )
        POP     PSW             ;GET OFFSET BACK IN A
        XTHL                    ;SAVE TEXT POINTER, GET DESC.
        LXI     B,LEFT2         ;WHERE TO RETURN TO.
        PUSH    B               ;GOES ON STACK
        DCR     A               ;SUB ONE FROM OFFSET
        CMP     M               ;POINTER PAST END OF STR?
        MVI     B,0             ;ASSUME NULL LENGTH STR
        RNC                     ;YES, JUST USE NULL STR
        MOV     C,A             ;SAVE OFFSET OF CHARACTER POINTER
        MOC     A,M             ;GET PRESENT LEN OF STR
        SUB     C               ;SUBTRACT INDEX (2ND ARG)
        CMP     E               ;IS IT TRUNCATION
        MOV     B,A             ;GET CALCED LENGTH IN B
        RC                      ;IF NOT USE PARTIAL STR
        MOV     B,E             ;USE TRUNCATED LENGTH
        RET>                    ;RETURN TO LEFT2
IFN LENGTH,<
;
; THE FOLLOWING FUNCTIONS ALLOW THE
; USER FULL ACCESS TO THE ALTAIR I/O PORTS
; INP(CHANNEL#) RETURNS AN INTEGER WHICH IS THE STATUS
; OF THE CHANNEL. OUT CHANNEL#,VALUE PUTS OUT THE INTEGER
; VALUE ON CHANNEL #. IT IS A STATEMENT, NOT A FUNCTION.
;
FNINP:  CALL    CONINT          ;GET INTEGER CHANNEL #
        STA     INPWRD+1        ;GET INP INSTR
INPWRD: IN      0               ;THE INP INSTR
        JMP     SNGFLT          ;SNGFLT RESULT
                                ;GET READY
FNOUT:  CALL    SETIO
OUTWRD: OUT     0               ;DO IT
        RET                     ;AND THATS ALL
;
; THE WAIT CHANNEL#,MASK,MASK2,WAITS UNTIL THE STATUS
; RETURNED BY CHANNEL# IS NON ZERO WHEN XORED WITH MASK2
; AND THEN ANDED WITH MASK. IF MASK2 IS NOT PRESENT IT IS ASSUMED
; TO BE ZERO
;
FNWAIT: CALL    SETIO           ;SET UP FOR WAIT
        PUSH    PSW             ;SAVE THE MASK
        MVI     E,0             ;DEFAULT MASK2 TO ZERO
        DCX     H
        CHRGET                  ;SEE IF THE STATEMENT ENDED
        JZ      NOTTHR          ;IF NO THIRD ARGUMENT SKIP THIS
        SYNCHK  44              ;MAKE SURE THERE IS A ","
        CALL    GETBYT
NOTTHR: POP     B               ;REGET THE "AND" MASK
STAINP: IN      0               ;THE INPUT INSTR
        XRA     E               ;XOR WITH MASK2
        ANA     B               ;AND WITH MASK
        JZ      STAINP          ;LOOP UNTIL RESULT IS NON-ZERO
                                ;NOTE: THIS LOOP CANNOT BE CONTROL-C'ED
                                ;UNLESS THE AIT IS BEING DONE ON CHANNEL
                                ;ZERO. HOWEVER A RESTART AT 0 IS OK.
        RET>
IFN     STRING,<
;USED BY RIGHT$ AND LEFT$ FOR PARAMETER CHECKING AND SETUP
PREAM:  XCHG                    ;PUT THE TEXT POINTER IN [H,L]
        SYNCHK  ")"             ;PARAM LIST SHOULD END
;USED BY MID$ FOR PARAMETER CHECKING AND SETUP
PREAM2: POP     B               ;GET RETURN ADDR OFF STACK
        POP     D               ;GET LENGTH OF ARG OFF STACK
        PUSH    B               ;SAVE RETURN ADDR BACK ON
        MOV     B,E             ;SAVE INIT LENGTH
        INR     B
        DCR     B               ;SEE IF EQUAL TO ZERO
IFE     LENGTH-2,<
        RNZ
ILLFUN:
FCERR:  MVI     E,ERRFC
        JMP     ERROR>
IFN     LENGTH-2,<
        JZ      FCERR           ;IT MUST NOT BE 0
        RET>
IFN     LENGTH,<
SETIO:  CALL    GETBYT          ;GET INTEGER CHANNEL NUMBER IN [A]
        STA     STAINP+1        ;SETUP "WAIT"
        STA     OUTWRD+1        ;SETUP "OUT"
        SYNCHK  44              ;MAKE SURE THERE IS A COMMA
        XWD     ^O1000,6>       ;"MVI B," AROUND THE CHRGET
IFN     STRING!LENGTH,<
GTBYTC: CHRGET
IFE     LENGTH-2,<
GETBYT: CALL    FRMEVL
CONINT: PUSH    H
        CALL    FRCINT
        ZCHG
        POP     H>
IFN     LENGTH-2,<
GETBYT: CALL    FRMNUM          ;READ FORMULA INTO THE FAC.
CONINT: CALL    POPINT>         ;CONVERT THE FAC TO A SINGLE BYTE INTEGER
        MOV     A,D             ;SHOULD BE .LT. 255
        ORA     A               ;SET CC'S
        JNZ     FCERR           ;WASN'T ERROR
        DCX     H               ;ACTUALLY FUNCTIONS CAN GET HERE
                                ;WITH BAD [H,L] BUT NOT SERIOUS
                                ;SET CONDITION CODES ON TERMINATOR
        CHRGET
        MOV     A,E             ;RETURN THE RESULT IN [A] AND [E]
        RET>
IFN     STRING,<
;
; THE VAL FUNCTION TAKES A STRING AND TURN IT INTO
; A NUMBER BY INTERPRETING THE ASCII DIGITS. ETC...
; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL
; IS MERELY A CALL TO FLOATING INPUT (FIN)
;
VAL:    CALL    LEN1            ;DO SETUP, SET RESULT=REAL
        JZ      ZERO            ;RETURN ZERO IF NULL
        MOV     E,A             ;GET LENGTH OF STR
IFN     LENGTH-2,<
        INX     H>              ;THIS IS ALL A KLUDGE
        INX     H               ;TO HANDLE THE FACT THE IF
        PUSHM                   ;TWO STRINGS "1" AND "2"
        MOV     H,B             ;ARE STORED NEXT TO EACH OTHER
        MOV     L,C             ;AND FIN IS CALLED POINTING TO
        DAD     D               ;THE FIRST TWELVE WILL BE RETURNED
        MOV     B,M             ;THE IDEA IS TO STORE 0 IN THE
        MOV     M,D             ;STRING BEYOND THE ONE VAL
        XTHL                    ;IS BEING CALLED ON
        PUSH    B               ;THE FIRST CHARACTER OF THE NEXT STRING
        MOV     A,M             ;GET FIRST CHARACTER OF ARGUMENT
        CALL    FIN             ;TURN IT INTO A NUMBER IN THE FAC
        POP     B               ;GET THE MODIFIED CHARACTER OF THE NEXT
                                ;STRING INTO [B]
        POP     H               ;GET THE POINTER TO THE MODIFIED CHARACTER
        MOV     M,B             ;RESTORE THE CHARACTER
                                ;IF STRING IS THE HIGHEST IN STRING SPACE
                                ;WE ARE MODIFYING [MEMSIZ] AND
                                ;THIS IS WHY [MEMSIZ] CAN'T BE USED TO STORE
                                ;STRING DATA BECAUSE WHAT IF THE
                                ;USER TOOK VAL OFF THAT HIGH STRING
        RET>
PAGE
SUBTTL  FANCY LIST,DELETE,EDIT,LLIST
IFE     LENGTH-2,<
IFN     LPTSW,<
LLIST:  MVI     A,1             ;GET NON ZERO VALUE
        STA     PRTFLG>         ;SAVE IN I/O FLAG
LIST:   POP     B               ;GET RID OF NEWSTT RETURN ADDR
        CALL    SCNLIN          ;SCAN LINE RANGE
        PUSH    B               ;SAVE POINTER TO 1ST LINE
LIST4:  POP     H               ;GET POINTER TO LINE
        POP     D               ;GET MAX LINE # OFF STACK
        PUSHM                   ;PUSH LINK
        MOV     A,B             ;SEE IF END OF CHAIN
        ORA     C
        POP     B               ;GET LINK OFF STACK FOR ISCNTC
        JZ      READY           ;LAST LINE, STOP.
IFN     LISTEN,<
        CALL    ISCNTC>         ;CHECK FOR CONTROL-C
        PUSH    B               ;SAVE LINK BACK ON
        PUSHM                   ;PUSH LINE #
        XTHL                    ;GET LINE # INTO [H,L]
        XCHG                    ;GET MAX LINE IN [H,L]
        COMPAR                  ;PAST LAST LINE IN RANGE?
        POP     B               ;TEXT POINTER TO [B,C]
        JC      STPRDY          ;IF PAST, THEN DONE LISTING.
        XTHL                    ;SAVE MAX ON BOTTOM OF STACK
        PUSH    H               ;SAVE LINK ON TOP
        PUSH    B               ;SAVE TEXT POINTER BACK
        XCHG                    ;GET LINE # IN [H,L]
        CALL    CRDO            ;DO CRLF TO START OUT
                                ;AND WE WANT [H,L] ON THE STACK
        CALL    LINPRT          ;PRINT AS INT WITHOUT LEADING SPACE
        MVI     A," "
        POP     H
        OUTCHR                  ;PRINT A SPACE AFTER THE LINE #
        CALL    BUFLIN          ;UNPACK THE LINE INTO BUG
        LXI     H,BUF-1         ;POINT AT THE START OF THE UNPACKED CHARACTERS
        MVI     B,0             ;STOP ON ZERO ONLY
        CALL    STRLT3          ;LITERALIZE THE LINE STRING
        CALL    STRPRT          ;PRINT OUT THE CHARACTERS
        JMP     LIST4           ;PRINT ANOTHER LINE
BUFLIN: LXI     B,BUF-1
        XWD     ^O1000,^O26     ;"MVI   D," AROUND THE NEXT BYTE
PRIT4:  POP     H               ;RESTORE POINTER TO START OF TEXT
PLOOP:  MOV     A,M             ;GET A CHARACTER FROM LINE.
        INX     B               ;ADVANCE STUFF COUNT
        ORA     A               ;IS IT A RESERVED WORD
        INX     H               ;INCREMENT POINTER INTO TEXT
        STAX    B               ;STORE A ZERO IF THE END
        RZ                      ;ZERO, END OF LINE.
        JP      PLOOP           ;REGULAR CHAR, JUST PRINT IT
        CPI     ELSETK          ;IF ITS "ELSE" DON'T PRINT THE COLON
                                ;IN FRONT OF IT
        CZ      DCXBRT##        ;BACKUP STUFF COUNT TO ELIMINATE
        SUI     127             ;GET RID OF SIGN BIT AND ADD ONE
        PUSH    H               ;SAVE CURRENT POSIT
        LXI     D,RESLST        ;GET RESLIST POINTER.
RESRCH: PUSH    D
        PUSH    PSW             ;SAVE THE RESERVED WORD NUMBER
RESCR1: LDAX    D               ;GET CHARACTER FROM RESLST
        INX     D               ;BUMP RESLST POINTER
        ORA     A               ;TEST BITS
        JP      RESCR1          ;NOT AT END OF RESERVED WORD YET
        POP     PSW
        DCR     A               ;DECREMENT CHAR
        POP     H               ;POP START POINTER HERE
        JNZ     RESRCH          ;NOT AT END OF RESLST YET.
;HERE WHEN FOUND RIGHT RESERVED WORD
PRIT3:  MOV     A,M             ;GET A CHARACTER FROM RESERVED WORD
        ORA     A               ;SET CONDITION CODES
        STAX    B
        JM      PRIT4
        INX     B
        INX     H               ;BUMP RESLST POINTER
        JMP     PRIT3           ;PRINT THE REST
;
; THE FOLLOWING CODE IS FOR THE DELETE RANGE
; COMMAND. BEFORE THE LINES ARE DELETED, 'OK'
; IS TYPED.
;
DELETE: CALL    SCNLIN          ;SCAN LINE RANGE
        POP     D               ;POP MAX LINE OFF STACK
        PUSH    B               ;SAVE POINTER TO START OF 1ST LINE
        CALL    FNDLIN          ;FIND THE LAST LINE
        POP     B               ;GET POINTER TO FIRST IN [B,C]
        PUSH    H               ;SAVE THE POINTER TO THE NEXT LINE
        LXI     H,REDDY         ;PRINT "OK" PREMATURELY
        CALL    STROUT
        LXI     H,FINI          ;GO BACK TO FINI WHEN DONE
        XTHL                    ;[H,L]=POINTER TO THE NEXT LINE
DEL:    XCHG                    ;[D,E] NOW HAVE THE POINTER TO THE LINE
                                ;BEYOND THIS ONE
        LHLD    VARTAB          ;COMPACTIFYING TO VARTAB
MLOOP:  LDAX    D
        STAX    B               ;SHOVING DOWN TO ELIMINATE A LINE
        INX     B
        INX     D
        COMPAR
        JNC     MLOOP           ;DONE COMPACTIFYING?
        MOV     H,B
        MOV     L,C
        INX     H               ;NEW VARTAB
        SHLD    VARTAB
        RET>
PAGE
SUBTTL  DISK CODE
IFN     DSKFUN,<
;
; THE STATEMENT DSKO$ STRING,SECTOR WRITES
; THE STRING (UP TO 132 DECIMAL CHARS
; ON THE SECTOR SPECIFIED.
; DSKI$ (SECTOR) IS A STRING FUNCTION THAT
; RETURNS THE 133 BYTE STRING STORED ON SECTOR.
;
DSKO$:  CALL    FRMEVL          ;EVALUATE FORMULA
        SYNCHK  44              ;FOLLOWED BY COMMA
        PUSH    H               ;SAVE TEXT POINTER
        CALL    FRESTR          ;FREE UP THE FACLO
        XTHL                    ;[H,L]=TXTPTR SAVE POINTER AT
                                ;STRING DESCRIPTOR ON THE STACK
        CALL    GETBYT          ;EVALUATE 2ND ARG(SECTOR) IN [E]
        XTHL                    ;SAVE TEXT POINTER, GET DESC.
        PUSHM                   ;[C]=LENGTH [H,L]=POINTER
        PUSHM
        POP     H               ;[H,L] GET STRING POINTER
        POP     B
        MOV     B,A             ;SECTOR NUMBER INTO [B]
        MVI     A,^D137
        SUB     C
        JC      FCERR           ;STRING TOO LONG
        INR     A
        MOV     E,A             ;NUMBER OF ZEROS+1
        MVI     D,64            ;SETUP A MASK
        INR     C
        MVI     A,4             ;LOAD THE HEAD
        OUT     9               ;TO DISK STATUS
SECLP:  IN      ^O11            ;GET SECTOR STATUS
        RAR                     ;TEST FOR START OF SECTOR
        JNC     SECLP           ;KEEP WAITING
        ANI     63              ;START OF SECTOR, RIGHT ONE
        CMP     B               ;COMPARE TO FIND OUT
        JNZ     SECLP           ;IF NOT
        MVI     A,128           ;WRITE ENABLE DISK
        OUT     9
        MVI     8,255           ;ALL ONE'S ALWAYS WRITTEN FIRST
WRITOK: IN      8               ;GET STATUS
        ANA     D               ;WRITE OK
        JZ      WRITOK          ;NO, MORE LOOPING.
        MOV     A,B             ;GET CHARACTER TO WRITE
        OUT     10              ;SEND IT OUT
        DCR     C               ;TEST FOR NULL
        JZ      ZRLOP
NOTYTD: IN      8               ;POLL
        ANA     D               ;MASK TEST
        JZ      NOTYTD          ;WAITING
        MOV     A,M             ;GET CHARACTER
        OUT     10
        DCR     C               ;DECREMENT CHARACTER COUNT
        INX     H
        JNZ     NOTYTD
ZRLOP:  IN      8
        ANA     D
        JZ      ZRLOP
        XRA     A               ;PUT OUT A ZERO
        OUT     10
        DCR     E
        JNZ     ZRLOP
TRUFIN: MVI     A,8             ;UNLOAD THE HEAD
        OUT     9
        POP     H
        RET                     ;DONE

DSKI$:  MVI     A,137           ;A LOT OF CHARACTERS ARE COMING
        CALL    STRINI          ;MAKE ROOM!
        CALL    CONINT          ;WHERE ARE THEY?
                                ;SECTOR NOW IN [E]
        LHLD    DSCTMP+2        ;PLACE TO STORE THEM
        MVI     A,4             ;LOAD THE HEAD
        OUT     9
SECLP2: IN      9               ;GET SECTOR INFO
        ORA     A               ;SEE IF BEGINNING OF SECTOR(READ)
        JP      SECLP2          ;IF NOT, KEEP WAITING
        RAR                     ;FIX UP SECTOR #
        ANI     63              ;GET SECTOR #
        CMP     E               ;IS IT THE ONE WE WAITED
        JNZ     SECLP2          ;TRY TO FIND IT
        MVI     C,137           ;GET # OF CHARS TO READ
READOK: IN      8               ;GET DISK STATUS
        ORA     A               ;READY TO READ BYTE
        JP      READOK
        IN      10              ;READ THE STUFF
        MOV     M,A             ;SAVE IN STR
        INX     H               ;BUMP DEST POINTER
        DCR     C               ;LESS CHARS
        JNZ     READOK
        MVI     A,8             ;UNLOAD HEAD
        OUT     9
        JMP     FINBCK          ;USE CHR$ TO FINISH UP

PATCH:  BLOCK   20>
PAGE
SUBTTL  CLOAD,CSAVE,CONSOLE
;
; THE CONSOLE COMMAND ALLOWS THE USER TO CHANGE THE I/O CHANNEL
; THAT THE USER TERMINAL IS ON. BY GIVING THE COMMAND CONSOLE X
; WHERE X IS SOME INTEGER THE TERMINAL DEVICE WILL BE POLLED FROM
; CHANNELS X AND X+1. RESTARTING AT LOCATION ZERO FORCED THE TERMINAL
; TO BE ON CHANNEL ZERO AGAIN.
;
IFN     CONSSW,<
INTERNAL        CONSDO
CONSDO: XRA     A               ;FORCE A CHANNEL ZERO CONSOLE
        CALL    CONS2           ;ON RESTART AT ZERO
        JMP     READY           ;TYPE "OK" AND ACCEPT INPUT
CONSOL: CALL    GETBYT          ;FETCH AN INTEGER INTO [A]
        RNZ                     ;CHECK FOR A TERMINATOR
CONS2:
IFN     REALIO,<
        STA     CNLCA1          ;CHANGE ALL THE FLAG INPUT CHANNEL
        STA     CNLCA2
        STA     CNLCA3>
IFN     LENGTH,<
        STA     CNLCA4>
        INR     A               ;[A]=DATA INPUT CHANNEL
        STA     CNLCB1          ;CHANGE ALL THE DATA INPUT CHANNEL
        STA     CNLCB2
        RET>
IFN     CASSW,<
;
; CASIN READS A CHARACTER FROM THE CASSETTE
; INTO [A] WITHOUT MODIFYING ANYTHING BUT [A] AND THE CONDITION
; CODES
;
CASIN:  IN      6               ;ROUTINE TO READ A CHARACTER
        ANI     IDONE           ;FROM THE CASSETTE INTO [A]
        JNZ     CASIN
        IN      7               ;READ THE DATA
        RET
;
; CASOUT OUTPUTS THE CHARACTER IN [A] TO THE CASSETTE
; WITHOUT MODIFYING ANYTHING
;
TWOCSO: CALL    CASOUT          ;DOUBLE OUT OF [A]
CASOUT: PUSH    PSW             ;ROUTINE TO WRITE A CHARACTER IN [A]
CASLK:  IN      6               ;ONTO THE CASSETTE
        ANI     ODONE
        JNZ     CASLK           ;WAIT TILL CASSETTE IS READY
        POP     PSW             ;GET THE CHARACTER BACK
        OUT     7               ;OUTPUT THE CHARACTER
        RET
;
; THE CSAVE COMMAND WRITES A PROGRAM ONTO CASSETTE BY DUMPING
; BASICS CORE. THE HEADER IS THREE 211'S FOLLOWED BY A ONE
; CHARACTER FILE NAME. THE END IS THREE ZEROS IN A ROW.
;
CSAVE:  PUSH    H
        MVI     A,211
        CALL    CASOUT          ;PUT OUT THE START BYTES
        CALL    TWOCSO          ;TWO MORE TIMES
        MOV     A,M             ;GET FILENAME
        CALL    CASOUT          ;STORE AFTER 211'S
        LHLD    TXTTAB          ;START OF PROGRAM
        XCHG
        LHLD    VARTAB          ;END OF PROGRAM
LOPCSO: LDAX    D               ;GET A BYTE FROM THE PROGRAM
        INX     D
        CALL    CASOUT          ;SEND IT OUT TO THE CASSETTE
        COMPAR                  ;THE END?
        JNZ     LOPCSO          ;IF NOT,OUTPUT MORE
        CALL    TWOCSO          ;TWO MORE 0'S TO MARK THE END
        POP     H               ;RESTORE THE TEXT POINTER
        CHRGET                  ;GO PAST THE FILE NAME
        RET
;
; THE CLOAD COMMAND CLEARS CORE AND THEN READS A PROGRAM
; FROM CASSETTE. SINCE THE LINKS OF THE FILE ON CASSETTE
; WILL BE WRONG IF THE FILE WAS SAVED WITH A DIFFERENT VERSION
; BASIC FINI IS JUMPED TO. A SCRATCH IS DONE AT THE START SO RESTARTS
; AT 0 WON'T LEAVE THIGNS IN A GARBAGE STATE.
;
CLOAD:  STA     FACLO           ;SAVE THE FILENAME
        CALL    SCRTCH          ;RESET EVERYTHING
LOPCLK: MVI     B,3             ;NUMBER OF START CHARACTERS
LOPCL2: CALL    CASIN           ;GET A CHARACTER
        CPI     211             ;START CHARACTER?
        JNZ     LOPCLK          ;NO RESET COUNT AND LOOK SOME MORE
        DCR     B               ;DECREMENT THE COUNT
        JNZ     LOPCL2          ;SEEN THREE YET?
        LXI     H,FACLO         ;POINT AT THE FILENAME
        CALL    CASIN           ;READ THIS FILENAME
        CMP     M               ;THE RIGHT FILE?
        JNZ     LOPCLK          ;IF NOT,START COMPLETELY OVER
        LHLD    TXTTAB          ;PLACE TO STORE THE PROGRAM
DOCRS:  MVI     B,4             ;NUMBER OF ZEROS TO GET
                                ;BEFORE STOPPING
DOCSMR: CALL    CASIN           ;GET A CHARACTER
        MOV     M,A             ;STORE IT
        CALL    REASON          ;MAKE SURE THERE IS ROOM
        MOV     A,M             ;REGET THE CHARACTER
        ORA     A               ;A ZERO?
        INX     H
        JNZ     DOCRS           ;RESET # OF ZEROES SEEN
        DCR     B               ;DECREMENT NUMBER OF ZEROS
        JNZ     DOCSMR          ;SEEN FOUR?
        SHLD    VARTAB          ;SETUP END OF PROGRAM
        LXI     H,REDDY         ;TYPE "OK" PREMATURELY
        CALL    STROUT
        JMP     FINI>           ;FIX UP THE LINKS AND GO BACK TO MAIN
PAGE
SUBTTL PEEK AND POKE
IFN     LENGTH,<
IFE     LENGTH-2,<
PEEK:   CALL    FRCINT          ;GET AN INTEGER IN [H,L]
        MOV     A,M>            ;GET THE VALUE TO RETURN
IFN     LENGTH-2,<
PEEK:   CALL    POSINT          ;GET THE VALUE OF FACLO INTO [D,E]
        LDAX    D>              ;READ THE VALUE
        JMP     SNGFLT          ;AND FLOAT IT
IFE     LENGTH-2,<
POKE:   CALL    FRMEVL
        PUSH    H               ;SAVE THE TEXT POINTER
        CALL    FRCINT          ;GET INTEGER VALUE OF FAC IN [H,L]
        XTHL>                   ;GET BACK THE TEXT POINTER
IFN     LENGTH-2,<
POKE:   CALL    INTID2          ;READ LOCATION TO POKE
        PUSH    D>              ;SAVE THE LOCATION
        SYNCHK  44              ;CHECK FOR A COMMA
        CALL    GETBYT
        POP     D               ;GET THE ADDRESS BACK
        STAX    D               ;STORE IT AWAY
        RET>                    ;SCANNED EVERYTHING
;
; NOTE: IN THE 8K PEEK ONLY ACCEPTS POSITIVE NUMBERS UP TO 32767
; POKE WILL ONLY TAKE AN ADDRESS UP TO 32767 , NO
; FUDGING ALLOWED. THE VALUE IS UNSIGNED.
;
.C1=.P
END
003114' SIN     DCOMP           000702' EXT
003127' SIN     DCXBRT          011204' EXT
003461' SIN     DDIV            000700' EXT
003303' SIN     DEF             007411'
003124' SPD     DEFFIN          007521'
003136' SPD     DEL             011271'
003465'         DELETE          011245'
001541' INT     DFACLO          001633' INT
002705'         DIM             006500'
004553'         DIMCON          006473'
006405' EXT     DIMFLG          001542'
011023'         DIRIS           003542'
006041' EXT     DMULT           000676' EXT
000000  SPD     DNTCPY          004217'
003542'         DOASIG          005056'
000001  SPD     DOCMP           006375'
000017          DOCOND          004354'
004237'         DODSP           005756'
000131' EXT     DOMIN           006146'
000131' INT     DONMUL          007326'
000015  SPD     DORES           001544'
004523' INT     DOSIZT          004621'
002753'         DSCTMP          001570'
004534'         DSKFUN          000000  SPD
002533'         DSUB            000674' EXT
006345'         DV0ERR          002075' INT
001607' INT     DVAR            010214'
002316'         DVAR2           010213'
000002          DVARS           010214'
000672' EXT     E               000003
006437'         EATEM           006535'
004072'         EDIT            000632' EXT
000203  SPD     ELSE            007074'
005025'         ELSETK          000220  SPD
005166'         END             003474'
001577'         ENDCON          003501'
005163'         ENDREL          005415'
001627'         ENDTK           000200  SPD
002064'         EQULTK          000260
000672'         ERRBS           000011  SPD
                ERRCN           000021  SPD
                ERRDD           000012  SPD
                ERRDIR          007532'
                ERRDV0          000013  SPD
                ERRFC           000005  SPD
                ERRFIN          002127'
                ERRID           000014  SPD
                ERRLS           000017  SPD
                ERRNF           000001  SPD
                ERROD           000004  SPD
SEARCH  MCS808                  ;THE UNIVERSAL FILE
SUBTTL  COMMON FILE
SALL
LENGTH==1                       ; 0 MEANS 4K, 1 MEANS 8K, 2 MEANS 12K
REALIO==1
CASSW==1                        ;CASSETTE SWITCH (CSAVE,CLOAD)
LPTSW==0
DSKFUN==0                       ;ON TO READ/WRITE
CONSSW==0
CONTRW==1                       ;ALLOW ^O
IFE     REALIO,<
        LPTSW==0                ;SIMULATOR DEFAULTS
        CASSW==0
        CONSSW==0
        DSKFUN==0
        CONTRW==0>
IFE     LENGTH,<
        EXTFNC==0               ;ON MEANS EXTENDED FUNCTIONS
        MULDIM==0               ;ON MEANS MULTIPLE DIMENSIONED ARRAYS ALLOWED
        STRING==0               ;ON MEANS STRINGS ALLOWED
        CASSW==0
        LPTSW==0
        DSFFUN==0
        CONSSW==0
        CONTRW==0>
IFE     LENGTH-1,<
        EXTFNC==1
        MULDIM==1
        STRING==1>
IFE     LENGTH-2,<
        EXTFNC==1
        MULDIM==1
        STRING==1>
DEFINE  SYNCHK(A),<RST  1
                A>
DEFINE  CHRGET,<RST     2>
DEFINE  OUTCHR,<RST     3>
DEFINE  COMPAR,<RST     4>
DEFINE  FSIGN,<RST      5>
DEFINE  PUSHM,<RST      6>
DEFINE  PUSHFM,<PUSHM
                PUSHM>
DEFINE  ACRLF,<
        ^D13
IFN     STRING,<^D10>>
DEFINE  PUSHR,<
        PUSH    D
        PUSH    B>
DEFINE  POPR,<
        POP     B
        POP     D>
DEFINE  MOVRI(B,C,D,E),<
        XWD     ^O1000,^O001    ;; "LXI B"
        EXP     C
        EXP     B
        XWD     ^O1000,^O021    ;; "LXI D"
        EXP     E
        EXP     D>
IF1,<
IFE     LENGTH,<PRINTX  /SMALL/>
IFE     LENGTH-1,<PRINTX        /MEDIUM/>
IFE     LENGTH-2,<PRINTX        /BIG/>
IFE     REALIO,<PRINTX  /SIMULATE/>
IFN     REALIO,<PRINTX  /ON MACHINE/>
IFN     CASSW,<PRINTX   /CASSETTE/>
IFN     LPTSW,<PRINTX   /LPT/>
IFN     DSKFUN,<PRINTX  /DISK/>
IFN     CONSSW,<PRINTX  /CONSOLE/>>
PAGE
SUBTTL  FLOATING POINT MATH PACKAGE CONFIGURATION
TITLE   MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF
IFNDEF  LENGTH,<
        PRINTX  !!! MUST HAVE COM !!!
        END>
RADIX   8                       ;!!!! ALERT !!!!
                                ;THROUGHOUT THE MATHPACKAGE!!
        ,P==0
INTERNAL        ZERO,FLOAT,FLOATR,MOVE,FADD,FADDS,FSUB,FMULT,FDIV,FUN,FOUT
INTERNAL        PUSHF,ABS,INT,QINT,SGN,SQR,RND,SIN,FCOMP,SIGNC,OVERR
INTERNAL        INPRT,LINPRT,MOVFM,MOVMF,MOVFR,MOVRF,MOVRM,NEG,INRART,INXHRT
IFN     EXTFNC,<
INTERNAL        FPWR,EXP,LOG,COS,TAN,ATN,FONE>
IFN     MULDIM&<LENGTH-2>,<
INTERNAL        DMULT>
IFN     STRING,<
INTERNAL        SIGNS>
IFN     LENGTH-2,<
INTERNAL        FADDT,FSUBT,FMULTT,FDIVT>
IFE     LENGTH-1,<
INTERNAL        FPWRT>
IFE     LENGTH-2,<
INTERNAL        VMOVMF,VMOVFM,FRCINT,FRCSNG,FRCDBL,VNEG,PUFOUT,DCXBRT,IADD
INTERNAL        ISUB,IMULT,IDIV,ICOMP,INET,DADD,DSUB,DMULT,DDIV,DCOMP,INTFNC>
EXTERNAL        FAC,FACLO,FBUFFR,MINUTK,PLUSTK,ERROR,DV0ERR,ERROV,FCERR,SIGN
EXTERNAL        $CODE
IFE     LENGTH-2,<
EXTERNAL        DFACLO,ARG,ARGLO,VALTYP,TMERR,TEMP2,TEMP3>
COMMENT %
        EXTERNAL LOCATIONS USED BY THE MATH-PACKAGE
        ;THE FLOATING ACCUMULATOR
IFE     LENGTH-2,<
        BLOCK   1               ;[TEMPORARY LEAST SIGNIFICANT BYTE]
DFACLO: BLOCK   4>              ;[FOUR LOWEST ORDERS FOR DOUBLE PRECISION]
FACLO:  BLOCK   3               ;[LOW ORDER OF MANTISSA (LO)]
                                ;[MIDDLE ORDER OF MANTISSA (MO)]
                                ;[HIGH ORDER OF MANTISSA (HO)]
FAC:    BLOCK   2               ;[EXPONENT]
                                ;[TEMPORARY COMPLEMENT OF SIGN IN MSG]
IFE     LENGTH-2,<
ARGLO:  BLOCK   7               ;[LOCATION OF SECOND ARGUMENT FOR DOUBLE
ARG:    BLOCK   1>              ; PRECISION]
FBUFFR: BLOCK   ^D13            ;BUFFER FOR FOUT
IFE     LENGTH-2,<BLOCK ^D<35-13>>
THE FLOATING POINT FORMAT IS AS FOLLOWS:
THE SIGN IS THE FIRST BIT OF THE MANTISSA
THE MANTISSA IS 24 BITS LONG    ;;
THE BINARY POINT IS TO THE LEFT OF THE MSB
NUMBER = MANTISSA * 2 ^ EXPONENT
THE MANTISSA IS POSITIVE, WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS
THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT
THE EXPONENT IS STORED IN EXCESS 200 I.E. WITH A BIAS OF 200
SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT
AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO. THE OTHER BYTES ARE IGNORED
TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING:
        TO SHIFT RIGHT, EXP:=EXP+1
        TO SHIFT LEFT,  EXP:=EXP-1
SO, IN MEMORY THE NUMBER LOOKS LIKE THIS:
        (BITS 17-24 OF THE MANTISSA)
        (BITS 9-16 OF THE MANTISSA)
        (THE SIGN IN BIT 7, BITS 2-8 OF THE MANTISSA ARE IN BITS 6-0)
        (THE EXPONENT AS A SIGNED NUMBER + 200
(REMEMBER THAT BIT 1 OF THE MANTISSA IS ALWAYS A ONE)
ARITHMETIC ROUTINE CALLING CONVENTIONS:
FOR ONE ARGUMENT FUNCTIONS:
        THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
FOR TWO ARGUMENT OPERATIONS:
        THE FIRST ARGUMENT IS IN B,C,D,E I.E. THE "REGISTERS"
        THE SECOND ARGUMENT IS IN THE FAC
        THE RESULT IS LEFT IN THE FAC
THE "S" ENTRY POINTS TO THE TWO ARGUMENT OPERATIONS HAVE (HL) POINTING TO
THE FIRST ARGUMENT INSTEAD OF THE FIRST ARGUMENT BEING IN THE REGISTERS.
MOVRM IS CALLED TO GET THE ARGUMENT IN THE REGISTERS.
THE "T" ENTRY POINTS ASSUME THE FIRST ARGUMENT IS ON THE STACK.
POPR IS USED TO GET THE ARGUMENT IN THE REGISTERS.
NOTE: THE "T" ENTRY POINTS SHOULD ALWAYS BE JUMPED TO AND NEVER CALLED
BECAUSE THE RETURN ADDRESS ON THE STACK WILL BE CONFUSED WITH THE NUMBER.
ON THE STACK, THE TWO LO'S ARE PUSHED ON FIRST AND THEN THE HO AND SIGN.
THIS IS DONE SO IF A NUMBER OF STORED IN MEMORY, IT CAN BE PUSHED ON THE
STACK WITH TWO PUSHM'S.  THE LOWER BYTE OF EACH PART IS IN THE LOWER
MEMORY ADDRESS SO WHEN THE NUMBER IS POPPED INTO THE REGISTERS, THE HIGHER
ORDER BYTE WILL BE IN THE HIGHER ORDER REGISTER OF THE REGISTER PAIR, I.E.
THE HIGHER ORDER BYTE WILL BE POPPED INTO B, D OR H.
%
PAGE
SUBTTL FLOATING POINT ADDITION AND SUBTRACTION
        ;ENTRY TO FADD WITH POINTER TO ARG IN (HL)
FADDH:  LXI     H,FHALF         ;ENTRY TO ADD 1/2
FADDS:  CALL    MOVRM           ;GET ARGUMENT INTO THE REGISTERS
        JMP     FADD            ;DO THE ADDITION
        ;SUBTRACTION    FAC:=ARG-FAC
IFN     EXTFNC,<
FSUBS:  CALL    MOVRM>          ;ENTRY IF POINTER TO ARG IS IN (HL)
IFE     LENGTH-1,<
        XWD     1000,041>       ;"LXI   H" AROUND NEXT 2 BYTES
IFN     LENGTH-2,<
FSUBT:  POPR>                   ;ENTRY IF ARGUMENT IS ON THE STACK
FSUB:   CALL    NEG             ;NEGATE SECOND ARGUMENT
                                ;FALL INTO FADD
        ;ADDITION       FAC:=ARG+FAC
        ;ALTERS A,B,C,D,E,H,L
IFN     LENGTH-2,<
        XWD     1000,041        ;"LXI   H" AROUND NEXT 2 BYTES
FADDT:  POPR>                   ;ENTRY IF ARGUMENT IS ON THE STACK
FADD:   MOV     A,B             ;CHECK IF FIRST ARGUMENT IS ZERO
        ORA     A               ;GET EXPONENT
        RZ                      ;IT IS, RESULT IS NUMBER IN FAC
        LDA     FAC             ;GET EXPONENT
        ORA     A               ;SEE IF THE NUMBER IS ZERO
        JZ      MOVFR           ;IT IS, ANSWER IS IN REGISTERS
;WE WANT TO GET THE SMALLER NUMBER IN THE REGISTERS SO WE CAN SHIFT IT RIGHT
;AND ALIGN THE BINARY POINTS OF THE TWO NUMBERS.  THEN WE CAN JUST ADD OR
;SUBTRACT THEM (DEPENDING ON THEIR SIGNS) BYTEWISE.
        SUB     B               ;CHECK RELATIVE SIZES
        JNC     FADD1           ;IS FAC SMALLER?
        CMA                     ;YES, NEGATE SHIFT COUNT
        INR     A
        XCHG                    ;SWITCH FAC AND REIGSTERS, SAVE (DE)
        CALL    PUSHF           ;PUT FAC ON STACK
        XCHG                    ;GET (DE) BACK WHERE IT BELONDS
        CALL    MOVFR           ;PUT REGISTERS IN THE FAC
        POPR                    ;GET THE OLD FAC IN THE REGISTERS
FADD1:
IFN     LENGTH,<
        CPI     31              ;ARE WE WITHIN 24 BITS?
        RNC>                    ;NO, ALL DONE
        PUSH    PSW             ;SAVE SHIFT COUNT
        CALL    UNPACK          ;UNPACK THE NUMBERS
        MOV     M,A             ;SAVE SUBTRACTION FLAG
        POP     PSW             ;GET SHIFT COUNT BACK
        CALL    SHIFTR          ;SHIFT REGISTERS RIGHT THE RIGHT AMOUNT
;IF THE NUMBERS HAVE THE SAME SIGN, THEN WE ADD THEM.  IF THE SIGNS ARE
;DIFFERENT, THEN WE AHVE TO SUBTRACT THEM.  WE HAVE TO DO THIS BECAUSE THE
;MANTISSAS ARE POSITIVE.  JUDGING BY THE EXPONENTS, THE LARGER NUMBER IS IN
;THE FAC, SO IF WE SUBTRACT, THE SIGN OF THE RESULT SHOULD BE THE SIGN OF THE
;FAC; HOWEVER, IF THE EXPONENTS ARE THE SAME, THE NUMBER IN THE REGISTERS
;COULD BE BIGGER, SO AFTER WE SUBTRACT THEM, WE HAVE TO CHECK IF THE RESULT
;WAS NEGATIVE.  IF IT WAS, WE NEGATE THE NUMBER IN THE REGISTERS AND
;COMPLEMENT THE SIGN OF THE FAC.  (HERE THE FAC IS UNPACKED)
;IF WE HAVE TO ADD THE NUMBERS, THE SIGN OF THE RESULT IS THE SIGN OF THE
;FAC.  SO, IN EITHER CASE, WHEN WE ARE ALL DONE, THE SIGN OF THE RESULT
;WILL BE THE SIGN OF THE FAC.
        ORA     H               ;GET SUBTRACTION FLAG
        LXI     H,FACLO         ;SET POINTER TO LO'S
        JP      FADD3           ;SUBTRACT IF THE SIGNS WERE DIFFERENT
        CALL    FADDA           ;ADD THE NUMBERS
        JNC     ROUND           ;ROUND RESULT IF THERE WAS NO OVERFLOW
                                ;THE MOST IT CAN OVERFLOW IS ONE BIT
        INX     H               ;THERE WAS OVERFLOW
        INR     M               ;INCREMENT EXPONENT
        JZ      OVERR           ;CHECK FOR OVERFLOW
IFE     LENGTH,<
        CALL    SHFTRO>         ;SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
IFN     LENGTH,<
        MVI     L,1             ;SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
        CALL    SHRADD>
        JMP     ROUND           ;ROUND RESULT AND WE ARE DONE
        ;HERE TO SUBTRACT C,D,E,B FROM ((HL)+0,1,2),0
FADD3:  XRA     A               ;SBUBTRACT NUBMERS, NEGATE UNDERFLOW BYTE
        SUB     B
        MOV     B,A             ;SAVE IT
        MOV     A,H             ;SUBTRACT LOW ORDERS
        SBB     E
        MOV     E,A
        INX     H               ;UPDATE POINTER TO NEXT BYTE
        MOV     A,M             ;SUBTRACT MIDDLE ORDERS
        SBB     D
        MOV     D,A
        INX     H               ;UPDATE POINTER TO HIGH ORDERS
        MOV     A,M             ;SUBTRACT HIGH ORDERS
        ABB     C
        MOV     C,A
        ;BECAUSE WE WANT A POSITIVE MANTISSA, CHECK IF WE HAVE TO NEGATE THE
        ; NUMBER
FADFLT: CC      NEGR            ;ENTRY FROM FLOATR, INT: NEGATE NUMBER IF IT
                                ; WAS NEGATIVE, FALL INTO NORMALIZE
        ;NORMALIZE C,D,E,B
        ;ALTERS A,B,C,D,E,M,L
        ;HERE WE SHIFT THE MANTISSA LEFT UNTIL THE MSB IS A ONE.
        ;EXCEPT IN 4K, THE IDEA IS TO SHIFT LEFT BY 8 AS MANY TIMES AS
        ;POSSIBLE.
NORMAL:
IFE     LENGTH,<
        MVI     H,0             ;CLEAR SHIFT COUNT
        MOV     A,C             ;IS THE NUMBER NORMALIZED?
        ORA     A
        JM      ROUND           ;YES, WE ARE DONE
NORM2:  CPI     340             ;IS THE RESULT ZERO?
        JZ      ZERO            ;YES, ZERO THE FAC
        DCR     H               ;NO, DECREMENT SHIFT COUNT
        MOV     A,B             ;SHIFT THE LO LEFT
        ADD     A               ;SHIFT IN A ZERO
        MOV     B,A
        CALL    SHFTLO          ;SHIFT THE REST OF THE NUMBER LEFT ONE
        MOV     A,H             ;GET THE SHIFT COUNT
        JP      NORM2>          ;CONTINUE IF NUMBER IS NOT NORMALIZED
IFN     LENFRG,<
        MOV     L,B             ;PUT LOWEST 2 BYTES IN (HL)
        MOV     H,E
        XRA     A               ;ZERO SHIFT COUNT
NORM1:  MOV     B,A             ;SAVE SHIFT COUNT
        MOV     A,C             ;DO WE HAVE 1 BYTE OF ZEROS
        ORA     A
        JNZ     NORM3           ;NO, SHIFT ONE PLACE AT A TIME
        ;THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
        MOV     C,D             ;YES, SHIFT OVER 1 BYTE
        MOV     D,H
        MOV     H,L
        MOV     L,A             ;SHIFT IN 8 ZEROS FOR THE LOW ORDER
        MOV     A,B             ;UPDATE SHIFT COUNT
        SUI     10
        CPI     340             ;DID WE SHIFT IN 4 BYTES OF ZEROS?
        JNZ     NORM1           ;NO, TRY TO SHIFT OVER 8 MORE
                                ;YES, NUMBER WAS ZERO.  FALL INTO ZERO
        ;ZERO FAC
        ;ALTERS A ONLY
        ;EXITS WITH A=0
        ;BY OUR FLOATING POINT FORMAT, THE NUMBER IS ZERO IF THE EXPONENT IS
        ; ZERO
ZERO:   XRA     A               ;ZERO A
ZERO0:  STA     FAC             ;ZERO THE FAC'S EXPONENT, ENTRY IF A=0
        RET                     ;ALL DONE
NORM2:  DCR     B               ;DECREMENT SHIFT COUNT
        DAD     H               ;ROTATE (HL) LEFT ONE, SHIFT IN A ZERO
        MOV     A,D             ;ROTATE NEXT HIGHER ORDER LEFT ONE
        RAL
        MOV     D,A
        MOV     A,C             ;ROTATE HIGH ORDER LEFT ONE
        ADC     A               ;SET CONDITION CODES
        MOV     C,A
NORM3:  JP      NORM2           ;WE HAVE MORE NORMALIZATION TO DO
        MOV     A,B             ;ALL NORMALIZED, GET SHIFT COUNT
        MOV     E,H             ;PUT LO'S BACK IN E,B
        MOV     B,L
        ORA     A               ;CHECK IF WE DID NO SHIFTING
        JZ      ROUND>
        LXI     H,FAC           LOOK AT FAC'S EXPONENT
        ADD     M               ;UPDATE EXPONENT
        MOV     M,A
        JNC     ZERO            ;CHECK FOR UNDERFLOW
        RZ                      ;NUMBER IS ZERO, ALL DONE
                                ;FALL INTO ROUND AND WE ARE DONE
        ;ROUND RESULT IN C,D,E,B AND PUT NUMBER IN THE FAC
        ;ALTERS A,B,C,D,E,H,L
        ;WE ROUND C,D,E UP OR DOWN DEPENDING UPON THE MSB OF B
ROUND:  MOV     A,B             ;SEE IF WE SHOULD ROUND UP
ROUNDB: LXI     H,FAC           ;ENTRY FROM FDIV, GET POINTER TO EXPONENT
        ORA     A
        CM      ROUNDA          ;DO IT IF NECESSARY
        MOV     B,M             ;PUT EXPONENT IN B
        ;HERE WE PACK THE HO AND SIGN
        INX     H               ;POINT TO SIGN
        MOV     A,M             ;GET SIGN
        ANI     200             ;GET RID OF UNWANTED BITS
        XRA     C               ;PACK SIGN AND HO
        MOV     C,A             ;SAVE IT IN C
        JMP     MOVFR           ;SAVE NUMBER IN FAC
IFE     LENGTH,<
        ;SHIFT C,D,E LEFT ONE
        ;THIS IS USED BY NORMAL, FDIV
        ;ALTERS A,C,D,E
SHFTLO: MOV     A,E             ;GET THE LO
        RAL                     ;SHIFT IT
        MOV     E,A             ;SAVE IT
        MOV     A,D             ;SHIFT THE NEXT HIGHER ORDER
        RAL
        MOV     D,A
        MOV     A,C             ;SHIFT THE HIGHEST ORDER
        ADC     A               ;ROTATE A LEFT AND SET CONDITION CODES
        MOV     C,A
        RET>                    ;ALL DONE
        ;SUBROUTINE FOR ROUND:  ADD ONE TO C,D,E
ROUNDA: INR     E               ;ADD ONE TO THE LOW ORDER, ENTRY FROM QINT
        RNZ                     ;ALL DONE IF IT IS NOT ZERO
        INR     D               ;ADD ONE TO NEXT HIGHER ORDER
        RNZ                     ;ALL DONE IF NO OVERFLOW
        INR     C               ;ADD ONE TO THE HIGHEST ORDER
        RNZ                     ;RETURN IF NO OVERFLOW
        MVI     C,200           ;THE NUMBER OVERFLOWED, SET NEW HIGH ORDER
        INR     M               ;UPDATE EXPONENT
        RNZ                     ;RETURN IF IT DID NOT OVERFLOW
                                ;IT DID, FALL INTO OVERR
        ;OVERFLOW ERROR
OVERR:  MVI     E,ERROV         ;SET OVERFLOW ERROR CODE
        JMP     ERROR           ;GO TO IT!!
        ;ADD (HL)+2,1,0 TO C,D,E
        ;THIS CODE IS USED BY FADD, FOUT
FADDA:  MOV     A,M             ;GET LOWEST ORDER
        ADD     E               ;ADD IN OTHER LOWEST ORDER
        MOV     E,A             ;SAVE IT
        INX     H               ;UPDATE POINTER TO NEXT BYTE
        MOX     A,M             ;ADD MIDDLE ORDERS
        ADC     D
        MOV     D,A
        INX     H               ;UPDATE POINTER TO HIGH ORDER
        MOV     A,M             ;ADD HIGH ORDERS
        ADC     C
        MOV     C,A
        RET                     ;ALL DONE
        ;NEGATE NUMBER IN C,D,E,B
        ;THIS CODE IS USED BY FADD, QINT
        ;ALTERS A,B,C,D,E,L
NEGH:   LXI     H,FAC+1         ;NEGATE FAC
        MOV     A,M             ;GET SIGN
        CMA                     ;COMPLEMENT IT
        MOV     M,A             ;SAVE IT AGAIN
        XRA     A               ;ZERO A
        MOV     L,A             ;SAVE ZERO IN L
        SUB     B               ;NEGATE LOWEST ORDER
        MOV     B,A             ;SAVE IT
        MOV     A,L             ;GET A ZERO
        SBB     E               ;NEGATE NEXT HIGHEST ORDER
        MOV     E,A             LSAVE IT
        MOV     A,L             ;GET A ZERO
        SBB     D               ;NEGATE NEXT HIGHEST ORDER
        MOV     D,A             ;SAVE IT
        MOV     A,L             ;GET ZERO BACK
        SBB     C               ;NEGATE HIGHEST ORDER
        MOV     C,A             ;SAVE IT
        RET                     ;ALL DONE
        ;SHIFT C,D,E RIGHT
        ;A = SHIFT COUNT
        ;ALTERS A,B,C,D,E,L
        ;THE IDEA (EXCEPT IN 4K) IS TO SHIFT RIGHT 8 PLACES
        ; POSSIBLE
SHIFTR: MVI     B,0             ;ZERO OVERFLOW BYTE
IFE     LENGTH,<
        INR     A>              ;ADD ONE TO SHIFT COUNT
IFN     LENGTH,<
SHFTR1: SUI     10              ;CAN WE SHIFT IT 8 RIGHT?
        JC      SHFTR2          ;NO, SHIFT IT ONE PLACE AT A TIME
        ;THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
        MOV     B,E             ;SHIFT NUMBER 1 BYTE RIGHT
        MOV     E,D
        MOV     D,C
        MVI     C,0             ;PUT 0 IN HO
        JMP     SHFTR1          ;TRY TO SHIFT 8 RIGHT AGAIN
SHFTR2: ADI     11>             ;CORRECT SHIFT COUNT
        MOV     L,A             ;SAVE SHIFT COUNT
SHFTR3: XRA     A               ;CLEAR CARRY
        DCR     L               ;ARE WE DONE SHIFTING?
        RZ                      ;RETURN IF WE ARE
IFE     LENGTH,<
SHRADD: CALL    SHFTRD>         ;SHIFT THE NUMBER RIGHT ONE
IFN     LENGTH,<
        MOV     A,C             ;GET HO
SHRADD: RAR                     ;ENTRY FROM FADD, SHIFT IT RIGHT
        MOV     C,A             ;SAVE IT
        MOV     A,D             ;SHIFT NEXT BYTE RIGHT
        RAR
        MOV     D,A
        MOV     A,E             ;SHIFT LOW ORDER RIGHT
        RAR
        MOV     E,A
        MOV     A,B             ;SHIFT OVERFLOW BYTE RIGHT
        RAR
        MOV     B,A>
        JMP     SHFTR3          ;SEE IF WE ARE DONE
IFE     LENGTH,<
        ;SHIFT C,D,E,B RIGHT ONE
        ;THIS IS USED BY SHIFTR, FMULT, FADD
        ;ALTERS A,B,C,D,E
SHFTRO: MOV     A,C             ;GET THE HO
SHFR0A: RAR                     LSHIFT IS RIGHT, ENTRY FROM FMULT
        MOV     C,A
        MOV     A,D             ;SHIFT THE MO RIGHT
        RAR
        MOV     D,A
        MOV     A,E             ;SHIFT THE LO
        RAR
        MOV     E,A
        MOV     A,B             ;SHIFT THE EXTRA LO BYTE
        RAR
        MOV     B,A
        RET>                    ;ALL DONE
PAGE
SUBTTL  NATURAL LOG FUNCTION
IFN     EXTFNC,<
        ;CALCULATION IS BY:
        ; LN(F*2^N)=(N+LOG2(F))*LN(2)
        ;AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F)
        ;CONSTANTS USED BY LOG
FONE:   000     ; 1
        000
        000
        201
LOGCN2: 3       ;DEGREE+1
        252     ; 0.598978650
        126
        031
        200
        361     ; 0.961470632
        042
        166
        200
        105     ; 2.88539129
        252     ; NOTE: THE REFERENCE FOR THIS CONSTANT HAS 100 NOT 105
        070     ; IN THE LOW ORDER BYTE.
        202
LOG:    FSIGN                   ;CHECK FOR A NEGATIVE OR ZERO ARGUMENT
        JPE     FCERR           ;FAC .LE. 0, BLOW HIM OUT OF THE WATER
                                ;FSIGN ONLY RETURNS 0,1 OR 377 IN A
                                ;THE PARITY WILL BE EVEN IF A HAS 0 OR 377
        LXI     H,FAC           ;GET POINTER TO EXPONENT
        MOV     A,H             ;GET EXPONENT IN A
        MOVRI   200,065,004,363 ;GET SQR(.5)
        SUB     B               ;REMOVE EXCESS 200
        PUSH    PSW             ;SAVE EXPONENT FOR LATER
        MOV     M,B             ;SET EXP TO 200, RESULT IS NUM IN (.5,1)
        PUSHR                   ;SAVE SQR(.5)
        CALL    FADD            ;CALCULATE (F-SQR(.0))/(F+SQR(.5))
        POPR                    ;GET SQR(.5) BACK
        INR     B               ;GET SQR(2)
        CALL    FDIV            ;WHERE F=NUMBER LEFT IN FAC
        LXI     H,FONE          ;THE CALCULATION IS EQUIVALENT TO THE ABOVE
        CALL    FSUBS           ; BUT DONE IN A DIFFERENT ORDER
        LXI     H,LOGCN2        ;EVALUATE APPROXIMATION POLYNOMIAL
        CALL    POLYX
        MOVRI   200,200,000,000 ;GET -1/2
        CALL    FADD            ;ADD IN LAST CONSTANT
        POP     PSW             ;RETRIEVE ORIGINAL EXPONENT
        CALL    FINLOG          ;ADD IT TO ORIGINAL NUMBER
MULLN2: MOVRI   200,061,162,030>CMT
;       JMP     FMULT           ;MULTIPLY BY LN(2)
PAGE
SUBTTL  FLOATING MULTIPLICATION AND DIVISION
        ;MULTIPLICATION         FAC:=ARC*FAC
        ;ALTERS A,B,C,D,E,H,L
IFE     EXTFNC,<
FMULTS: CALL    MOVRM>          ;ENTRY WITH POINTER TO ARG IN (HL)
IFN     LENGTH-2,<
        XWD     1000,041        ;"LXI   H" AROUND NEXT 2 BYTES
FMULTI: POPR>                   ;ENTRY IF ARGUMENT IS ON THE STACK
FMULT:  FSIGN                   ;CHECK IF FAC IS ZERO
        RZ                      ;IF IT IS, RESULT IS ZERO
        MVI     L,0             ;ADD THE TWO EXPONENTS, L IS A FLAG
        CALL    MULDIV          ;FIX UP THE EXPONENTS
        ;SAVE THE NUMBER IN THE REGISTERS SO WE CAN ADD IT FAST
        MOV     A,C             ;GET HO
        STA     FMULTA+1        ;STORE HO OF REGISTERS
        XCHG                    ;STORE THE TWO LO'S OF THE REGISTERS
        SHLD    FMULTB+1
        LXI     B,$CODE         ;ZERO THE PRODUCT REGISTERS
        MOV     D,B
        MOV     E,B
        LXI     H,NORMAL        ;PUT ADDRESS OF NORMAL, WHERE WE FINISH UP,
        PUSH    H               ; ON THE STACK
        LXI     H,FMULT2        ;PUT FMULT2 ON THE STACK TWICE, SO AFTER
        PUSH    H               ; WE MULTIPLY BY THE LO BYTE, WE WILL
        PUSH    H               ; MULTIPLY BY THE MO AND HO
        LXI     H,FACLO         ;GET ADDRESS OF LO OF FAC
FMULT2: MOV     A,M             ;GET BYTE TO MULTIPLY BY
        INX     H               ;MOVE POINTER TO NEXT BYTE
IFN     LENGTH,<
        ORA     A
        JZ      FMULT3>         ;ARE WE MULTPLYING BY ZERO?
        PUSH    H               ;SAVE POINTER
IFE     LENGTH,<
        MVI     L,10>           ;SET UP A COUNT
IFN     LENGTH,<
        XCHG                    ;GET LO'S IN (HL)
        MVI     E,10>           ;SET UP A COUNT
;THE PRODUCT WILL BE FORMED IN C,D,E,B. THIS WILL BE IN C,H,L,B PART OF THE
;TIME IN ORDER TO USE THE "DAD" INSTRUCTION.  AT FMULT2, WE GET THE NEXT
;BYTE OF THE MANTISSA IN THE FAC TO MULTIPLY BY.  ((HL) POINTS TO IT)
;(THE FMULT2 SUBROUTINE PRESERVED (HL))  IN 8K, IF THE BYTE IS ZERO, WE JUST
;SHIFT THE PRODUCT 8 RIGHT.  THIS BYTE IS THEN SHIFTED RIGHT AND SAVED IN D
;(H IN 4K).  THE CARRY DETERMINES IF WE SHOULD ADD IN THE SECOND FACTOR
;IF WE DO, WE ADD IT TO C,H,L.  B IS ONLY USED TO DETERMINE WHICH WAY WE
;ROUND.  WE THEN SHIFT C,H,L,B (C,D,E,B) IN 4K RIGHT ONE TO GET READY FOR THE
;NEXT TIME THROUGH THE LOOP.  NOTE THAT THE CARRY IS SHIFTED INTO THE MSB OF
;C.  E HAS A COUNT (L IN 4K) TO DETERMINE WHEN WE HAVE LOOKED AT ALL THE BITS
;OF D (H IN 4K).
FMULT4: RAR                     ;ROTATE BYTE RIGHT
IFE     LENGTH,<
        MOV     H,A>            ;SAVE THE COUNT
IFN     LENGTH,<
        MOV     D,A>            ;SAVE IT
        MOV     A,C             ;GET HO
        JNC     FMULTS          ;DON'T ADD IN NUMBER IF BIT WAS ZERO
IFE     LENGTH,<
        XCHG>                   ;PUT THE LO'S IN (HL)
        PUSH    D               ;SAVE COUNTERS
FMULTB: LXI     D,$CODE         ;GET LO'S OF NUMBER TO ADD, THIS IS SET ABOVE
        DAD     D               ;ADD THEM IN
        POP     D               ;GET COUNTERS BACK
FMULTA: ACI     0               ;ADD IN HO, THIS IS SET UP ABOVE
IFE     LENGTH,<
        XCHG                    ;PUT THE LO'S BACK IN (DE)
FMULT5: CALL    SHFROA          ;SHIFT THE RESULT RIGHT ONE
        DCR     L               ;ARE WE DONE?
        MOV     A,H>            ;GET NUMBER WE ARE MULTIPLYING BY
IFN     LENGTH,<
FMULT5: RAR                     ;ROTATE RESULT RIGHT ONE
        MOV     C,A
        MOV     A,H             ;ROTATE NEXT BYTE
        RAR
        MOV     H,A
        MOV     A,L             ;ROTATE NEXT LOWER ORDER
        RAR
        MOV     L,A
        MOV     A,B             ;ROTATE LO
        RAR
        MOV     B,A
        DCR     E               ;ARE WE DONE?
        MOV     A,D>            ;GET NUMBER WE ARE MULTIPLYING BY
        JNZ     FMULT4          ;MULTIPLY AGAIN IF WE ARE NOT DONE
IFN     LENGTH,<
        XHG>                    ;GET LO'S IN (HL)
POPHRT: POP     H               ;GET POINTER TO NUMBER TO MULTIPLY BY
        RET                     ;ALL DONE
IFN     LENGTH,<
FMULT3: MOV     B,E             ;MULTIPLY BY ZERO: SHIFT EVERYTHING 8 RIGHT
        MOV     E,D
        MOV     D,C
        MOV     C,A             ;SHIFT IN 8 ZEROS ON THE LEFT
        RET>                    ;ALL DONE
        ;DIVIDE FAC BY 10
        ;ALTERS A,B,C,D,E,H,L
DIV10:  CALL    PUSHF           ;SAVE NUMBER
IFN     LENGTH-2,<
        MOVRI   204,040,000,000 ;LOAD CONSTANT '10' INTO REGISTERS
        CALL    MOVFR>          ;MOVE THE CONSTANT TO THE FAC
IFE     LENGTH-2,<
        LXI     H,FTEN          ;GET POINTER TO THE CONSTANT '10'
        CALL    MOVFM>          ;MOVE TEN INTO THE FAC
FDIVT:  POPR                    ;GET NUMBER BACK IN REGISTERS
                                ;FALL INTO DIVIDE AND WE ARE DONE
        ;DIVISION       FAC:=ARG/FAC
        ;ALTERS A,B,C,D,E,H,L
FDIV:   FSIGN                   ;CHECK FOR DIVISION BY ZERO
        JZ      DV0ERR          ;HE IS TRYING TO GET AWAY WITH IT
        MVI     L,377           ;SUBTRACT THE TWO EXPONENTS, L IS A FLAG
        CALL    MULDIV          ;FIX UP THE EXPONENTS AND THINGS
        INR     M               ;ADD 2 TO EXPONENT TO CORRECT SCALING
        INR     M
        ;HERE WE SAVE THE FAC IN MEMORY SO WE CAN SUBTRACT IT FROM THE NUMBER
        ;IN THE REGISTERS QUICKLY.
        DCX     H               ;POINT TO HO
        MOV     A,M             ;GET HO
        STA     FDIVA+1         ;SAVE IT
        DCX     H               ;SAVE MIDDLE ORDER
        MOV     A,M
        STA     FDIVB+1         ;PUT IT WHERE NOTHING WILL HURT IT
        DCX     H               ;SAVE LO
        MOV     A,M
        STA     FDIVC+1
;THE NUMERATOR WILL BE KEPT IN B,H,L.  THE QUOTIENT WILL BE FORMED IN C,D,E.
;TO GET A BIT OF THE QUOTIENT, WE FIRST SAVE B,H,L ON THE STACK, THEN
;SUBTRACT THE DENOMINATOR THAT WE SAVED IN MEMORY.  THE CARRY INDICATES
;WHETHER OR NOT B,H,L WAS BIGGER THAN THE DENOMINATOR.  IF B,H,L WAS BIGGER,
;THE NEXT BIT OF THE QUOTIENT IS A ONE.  TO GET THE OLD B,H,L OFF THE STACK,
;WE POP THEM INTO THE PSW.  IF THE DENOMINATOR WAS BIGGER, THE NEXT BIT OF
;THE QUOTIENT IS ZERO, AND WE GET THE OLD B,H,L BACK BY POPPING IT OFF THE
;STACK.  WE HAVE TO KEEP AN EXTRA BIT OF THE QUOTIENT IN FDIVG+1 IN CASE THE
;DENOMINATOR WAS BIGGER,  THEN B,H,L WILL GET SHIFTED LEFT.  IF THE MSB  OF
;B WAS ONE, IT HAS TO BE STORED SOMEWHERE, SO WE STORE IT IN FDIVG+1.  THEN
;THE NEXT TIME THROUGH THE LOOP B,H,L WILL LOOK BIGGER BECAUSE IT HAS AN
;EXTRA HO BIT IN FDIVG+1. WE ARE DONE DIVIDING WHEN THE MSB OF C IS A ONE.
;THIS OCCURS WHEN WE HAVE CALCULATED 24 BITS OF THE QUOTIENT.  WHEN WE JUMP
;TO ROUND, THE 25TH BIT OF THE QUOTIENT DETERMINES WHETHER WE ROUND OR NOT.
;IT IS IN THE MSB OF A.  IF INITIALLY THE DENOMINATOR IS BIGGER THAN THE
;NUMERATOR, THE FIRST BIT OF THE QUOTIENT WILL BE ZERO.  THIS MEANS WE
;WILL GO THROUGH THE DIVIDE LOOP 26 TIMES, SINCE IT STOPS ON THE 25TH BIT
;AFTER THE FIRST NON-ZERO BIT OF THE EXPONENT.  SO, THIS QUOTIENT WILL LOOK
;SHIFTED LEFT ONE FROM THE QUOTIENT OF TWO NUMBERS IN WHICH THE NUMERATOR IS
;BIGGER.  THIS CAN ONLY OCCUR ON THE FIRST TIME THROUGH THE LOOP, SO C,D,E
;ARE ALL ZERO.  SO, IF WE FINISH THE LOOP AND C,D,E ARE ALL ZERO, THEN WE
;MUST DECREMENT THE EXPONENT TO CORRECT FOR THIS.
        MOV     B,C             ;GET NUMBER IN B,H,L
        XCHG
        XRA     A               ;ZERO C,D,E AND HIGHEST ORDER
        MOV     C,A
        MOV     D,A
        MOV     E,A
        STA     FDIVG+1
FDIV1:  PUSH    H               ;SAVE LO'S OF NUMBER
        PUSH    B               ;SAVE HO OF NUMBER
        MOV     A,L             ;SUBTRACT NUMBER THAT WAS IN FAC
FDIVC:  SUI     0               ;SUBTRACT LO
        MOV     L,A             ;SAVE IT
        MOV     A,H             ;SUBTRACT MIDDLE ORDER
FDIVB:  SBI     0
        MOV     H,A
        MOV     A,B             ;SUBTRACT HO
FDIVA:  SBI     0
        MOV     B,A
FDIVG:  MVI     A,0             ;GET HIGHEST ORDER
        SBI     0               ;SUBTRACT THE CARRY FROM IT
        CMC                     ;SET CARRY TO CORESPOND TO NEXT QUOTIENT BIT
        JNC     FDIV2           ;GET OLD NUMBER BACK IF WE SUBTRACTED TOO MUCH
        STA     FDIVG+1         ;UDPATE HIGHEST ORDER
        POP     PSW             ;THE SUBTRACTION WAS GOOD
        POP     PSW             ;GET PREVIOUS NUMBER OFF STACK
        STC                     ;NEXT BIT IN QUOTIENT IS A ONE
        XWD     1000,322        ;"JNC" AROUND NEXT 2 BYTES
FDIV2:  POP     B               ;WE SUBTRACTED TOO MUCH
        POP     H               ;GET OLD NUMBER BACK
        MOV     A,C             ;ARE WE DONE?
        INR     A               ;SET SIGN FLAG WITHOUT AFFECTING CARRY
        DCR     A
        RAR                     ;PUT CARRY IN MSB
        JM      ROUNDB          ;WE ARE DONE
        RAL                     ;WE AREN'T, GET OLD CARRY BACK
IFE     LENGTH,<
        CALL    SHFTLD>         ;ROTATE EVERYTHING LEFT ONE
IFN     LENGTH,<
        MOV     A,E             ;ROTATE EVERYTHING LEFT ONE
        RAL                     ;ROTATE NEXT BIT OF QUOTIENT IN
        MOV     E,A
        MOV     A,D
        RAL
        MOV     D,A
        MOV     A,C
        RAL
        MOV     C,A>
        DAD     H               ;ROTATE A ZERO INTO RIGHT END OF NUMBER
        MOV     A,B             ;THE HO BYTE, FINALLY!
        RAL
        MOV     B,A
        LDA     FDIVG+1         ;ROTATE THE HIGHEST ORDER
        RAL
        STA     FDIVG+1
        MOV     A,C             ;ADD ONE TO EXPONENT IF THE FIRST SUBTRACTION
        ORA     D               ; DID NOT WORK
        ORA     E
        JNZ     FDIV1           ;THIS ISN'T THE CASE
        PUSH    H               ;SAVE PART OF NUMBER
        LXI     H,FAC           ;GET POINTER TO FAC
        OCR     M               ;DECREMENT EXPONENT
        POP     H               ;GET NUMBER BACK
        JNZ     FDIV1           ;DIVIDE MORE IF NO OVERFLOW OCCURED
        JMP     OVERR           ;OVERFLOW!!
        ;CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV
        ;ALTERS A,B,H,L
IFE     LENGTH-2,<
MULDVS: A       377             ;ENTRY FROM DDIV, SUBTRACT EXPONENTS
        XWD     1000,056        ;"MVI   L" AROUND NEXT BYTE
MULDVA: XRA     A               ;ENTRY FROM DMULT, ADD EXPONENTS
        LXI     H,ARG-1         ;GET POINTER TO SIGN AND HO OF ARG
        MOV     C,M             ;GET HO AND SIGN FOR UNPACKING
        INX     H               ;INCREMENT POINTER TO EXPONENT
        MOV     B,M             ;GET EXPONENT FOR BELOW
        MOV     L,A>            ;SAVE ADD OR SUBTRACT FLAG
MULDIV: MOV     A,B             ;IS NUMBER IN REGISTERS ZERO?
        ORA     A
        JZ      MULDV2          ;IT IS, ZERO FAC AND WE ARE DONE
        MOV     A,L             ;GET ADD OR SUBTRACT FLAG
        LXI     H,FAC           ;GET POINTER TO EXPONENT
        XRA     M               ;GET EXPONENT
        ADD     B               ;ADD IN REGISTER EXPONENT
        MOV     B,A             ;SAVE IT
        RAR                     ;CHECK FOR OVERFLOW
        XRA     B               ;OVERFLOW IF SIGN IS THE SAME AS CARRY
        MOV     A,B             ;GET SUM
        JP      MULDV1          ;WE HAVE OVERFLOW!!
        ADI     200             ;PUT EXPONENT IN EXCESS 200
        MOV     M,A             ;SAVE IT IN THE FAC
        JZ      POPHRT          ;WE HAVE UNDERFLOW!! RETURN.
        CALL    UNPACK          ;UNPACK THE ARGUMENTS
        MOV     M,A             ;SAVE THE NEW SIGN
        DCX     H               ;POINT TO EXPONENT
        RET                     ;ALL DONE, ELAVE HO IN A
IFN     EXTFNC,<
MLDVEX: FSIGN                   ;ENTRY FROM EXP, PICK UNDERFLOW IF NEGATIVE
        CMA                     ;PICK OVERFLOW IF POSITIVE
        POP     H>              ;DON'T SCREW UP STACK
MULDV1: ORA     A               ;IS ERROR OVERFLOW OR UNDERFLOW?
MULDV2: POP     H               ;GET OLD RETURN ADDRESS OFF STACK
IFE     LENGTH,<
        JM      OVERR           ;OVERFLOW
                                ;UNDERFLOW -- FALL INTO ZERO


        ;ZERO FAC
        ;ALTERS A ONLY
        ;EXITS WITH A=0
ZERO:   XRA     A               ;ZERO A
        STA     FAC             ;ZERO FAC
        RET>                    ;ALL DONE
IFN     LENGTH,<
        JP      ZERO            ;UNDERFLOW
        JMP     OVERR>          ;OVERFLOW
        ;MULTIPLY FAC BY 10
        ;ALTERS A,B,C,D,E,H,L
MUL10:  CALL    MOVRF           ;GET NUMBER IN REGISTERS
        MOV     A,B             ;GET EXPONENT
        ORA     A               ;RESULT IS ZERO IF ARG IS ZERO
        RZ                      ;IT IS
        ADI     2               ;MULTIPLY BY 4 BY ADDING 2 TO EXPONENT
        JC      OVERR           ;OVERFLOW!!
        MOV     B,A             ;RESTORE EXPONENT
        CALL    FADD            ;ADD IN ORIGINAL NUMBER TO GET 5 TIMES IT
        LCI     H,FAC           ;ADD 1 TO EXPONENT TO MULTIPLY NUMBER BY
        INR     M               ; 2 TO GET 10 TIMES ORIGINAL NUMBER
        RNZ                     ;ALL DONE IF NO OVERFLOW
        JMP     OVERR           ;OVERFLOW
PAGE
SUBTTL  SIGN, SGN, FLOAT, NEG AND ABS
        ;PUT SIGN OF FAC IN A
        ;ALTERS A ONLY
        ;LEAVES FAC ALONE
        ;NOTE: TO TAKE ADVANTAGE OF THE RST INSTRUCTIONS TO SAVE BYTES,
        ;FSIGN IS DEFINED TO BE AN RST.  "FSIGN" IS EQUIVALENT TO "CALL SIGN"
        ;THE FIRST FEW INSTRUCTIONS OF SIGN (THE ONES BEFORE SIGNC) ARE DONE
        ;IN THE 8 BYTES AT THE RST LOCATION.
REPEAT  0,<                     ;FSIGN IS ALWAYS AN RST
SIGN:   LDA     FAC             ;CHECK IF THE NUMBER IS ZERO
        ORA     A
        RZ>                     ;IT IS, A IS ZERO
SIGNC:  LDA     FAC-1           ;GET SIGN OF FAC, IT IS NON-ZERO
        XWD     1000,376        ;"CPI" AROUND NEXT BYTE
FCOMPS: CMA                     ;ENTRY FROM FCOMP, COMPLEMENT SIGN
ICOMPS: RAL                     ;ENTRY FROM ICOMP, PUT SIGN BIT IN CARRY
SIGNS:  SBB     A               ;A=0 IF CARRY WAS 0, A=377 IF CARRY WAS 1
        RNZ                     ;RETURN IF NUMBER WAS NEGATIVE
INRART: INR     A               ;PUT ONE IN A IF NUMBER WAS POSITIVE
        RET                     ;ALL DONE
        ;SGN FUNCTION
        ;ALTERS A,B,C,D,E,H,L
IFN     LENGTH-2,<
SGN:    FSIGN>                  ;GET SIGN OF FAC IN A
                                ;FALL INTO FLOAT
        ;FLOAT THE SIGNED INTEGER IN A
        ;ALTERS A,B,C,D,E,H,L
FLOAT:  MVI     0,210           ;SET EXPONENT CORRECTLY
        LXI     D,$CODE         ;ZERO D,E
                                ;FALL INTO FLOATR
        ;FLOAT THE SIGNED NUMBER IN B,A,D,E
        ;ALTERS A,B,C,D,E,H,L
FLOATR: LXI     H,FAC           ;GET POINTER TO FAC
        MOV     C,A             ;PUT HO IN C
        MOV     M,B             ;PUT EXPONENT IN THE FAC
        MVI     B,0             ;ZERO OVERFLOW BYTE
        INX     H               ;POINT TO SIGN
        MVI     M,200           ;ASSUME A POSITIVE NUMBER
        RAL                     ;PUT SIGN IN CARRY
        JMP     FADFLT          ;GO AND FLOAT THE NUMBER
        ;ABSOLUTE VALUE OF FAC
        ;ALTERS A,H,L
ABS:
IFE     LENGTH-2,<
        CPI     2               ;IS THE ARGUMENT AN INTEGER?
        JZ      IABS>           ;YES, USE THE INTEGER ABSOLUTE VALUE
        FSIGN                   ;GET THE SIGN OF FAC
        RP                      ;ALL DONE IF IT IS POSITIVE
                                ;FALL INTO NEG
        ;NEGATE NUMBER IN THE FAC
        ;ALTERS A,H,L
        ;NOTE: THE NUMBER MUST BE PACKED
NEG:    LXI     H,FAC-1         ;GET POINTER TO SIGN
        MOV     A,M             ;GET SIGN
        XRI     200             ;COMPLEMENT SIGN BIT
        MOV     M,A             ;SAVE IT
        RET                     ;ALL DONE
IFE     LENGTH-2,<
        ;NEGATE ANY TYPE VALUE IN THE FAC
        ;ALTERS A,B,C,D,E,H,L
VNEG:   LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
        CPI     2
        JZ      INEG            ;WE HAVE AN INTEGER, NEGATE IT THAT WAY
        JM      TMERR           ;SLOW UP ON STRINGS
        JMP     NEG             ;NEGATE SNG AND DBL THE SAME


        ;SGN FUNCTION
        ;ALTERS A,H,L
SGN:    CALL    VSIGN           ;GET THE SIGN OF THE FAC IN A
        MOV     L,A             ;PUT IT IN THE LO POSITION
        RAL                     ;EXTEND THE SIGN TO THE HO
        SBB     A
        MOV     H,A
        JMP     CONISS          ;RETURN THE RESULT AND SET VALTYP


        ;GET THE SIGN OF THE VALUE IN THE FAC IN A
        ;ASSUMES A HAS THE VALTYP WHEN CALLED
        ;ALTERS A,H,L
VSIGN:  CPI     2               ;IS THE ARGUMENT AN INTEGER?
        JNZ     SIGN            ;NO, SINGLE AND DOUBLE PREC. WORK THE SAME
        LHLD    FACLO           ;GET THE INTEGER ARGUMENT
        MOV     A,H             ;GET ITS SIGN
        ORA     L               ;CHECK IF THE NUMBER IS ZERO
        RZ                      ;IT IS, WE ARE DONE
        MOV     A,H             ;IT ISN'T SIGN IS THE SIGN OF H
        JMP     ICOMPS>         ;GO SET A CORRECTLY
PAGE
SUBTTL  FLOATING POINT MOVEMENT ROUTINES
        ;PUT FAC ON STACK
        ;ALTERS D,E
PUSHF:  XCHG                    ;SAVE (HL)
        LHLD    FACLO           ;GET LO'S
        XTHL                    ;SWITCH LO'S AND RET ADDR
        PUSH    H               ;PUT RET ADDR BACK ON STACK
        LHLD    FAC-1           ;GET HO'S
        XTHL                    ;SWITCH HO'S AND RET ADDR
        PUSH    H               ;PUT RET ADDR BACK ON STACK
        XCHG                    ;GET OLD (HL) BACK
        RET                     ;ALL DONE
        ;MOVE NUMBER FROM MEMORY [(HL)] TO FAC
        ;ALTERS B,C,D,E,H,L
        ;AT EXIT NUMBER IS IN B,C,D,E
        ;AT EXIT (HL):=(HL)+4
MOVFM:  CALL    MOVRM           ;GET NUMBER IN REGISTERS
                                ;FALL INTO MOVFR AND PUT IT IN FAC
        ;MOVE REGISTERS (B,C,D,E) TO FAC
        ;ALTERS D,E
MOVFR:  XCHG                    ;GET LO'S IN (HL)
        CHLD    FACLO           ;PUT THEM WHERE THEY BELONG
        MOV     H,B             ;GET HO'S IN (HL)
        MOV     L,C
        SHLD    FAC-1           ;PUT HO'S WHERE THEY BELONG
        XCHG                    ;GET OLD (HL) BACK
        RET                     ;ALL DONE
        ;MOVE FAC TO REGISTERS (B,C,D,E)
        ;ALTERS B,C,D,E,H,L
MOVRF:  LXI     H,FACLO         ;GET POINTER TO FAC
                                ;FALL INTO MOVRM
        ;GET NUMBER IN REGISTERS (B,C,D,E) FROM MEMORY [(HL)]
        ;ALTERS B,C,D,E,H,L
        ;AT EXIT (HL):=(HL)+4
MOVRM:  MOV     E,M             ;GET LO
        INX     H               ;POINT TO MO
        MOV     D,M             ;GET MO
        INX     H               ;POINT TO HO
        MOV     C,M             ;GET HO
        INX     H               ;POINT TO EXPONENT
        MOV     B,M             ;GET EXPONENT
INXHRT: INX     H               ;INC POINTER TO BEGINNING OF NEXT NUMBER
        RET                     ;ALL DONE
        ;MOVE NUMBER FROM FAC TO MEMORY[(HL)]
        ;ALTERS A,B,D,E,H,L
MOVMF:  LXI     D,FACLO         ;GET POINTER TO FAC
                                ;FALL INTO MOVE
        ;MOVE NUMBER FROM (DE) TO (HL)
        ;ALTERS A,B,D,E,H,L
        ;EXITS WITH (DE):=(DE)+4
MOVE:   MVI     B,4             ;SET COUNTER
IFE     LENGTH-2,<
        XWD     1000,076        ;"MVI   A" OVER NEXT BYTE
MOVVFM: XCHG>                   ;MOVE NUMBERS INTO THE FAC
MOVE1:  LDAX    D               ;GET WORD ENTRY FROM VMOVMF
        MOV     M,A             ;PUT IT WHERE IT BELONGS
        INX     D               ;INCREMENT POINTERS TO NEXT WORD
        INX     H
        DCR     B               ;SEE IF DONE
        JNZ     MOVE1
        RET
        ;UNPACK THE FAC AND THE REGISTERS
        ;ALTERS A,C,H,L
        ;WHEN THE NUMBER IN THE FAC IS UNACKED, THE ASSUMED ONE IN THE
        ;MANTISSA IS RESTORED, AND THE COMPLEMENT OF THE SIGN IS PLACED
        ;IN FAC+1
UNPACK: LXI     H,FAC-1         ;POINT TO HO AND SIGN
        MOV     A,H             ;GET HO AND SIGN
        PUSH    PSW             ;SAVE SIGN
        ORA     200             ;RESTORE THE HIDDEN ONE
        MOV     M,A             ;SAVE HO
        POP     PSW             ;GET SIGN
        XRA     M               ;GET COMPLEMENT OF SIGN IN MSB
        INX     H               ;POINT TO TEMPORARY SIGN BYTE
        INX     H
        MOV     M,A             ;SAVE COMPLEMENT OF SIGN
        MOV     A,C             ;GET HO AND SIGN OF THE REGISTERS
        PUSH    PSW             ;SAVE SIGN
        ORI     200             ;RESTORE THE HIDDEN ONE
        MOV     C,A             ;SAVE THE HO
        POP     PSW             ;GET THE SIGN BACK
        XRA     M               ;COMPARE SIGN OF FAC AND SIGN OF REGISTERS
        RET                     ;ALL DONE
IFE     LENGTH-2,<
REPEAT  0,<                     ;VPUSHF WILL BE IN-LINE IN F3
        ;PUT ANY TIME VALUE ON THE STACK FROM FAC
        ;STRINGS ARE TREATED AS INTEGERS
        ;ALTERS A,B,C,H,L
VPUSHF: LDA     VALTYP          ;GET THE VALUE TYPE
        CPI     4               ;SET FLAGS ACCORDING TO VALTYP
        LXI     H,FACLO         ;GET POINTER TO LO IN FAC
        PUSHM                   ;PUSH FACLO+0,1 ON THE STACK
        JM      VPUSHD          ;RETURN IF THE DATA WAS AN INTEGER OR A STRING
        PUSHM                   ;PUSH FAC-1,0 ON THE STACK
        JZ      VPUSHD          ;RETURN IF WE HAD A SINGLE PRECISION NUMBER
        LXI     D,DFACLO        ;WE HAVE A DOUBLE PRECISON NUMBER
        PUSHM                   ;PUSH ITS 4 LO BYTES ON THE STACK
        PUSHM
VPUSHD:>                        ;ALL DONE


        ;MOVE ANY TYPE VALUE FROM MEMORY [(HL)] TO FAC
        ;ALTERS A,B,D,E,H,L
VMOVFA: LXI     H,ARGLO         ;ENTER FROM DADD, MOVE ARG TO FAC
VMOVFM: LXI     D,MOVVFM        ;GET ADDRESS OF LOCATION THAT DOES
        JMP     VMVVFM          ; AN "XCHG" AND FALLS INTO MOVE1:


        ;MOVE ANY TYPE VALUE FROM FAC TO MEMORY [(HL)]
        ;ALTERS A,B,D,E,H,L
VMOVAF: LXI     H,ARGLO         ;ENTRY FROM FIN, DMUL10, DDIV10
                                ;MOVE FAC TO ARG
VMOVMF: LXI     D,MOVE1         ;GET ADDRESS OF MOVE SUBROUTINE
VMVVFM: PUSH    D               ;SHOVE IT ON THE STACK
        LXI     D,FACLO         ;GET FIRST ADDRESS FROM INT, SNG
        LDA     VALTYP          ;GET THE VALUE TYPE
        ANI     177             ;STRINGS LOOK LIKE REALS
        MOV     B,A             ;SET UP THECOUNT
        CPI     10              ;DO WE HAVE DBL?
        RNZ                     ;WE DO NOT, GO DO THE MOVE
        LXI     D,DFACLO        ;WE DO, GET LO ADDR OF THE DBL DUMBER
        RET>                    ;GO DO THE MOVE
PAGE
SUBTTL  COMPARE TWO NUMBERS
        ;COMPARE TWO SINGLE PRECISION NUMBERS
        ;A=1 IF ARG .LT. FAC
        ;A=0 IF ARG=FAC
        ;A=-1 IF ARG .GT. FAC
        ;DOREL DEPENDS UPON THE FACT THAT FCOMP RETURNS
        ; IFF A HAS 377
        ;ALTERS A,H,L
FCOMP:  MOV     A,B             ;CHECK IF ARG IS ZERO
        ORA     A
        JZ      SIGN
        LXI     H,FCOMPS        ;WE JUMP TO FCOMPS WHEN WE ARE DONE
        PUSH    H               ;PUT THE ADDRESS ON THE STACK
        FSIGN                   ;CHECK IF FAC IS ZERO
        MOV     A,C             ;IF IT IS, RESULT IS MINUS THE SIGN OF ARG
        RZ                      ;IT IS
        LXI     H,FAC-1         ;POINT TO SIGN OF FAC
        XRA     M               ;SEE IF THE SIGNS ARE THE SAME
        MOV     A,C             ;IF THEY ARE DIFFERENT, RESULT IS SIGN OF ARG
        RM                      ;THEY ARE DIFFERENT
        CALL    FCOMP2          ;CHECK THE REST OF THE NUMBER
FCOMPD: RAR                     ;NUMBERS ARE DIFFERENT, CHANGE SIGN IF
        XRA     C               ; BOTH NUMBERS ARE NEGATIVE
        RET                     ;GO SET UP A
FCOMP2: INX     H               ;POINT TO EXPONENT
        MOV     A,B             ;GET EXPONENT OF ARG
        CMP     M               ;COMPARE THE TWO
        RNZ                     ;NUMBERS ARE DIFFERENT
        DCX     H               ;POINT TO HO
        MOV     A,C             ;GET HO OF ARG
        CMP     M               ;COMPARE WITH HO OF FAC
        RNZ                     ;THEY ARE DIFFERENT
        DCX     H               ;POINT TO MO OF FAC
        MOV     A,D             ;GET MO OF ARG
        CMP     M               ;COMPARE WITH MO OF FAC
        RNZ                     ;THE NUMBERS ARE DIFFERENT
        DCX     H               ;POINT TO LO OF FAC
        MOV     A,E             ;GET LO OF ARG
        SUB     M               ;SUBTRACT LO OF ARG
        RNZ                     ;NUMBERS ARE DIFFERENT
        POP     H               ;NUMBERS ARE THE SAME, DON'T SCREW UP STACK
        POP     H
        RET                     ;ALL DONE

IFE     LENGTH-2,<
        ;COMPARE TWO INTEGERS
        ;A=1 IF (DE) .LT. (HL)
        ;A=0 IF (DE)=(HL)
        ;A=-1 IF (DE) .GT. (HL)
        ;ALTERS A ONLY
ICOMP:  MOV     A,D             ;ARE THE SIGNS THE SAME
        XRA     H
        MOV     A,H             ;IF NOT, ANSWER IS THE SIGN OF (HL)
        JM      ICOMPS          ;THEY ARE DIFFERENT
        CMP     D               ;THEY ARE THE SAME, COMPARE THE HO'S
        JNZ     SIGNS           ;GO SET UP A
        MOV     A,L             ;COMPARE THE LO'S
        SUB     E
        JNZ     SIGNS           ;GO SET UP A
        RET                     ;ALL DONE, THEY ARE THE SAME


        ;COMPARE TWO DOUBLE PRECISION NUMBERS
        ;A=1 IF ARG .LT. FAC
        ;A=0 IF ARG=FAC
        ;A=-1 IF ARG .GT. FAC
        ;ALTERS A,B,C,D,E,H,L
DCOMPD: LXI     H,ARGLO         ;ENTRY WITH POINTER TO ARG IN (DE)
        MVI     B,10            ;SET UP COUNT TO MOVE DBL NUMBERS
        CALL    MOVE1           ;MOVE THE ARGUMENT INTO ARG
DCOMP:  LXI     D,ARG           ;GET POINTER TO ARG
        LDAX    D               ;SEE IF ARG=0
        ORA     A
        JZ      SIGN            ;ARG=0, GO SET UP A
        LXI     H,FCOMPS        ;PUSH FCOMPS ON STACK SO WE WILL RETURN TO
        PUSH    H               ; TO IT AND SET UP A
        FSIGN                   ;SEE IF FAC=0
        DCX     D               ;POINT TO SIGN OF ARG
        LDAX    D               ;GET SIGN OF ARG
        MOV     C,A             ;SAVE IT FOR LATER
        RZ                      ;FAC=0, SIGN OF RESULT IS SIGN OF ARG
        LXI     H,FAC-1         ;POINT TO SIGN OF FAC
        XRA     M               ;SEE IF THE SIGNS ARE THE SAME
        MOV     A,C             ;IF THEY ARE, GET THE SIGN OF THE NUMBERS
        RM                      ;THE SIGNS ARE DIFFERENT, GO SET A
        INX     D               ;POINT BACK TO EXPONENT OF ARG
        INX     H               ;POINT TO EXPONENT OF FAC
        MVI     B,10            ;SET UP A COUNT
DCOMP1: LDAX    D               ;GET A BYTE FROM ARG
        SUB     M               ;COMPARE IT WITH THE FAC
        JNZ     FCOMPD          ;THEY ARE DIFFERENT, GO SET UP A
        DCX     D               ;THEY ARE THE SAME, EXAMINE THE NEXT LOWER
        DCX     H               ; ORDER BYTES
        DCR     B               ;ARE WE DONE?
        JNZ     DCOMP1          ;NO, COMPARE THE NEXT BYTES
        POP     B               ;THEY ARE THE SAME, GET FCOMPS OFF STACK
        RET>                    ;ALL DONE
PAGE
SUBTTL  CONVERSION ROUTINES BETWEEN INTEGER, SINGLE AND DOUBLE PRECISION
IFE     LENGTH-2,<
        ;FORCE THE FAC TO BE AN INTEGER
        ;ALTERS A,B,C,D,E,H,L
FRCINT: LDA     VALTYP          ;SEE WHAT WE HAVE
        CPI     4
        LHLD    FACLO           ;GET FACLO+0,1 IN CASE WE HAVE AN INTEGER
        RC                      ;WE HAVE AN INTEGER, ALL DONE
        JM      TMERR           ;WE HAVE A STRING, THAT IS A "NO-NO"
        CNZ     CONSD           ;IF WE HAVE A DBL, CONVERT IT TO A SNG
        LXI     H,OVERR         ;PUT OVERR ON THE STACK SO WE WILL GET ERROR
        PUSH    H               ; IF NUMBER IS TOO BIG
                                ;FALL INTO CONIS


        ;CONVERT SINGLE PRECISION NUMBER TO INTEGER
        ;ALTRS A,B,C,D,E,H,K
CONIS:  LDA     FAC             ;GET THE EXPONENT
        CPI     220             ;SEE IF IT IS TOO BIG
        JNC     CONIS2          ;IT IS, BUT IT MIGHT BE -32768
        CALL    QINT            ;IT ISN'T, CONVERT IT TO AN INTEGER
        XCHG                    ;PUT IT IN (HL)
CONIS1: POP     D               ;GET ERROR ADDRESS OFF STACK
        ;ENTRY FROM SGN, FIN, LINPRT
CONISS: SHLD    FACLO           ;STORE THE NUMBER IN FACLO
        MVI     A,2             ;SET VALTYP TO "INTEGER"
CONISD: STA     VALTYP          ;ENTRY FROM CONDS
        RET                     ;ALL DONE
CONIS2: MOVRI   220,200,000,000 ;CHECK IF NUMBER IS -32768, ENTRY FROM FIN
        CALL    FCOMP
        RNZ                     ;ERROR:  IT CAN'T BE CONVERTED TO AN INTEGER
        MOV     H,C             ;IT IS -32768, PUT IT IN (HL)
        MOV     L,D
        JMP     CONIS1          ;STORE IT IN THE FAC AND SET VALTYP


        ;FORCE THE FAC TO BE A SINGLE PRECISION NUMBER
        ;ALTERS A,B,C,D,E,H,L
FRCSNG: LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
        CPI     4
        RZ                      ;WE ALREADY HAVE AN INTEGER, ALL DONE
        JC      CONSI           ;WE HAVE AN INTEGER, CONVERT IT
        JM      TMERR           ;STRINGS!! -- ERROR!!
                                ;DBL PREC -- FALL INTO CONSD


        ;CONVERT DOUBLE PRECISION NUMBER TO A SINGLE PRECISION ONE
        ;ALTERS A,B,C,D,E,H,L
CONSD:  CALL    MOVRF           ;GET THE HO'S IN THE REGISTERS
        MVI     A,4             ;SET VALTYP TO "SINGLE PRECISION"
        STA     VALTYP
        MOV     A,B             ;CHECK IF THE NUMBER IS ZERO
        ORA     A
        RZ                      ;IF IT IS, WE ARE DONE
        CALL    UNPACK          ;UNPACK THE NUMBER
        LXI     H,FACLO-1       ;GET FIRST BYTE BELOW A SNG NUMBER
        MOV     B,M             ;PUT IT IN B FOR ROUND
        JMP     ROUND           ;ROUND THE DBL NUMBER UP AND WE ARE DONE


        ;CONVERT AN INTEGER TO A SINGLE PRECISION NUMBER
        ;ALTERS A,B,C,D,E,H,L
CONSI:  LHLD    FACLO           ;GET THE INTEGER
CONSIH: MVI     A,4             ;SET VALTYP TO "SINGLE PRECISION"
        STA     VALTYP
        MOV     A,H             ;SET UP REGISTERS FOR FLOATR
        MOV     D,L
        MVI     E,0
        MVI     B,220
        JMP     FLOATR          ;GO FLOAT THE NUMBER


        ;FORCE THE FAC TO BE A DOUBLE PRECISION NUMBER
        ;ALTERS A,B,C,D,E,H,L
FRCDBL: LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
        CPI     10
        RZ                      ;WE ALREADY HAVE A DBL, WE ARE DONE
        JNC     TMERR           ;GIVE AN ERROR IF WE HAVE A STRING
        CPI     2               ;SEE IF WE HAVE A SNG OR INT
        CZ      CONSI           ;CONVERT TO SNG IF WE HAVE AN INT
                                ;FALL INTO CONDS AND CONVERT TO DBL


        ;CONVERT A SINGLE PRECISION NUMBER TO A DOUBLE PRECISION ONE
        ;ALTERS A,H,L
CONDS:  LXI     H,$CODE         ;ZERO H,L
        SHLD    DFACLO          ;CLEAR THE FOUR LOWER BYTES IN THE DOUBLE
        SHLD    DFACLO+2        ; PRECISION NUMBER
        MVI     A,10            ;SET VALTYP TO "DOUBLE PRECISION"
        JMP     CONISD          ;GO FOR IT
PAGE
SUBTTL  GREATEST INTEGER FUNCTION
        ;QUICK GREATEST INTEGER FUNCTION
        ;LEAVES INT(FAC) IN C,D,E (SIGNED)
        ;ASSUMES FAC .LT. 2^23 = 8388608
        ;ASSUMES THE EXPONENT OF FAC IS IN A
        ;ALTERS A,B,C,D,E
QINT:   MOV     B,A             ;ZERO B,C,D,E IN CASE THE NUMBER IS ZERO
        MOV     C,A
        MOV     D,A
        MOV     E,A
        ORA     A               ;SET CONDITION CODES
        RZ                      ;IT IS ZERO, WE ARE DONE
;THE HARD CASE IN QINT IS NEGATIVE NON-INTEGERS.  TO HANDLE THIS, IF THE
;NUMBER IS NEGATIVE, WE REGARD THE 3-BYTE MANTISSA AS A 3-BYTE INTEGER AND
;SUBTRACT ONE.  THEN ALL THE FRACTIONAL BITS ARE SHIFTED OUT BY SHIFTING THE
;MANTISSA RIGHT.  THEN, IF THE NUMBER WAS NEGATIVE, WE ADD ONE.  SO, IF WE
;HAD A NEGATIVE INTEGER, ALL THE BITS TO THE RIGHT OF THE BINARY POINT WERE
;ZERO.  SO THE NET EFFECT IS WE HAVE THE ORIGINAL NUMBER IN C,D,E.  IF THE
;NUMBER WAS A NEGATIVE NON-INTEGER, THERE IS AT LEAST ONE NON-ZERO BIT TO THE
;RIGHT OF THE BINARY POINT.  SO THE NET EFFECT IS THAT WE GET THE ABSOLUTE
;VALUE OF INT(FAC) IN C,D,E/  C,D,E IS THEN NEGATED IF THE ORIGINAL NUMBER WAS
;NEGATIVE SO THE RESULT WILL BE SIGNED.
        PUSH    H               ;SAVE (HL)
        CALL    MOVRF           ;GET NUMBER IN THE REGISTERS
        CALL    UNPACK          ;UNPACK THE NUMBER
        XRA     M               ;GET SIGN OF NUMBER
        MOV     H,A             ;DON'T LOSE IT
        CM      QINTA           ;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
        MVI     A,230           ;SEE HOW MANY WE HAVE TO SHIFT TO CHANGE
        SUB     B               ; NUMBER TO AN INTEGER
        CALL    SHIFTR          ;SHIFT NUMBER TO GET RID OF FRACTIONAL BITS
        MOV     A,H             ;GET SIGN
        RAL                     ;PUT SIGN IN CARRY SO IT WILL NOT BE CHANGED
        CC      ROUNDA          ;IF NUMBER WAS NEGATIVE, ADD ONE
        MVI     B,0             ;FORGET THE BITS WE SHIFTED OUT
        CC      NEGR            ;NEGATE NUMBER IF IT WAS NEGATIVE BECAUSE WE
                                ; WANT A SIGNED MANTISSA
        POP     H               ;GET OLD (HL) BACK
        RET                     ;ALL DONE
QINTA:  DCX     D               ;SUBTRACT ONE FROM C,D,E
        MOV     A,D             ;WE HAVE TO SUBTRACT ONE FROM C IF
        ANA     E               ; D AND E ARE BOTH ALL ONES
        INR     A               ;SEE IF BOTH WERE -1
        RNZ                     ;THEY WERE NOT, WE ARE DONE
IFN     LENGTH-2,<
        DCR     C>              ;THEY WERE, SUBTRACT ONE FROM C
IFE     LENGTH-2,<
DCXBRT: DCX     B>              ;THIS IS FOR BILL.  C WILL NEVER BE ZERO
                                ; (THE MSB WILL ALWAYS BE ONE) SO "DCX  B"
                                ; AND "DCR      A" ARE FUNCTIONALLY EQUIVALENT
        RET                     ;ALL DONE
        ;GREATEST INTEGER FUNCTION
        ;ALTERS A,B,C,D,E,H,L
IFE     LENGTH-2,<
INTFNC: CPI     4               ;SEE WHAT KIND OF NUMBER WE AHVE
        RC                      ;IT IS AN INTEGER, ALL DONE
        JNZ     DINT            ;CONVERT THE DOUBLE PRECISION NUMBER
        CALL    CONIS>          ;TRY TO CONVERT THE NUMBER TO AN INTEGER
                                ;IF WE CAN'T, WE WILL RETURN HERE TO GIVE A
                                ; SINGLE PRECISION RESULT
INT:    LXI     H,FAC           ;GET EXPONENT
        MOV     A,M
        CPI     230             ;SEE IF NUMBER HAS ANY FRACTIONAL BITS
IFN     EXTFNC,<                ;THE ONLY GUY WHO NEEDS THIS DOESN'T CARE
        LDA     FACLO>          ; ABOUT THE SIGN
        RNC                     ;IT DOES NOT
IFN     EXTFNC,<
        MOV     A,M>            ;GET EXPONENT BACK
        CALL    QINT            ;IT DOES, SHIFT THEM OUT
        MVI     M,230           ;CHANGE EXPONENT SO IT WILL BE CORRECT
                                ; AFTER NORMALIZATION
IFN     EXTFNC,<
        MOV     A,E             ;GET LO
        PUSH    PSW>            ;SAVE IT
        MOV     A,C             ;NEGATE NUMBER IF IT IS NEGATIVE
        RAL                     ;PUT SIGN IN CARRY
IFE     EXTFNC,<
        JMP     FADFLT>         ;REFLOAT NUMBER
IFN     EXTFNC,<
        CALL    FADFLT          ;REFLOAT NUMBER
POPPRT: POP     PSW             ;GET LO BACK
        RET>                    ;ALL DONE
IFE     LENGTH-2,<
        ;GREATEST INTEGER FUNCTION FOR DOUBLE PRECISION NUMBERS
        ;ALTERS A,B,C,D,E,H,L
DINT:   LXI     H,FAC           ;GET POINTER TO FAC
        MOV     A,M             ;GET EXPONENT
        CPI     220             ;CAN WE CONVERT IT TO AN INTEGER?
        JC      FRCINT          ;THEN DO SO
        JNZ     DINT2           ;CHECK FOR -32768
        MOV     C,A             ;SAVE EXPONENT IN C
        DCX     H               ;GET POINTER TO SIGN AND HO
        MOV     A,M             ;GET SIGN AND HO
        XRI     200             ;CHECK IF IT IS 200
        MVI     B,6             ;SET UP A COUNT TO CHECK IF THE REST OF
DINT1:  DCX     H               ; THE NUMBER IS ZERO, POINT TO NEXT BYTE
        ORA     M               ;IF ANY BITS ARE NON-ZERO, A WILL BE NON-ZERO
        DCR     B               ;ARE WE DONE?
        JNZ     DINT1           ;NO, CHECK THE NEXT LOWER ORDER BYTE
        ORA     A               ;IS A NOW ZERO?
        LXI     H,200*400+$CODE ;GET -32768 JUST IN CASE
        JZ      CONISS          ;A IS ZERO SO WE AHVE -32768
        MOV     A,C             ;GET EXPONENT
DINT2:  CPI     270             ;ARE THERE ANY FRACTIONAL BITS?
        RNC                     ;NO, THE NUMBER IS ALREADY AN INTEGER
DINTFO: PUSH    PSW             ;ENTRY FROM FOUR, CARRY IS ZERO IF WE COME
                                ; HERE FROM FOUT
        CALL    MOVRF           ;GET HO'S OF NUMBER IN REGISTERS FOR UNPACKING
        CALL    UNPACK          ;UNPACK IT
        XRA     M               ;GET ITS SIGN BACK
        DCX     H               ;SET THE EXPONENT TO NORMALIZE CORRECTLY
        MVI     M,270
        PUSH    PSW             ;SAVE THE SIGN
        CM      DINTA           ;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
        MVI     A,270           ;GET HOW MANY VITS WE HAVE TO SHIFT OUT
        SUB     B
        CALL    DSHFTR          ;SHIFT THEM OUT!!
        POP     PSW             ;GET THE SIGN BACK
        CM      DROUNA          ;IF NUMBER WAS NEGATIVE, ADD ONE
        XRA     A               ;PUT A ZERO IN THE EXTRA LO BYTE SO WHEN
        STA     DFACLO-1        ; WE NORMALIZE, WE WILL SHIFT IN ZEROS
        POP     PSW             ;IF WE WERE CALLED FROM FOUT, DON'T NORMALIZE
        RNC                     ; JUST RETURN
        JMP     DNORML          ;RE-FLOAT THE INTEGER

DINTA:  LXI     H,DFACLO        ;SUBTRACT ONE FROM FAC, GET POINTER TO LO
DINTA1: MOV     A,M             ;GET A BYTE OF FAC
        DCR     M               ;SUBTRACT ONE FROM IT
        ORA     A               ;CONTINUE ONLY IF THE BYTE USED TO BE ZERO
        INX     H               ;INCREMENT POINTER TO NEXT BYTE
        JZ      DINTA1          ;CONTINUE IF NECESSARY
        RET>                    ;ALL DONE
PAGE
SUBTTL  INTEGER ARITHMETIC ROUTINES
IFN     MULDIM&<LENGTH-2>,<
        ;TWO BYTE UNSIGNED INTEGER MULTIPLY
        ; (HL):=(BC)*(DE)
        ;A,D,E,H,L ARE CHANGED
DMULT:  LXI     H,$CODE         ;ZERO PRODUCT REGISTERS
        MOV     A,B             ;CHECK IF (BC) IS ZERO
        ORA     C               ;IF SO, JUST RETURN, (HL) IS ALREADY ZERO
        RZ                      ;THIS IS DONE FOR SPEED
        MVI     A,20            ;SET UP A COUNT
DMULT1: DAD     H               ;ROTATE (HL) LEFT ONE
        JC      BSERR##         ;CHECK FOR OVERFLOW, IF SO,
        XCHG                    ; BAD SUBSCRIPT (BS) ERROR
        DAD     H               ;ROTATE (DE) LEFT ONE
        XCHG
        JNC     DMULT2          ;ADD IN (BC) IF HO WAS 1
        DAD     B
        JC      BSERR           ;CHECK FOR OVERFLOW
DMULT2: DCR     A               ;SEE IF DONE
        JNZ     DMULT1
        RET>                    ;ALL DONE
IFE     LENGTH-2,<
COMMENT %
        INTEGER ARITHMETIC CONVENTIONS

INTEGER VARIABLES ARE 2 BYTE, SIGNED NUMBERS
        THE LOW BYTE COMES FIRST IN MEMORY

CALLING CONVENTIONS:
FOR ONE ARUGMENT FUNCTIONS:
        THE ARGUMENT IS IN (HL), THE RESULT IS LEFT IN (HL)
FOR TWO ARGUMENT OPERATIONS:    ;;
        THE FIRST ARGUMENT IS IN (DE)
        THE SECOND ARGUMENT IS IN (HL)
        THE RESULT IS LEFT IN (HL)
IF OVERFLOW OCCURS, THE ARGUMENTS ARE CONVERTED TO SINGLE PRECISION
WHEN INTEGERS ARE STORED IN THE FAC, THEY ARE STORED AT FACLO+0,1
VALTYP(INTEGER)=2
%


        ;INTEGER SUBTRACTION    (HL):=(DE)-(HL)
        ;ALTERS A,B,C,D,E,H,L
ISUB:   MOV     A,H             ;EXTEND THE SIGN OF (HL) TO B
        RAL                     ;GET SIGN IN CARRY
        SBB     A
        MOV     B,A
        CALL    INEGHL          ;NEGATE (HL)
        MOV     A,C             ;GET A ZERO
        SBB     B               ;NEGATE SIGN
        JMP     IADDS           ;GO ADD THE NUMBERS


        LINTEGER ADDITION       (HL):=(DE)+(HL)
        ;ALTERS A,B,C,D,E,H,L
IADD:   MOV     A,H             ;EXTEND THE SIGN OF (HL) TO B
        RAL                     ;GET SIGN IN CARRY
        SBB     A
IADDS:  MOV     B,A             ;SAVE THE SIGN
        PUSH    H               ;SAVE THE SECOND ARGUMENT IN CASE OF OVERFLOW
        MOV     A,D             ;EXTEND THE SIGN OF (DE) TO A
        RAL                     ;GET SIGN IN CARRY
        SBB     A
        DAD     D               ;ADD THE TWO LO'S
        ADC     B               ;ADD THE EXTRA HO
        RRC                     ;IF THE LSB OF A IS DIFFERENT FROM THE MSB OF
        XRA     H               ; H, THEN OVERFLOW OCCURRED
        JP      POPPRT          ;NO OVERFLOW, GET OLD (HL) OFF STACK AND WE
                                ; ARE DONE
        PUSH    B               ;OVERFLOW -- SAVE EXTENDED SIGN OF (HL)
        XCHG                    ;GET (DE) IN (HL)
        CALL    CONSIH          ;FLOAT IT
        POP     PSW             ;GET SIGN OF (HL) IN A
        POP     H               ;GET OLD (HL) BACK
        CALL    PUSHF           ;PUT FIRST ARGUMENT ON STACK
        XCHG                    ;PUT SECOND ARGUMENT IN (DE) FOR FLOATR;
        CALL    INEGAD          ;FLOAT IT
        POPR                    ;GET FIRST ARGUMENT OFF STACK
        JMP     FADD            ;ADD THE TWO NUMBERS USING SINGLE PRECISION


        ;INTEGER MULTIPLICATION         (HL):=(DE)*(HL)
        ;ALTERS A,B,C,D,E,H,L
IMULT:  PUSH    H               ;SAVE SECOND ARGUMENT IN CASE OF OVERFLOW
        PUSH    D               ;SAVE FIRST ARGUMENT
        CALL    IMULDV          ;FIX UP THE SIGNS
        PUSH    B               ;SAVE THE SIGN OF THE RESULT
        MOV     B,H             ;COPY SECOND ARGUMENT INTO (BC)
        MOV     C,L
        LXI     H,$CODE         ;ZERO (HL), THAT IS WHERE THE PRODUCT GOES
        MVI     A,20            ;SET UP A COUNT
IMULT1: DAD     H               ;ROTATE PRODUCT LEFT ONE
        JC      IMULTS          ;CHECK FOR OVERFLOW
        XCHG                    ;ROTATE FIRST ARGUMENT LEFT ONE TO SEE IF
        DAD     H               ; WE ADD IN (BC) OR NOT
        XCHG
        JNC     IMULT2          ;DON'T ADD IN ANYTHING
        DAD     B               ;ADD IN (BC)
        JC      IMULT5          ;CHECK FOR OVERFLOW
IMULT2: DCR     A               ;ARE WE DONE?
        JNZ     IMULT1          ;NO, DO IT AGAIN
        POP     B               ;WE ARE DONE, GET SIGN OF RESULT
        POP     D               ;GET ORIGINAL FIRST ARGUMENT
IMLDIV: MOV     A,H             ;ENTRY FROM IDIV, IS RESULT .GE. 32768?
        ORA     A
        JM      IMULT3          ;IT IS, CHECK FOR SPECIAL CASE OF -32768
        POP     D               ;RESULT IS OK, GET SECOND ARGUMENT OFF STACK
        MOV     A,B             ;GET THE SIGN OF RESULT IN A
        JMP     INEGA           ;NEGATE THE RESULT IF NECESSARY
IMULT3: XRA     200             ;IS RESULT 32768?
        ORA     L               ;NOTE: IF WE GET HERE FROM IDIV, THE RESULT
        JZ      IMULT4          ; MUST BE 32768, IT CANNOT BE GREATER
        XCHG                    ;IT IS .GT. 32768, WE HAVE OVERFLOW
        XWD     1000,001        ;"LXI   B" OVER NEXT 2 BYTES
IMULT5: POP     B               ;GET SIGN OF RESULT OFF STACK
        POP     H               ;GET THE ORIGINAL FIRST ARGUMENT
        CALL    CONSIH          ;FLOAT IT
        POP     H               ;GET THE ORIGINAL SECOND ARGUMENT
        CALL    PUSHF           ;SAVE FLOATED FIRST ARUMENT
        CALL    CONSIH          ;FLOAT SECOND ARGUMENT
FMULTT: POPR                    ;GET FIRST ARGUMENT OFF STACK, ENTRY FROM POLYX
        JMP     FMULT           ;MULTIPLY THE ARGUMENTS USING SINGLE PRECISION
IMULT4: MOV     A,B             ;IS RESUKT +32768 OR -32768?
        ORA     A               ;GET ITS SIGN
        POP     B               ;DISCARD ORIGINAL SECOND ARGUMENT
        RM                      ;THE RESULT SHOULD BE NEGATIVE, IT IS OK
        PUSH    D               ;IT IS POSITIVE, SAVE REMAINDER FOR MOD
        CALL    CONSIH          ;FLOAT -32768
        POP     D               ;GET MOD'S REMAINDER BACK
        JMP     NEG             ;NEGATE -32768 TO GET 32768, WE ARE DONE


        ;INTEGER DIVISION       (HL):=(DE)/(HL)
        ;REMAINDER IS IN (DE), QUOTIENT IN (HL)
        ;ALTERS A,B,C,D,E,H,L
IDIV:   MOV     A,H             ;CHECK FOR DIVISION BY ZERO
        ORA     L
        JZ      DV0ERR          ;WE HAVE DIVISION BY ZERO!!
        CALL    IMULDV          ;FIX UP THE SIGNS
        PUSH    B               ;SAVE THE SIGN OF THE RESULT
        XCHG                    ;GET DENOMINATOR IN (HL)
        CALL    INEGHL          ;NEGATE IT
        MOV     B,H             ;SAVE NEGATED DENOMINATOR IN (BC)
        MOV     C,L
        LXI     H,$CODE         ;ZERO WHERE WE DO THE SUBTRACTION
        MVI     A,21            ;SET UP A COUNT
        PUSH    PSW             ;SAVE IT
        ORA     A               ;CLEAR CARRY
        JMP     IDIV3           ;GO DIVIDE
IDIV1:  PUSH    PSW             ;SAVE COUNT
        PUSH    H               ;SAVE (HL) I.E. CURRENT NUMERATOR
        DAD     B               ;SUBTRACT DENOMINATOR
        JNC     IDIV2           ;WE SUBTRACTED TOO MUCH, GET OLD (HL) BACK
        POP     PSW             ;THE SUBTRACTION WAS GOOD, DISCARD OLD (HL)
        STC                     ;NEXT BIT IN QUOTIENT IS A ONE
        XWD     1000,076        ;"MVI   A" OVER NEXT BYTE
IDIV2:  POP     H               ;IGNORE THE SUBTRACTION, WE COULDN'T DO IT
IDIV3:  MOV     A,E             ;SHIFT IN THE NEXT QUOTIENT BIT
        RAL
        MOV     E,A
        MOV     A,D             ;SHIFT THE HO
        RAL
        MOV     D,A
        MOV     A,L             ;SHIFT IN THE NEXT BIT OF THE NUMERATOR
        RAL
        MOV     L,A
        MOV     A,H             ;DO THE HO
        RAL
        MOV     H,A             ;SAVE THE HO
        POP     PSW             ;GET COUNT BACK
        DCR     A               ;ARE WE DONE?
        JNZ     IDIV1           ;NO, DIVIDE AGAIN
        XCHG                    ;GET QUOTIENT IN (HL), REMAINDER IN (DE)
        POP     B               ;GET SIGN OF RESULT
        PUSH    D               ;SAVE REMAINDER SO STACK WILL BE ALRIGHT
        JMP     IMLDIV          ;CHECK FOR SPECIAL CASE OF 32768


        ;GET READY TO MULTIPLY OR DIVIDE
        ;ALTERS A,B,C,D,E,H,L
IMULDV: MOV     A,H             ;GET SIGN OF RESULT
        XRA     D
        MOV     B,A             ;SAVE IT IN B
        CALL    INEGH           ;NEGATE SECOND ARGUMENT IF NECESSARY
        XCHG                    ;PUT (DE) IN (HL), FALL IN AND NEGATE FIRST
                                ; ARGUMENT IF NECESSARY


        ;NEGATE H,L
        ;ALTERS A,C,H,L
INEGH:  MOV     A,H             ;GET SIGN OF (HL)
INEGA:  ORA     A               ;SET CONDITION CODES
        RP                      ;WE DON'T HAVE TO NEGATE, IT IS POSITIVE
INEGHL: XRA     A               ;CLEAR A
        MOV     C,A             ;STORE A ZERO (WE USE THIS METHOD FOR ISUB)
        SUB     L               ;NEGATE LO
        MOV     L,A             ;SAVE IT
        MOV     A,C             ;GET A ZERO BACK
        DBB     H               ;NEGATE HO
        MOV     H,A             ;SAVE IT
        RET                     ;ALL DONE


        ;INTEGER ABSOLUTE VALUE
        ;ALTERS A,B,C,D,E,H,L
IABS:   LDA     FACLO+1         ;GET SIGN OF INTEGER IN FAC
        ORA     A               ;CHECK ITS SIGN
        RP                      ;IT IS POSITIVE, LEAVE IT ALONE
                                ;FALL INTO INEG AND NEGATE IT


        ;INTEGER NEGATION
        ;ALTERS A,B,C,D,E,H,L
INEG:   LHLD    FACLO           ;GET THE INTEGER
        CALL    INEGHL          ;NEGATE IT
        SHLD    FACLO           ;STORE IT BACK IN THE FAC
        XRI     200             ;CHECK FOR SPECIAL CASE OF 32768
        ORA     L
        RNZ                     ;IT DID NOT OCCUR, EVERYTHING IS FINE
        XCHG                    ;WE HAVE IT, FLOAT 32768
        MVI     A,4             ;CHANGE VALTYP TO "SINGLE PRECISION"
        STA     VALTYP
INEGAD: MVI     B,230           ;ENTRY FROM IADD, SET EXPONENT
        JMP     FLOATR          ;GO FLOAT THE NUMBER


        ;MOD OPERATOR
        ;(HL):=(DE)-(DE)/(HL)*(HL),  (DE)=QUOTIENT
        ;ALTERS A,B,C,D,E,H,L
MOD:    PUSH    D               ;SAVE (DE) FOR ITS SIGN
        CALL    IDIV            ;DIVIDE AND GET THE REMAINDER
        XCHG                    ;PUT REMAINDER IN (DE)
        MVI     A,2             ;SET VALTYP TO "INTEGER" IN CASE RESULT OF
        STA     VALTYP          ; THE DIVISION WAS 32768
        POP     PSW             ;GET THE SIGN OF (DE) BACK
        JNP     INEGA>          ;NEGATE THE REMAINDER IF NECESSARY
PAGE
SUBTTL  DOUBLE PRECISION ARITHMETIC ROUTINES
IFE     LENGTH-2,<
COMMENT %
        DOUBLE PRECISION ARITHMETIC CONVENTIONS

DOUBLE PRECISION NUMBERS ARE 8 BYTE QUANTITIES
THE LAST 4 BYTES IN MEMORY ARE IN THE SAME FORMAT AS SINGLE PRECISION NUMBERS
THE FIRST 4 BYTES ARE 32 MORE LOW ORDER BITS OF PRECISION
THE LOWEST ORDER BYTE COMES FIRST IN MEMORY

CALLING CONVENTIONS:
FOR ONE ARUGMENT FUNCTIONS:
        THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
FOR TWO ARGUMENT OPERATIONS:
        THE FIRST ARGUMENT IS IN ARG=7,6,5,4,3,2,1,0  (NOTE: ARGLO=ARG-7)
        THE SECOND ARGUMENT IS IN THE FAC
        THE RESULT IS LEFT IN THE FAC
VALTYP(DOUBLE PRECISION)=10 OCTAL
%


        ;DOUBLE PRECISION SUBTRACTION   FAC:=ARG-FAC
        ;ALTERS ALL REGISTERS
DSUB:   CALL    NEG             ;NEGATE THE SECOND ARGUMENT
                                ;FALL INTO DADD


        ;DOUBLE PRECISION ADDITION      FAC:=ARG+FAC
        ;ALTERS ALL REGISTERS
DADD:   LXI     H,ARG           ;GET  POINTER TO EXPONENT OF FIRST ARGUMENT
        MOV     A,H             ;CHECK IF IT IS ZERO
        ORA     A
        RZ                      ;IT IS, RESULT IS ALREADY IN FAC
        MOV     B,A             ;SAVE EXPONENT FOR UNPACKING
        DCX     H               ;POINT TO HO AND SIGN
        MOV     C,M             ;GET HO AND SIGN FOR UNPACKING
        LXI     D,FAC           ;GET POINTER TO EXPONENT OF SECOND ARGUMENT
        LDAX    D               ;GET EXPONENT
        ORA     A               ;SEE IF IT IS ZERO
        JZ      VMOVFA          ;IT IS, MOVE ARG TO FAC AND WE ARE DONE
        SUB     B               ;SUBTRACT EXPONENTS TO GET SHIFT COUNT
        JNC     DADD2           ;PUT THE SMALLER NUMBER IN FAC
        CMA                     ;NEGATE SHIFT COUNT
        INR     A
        PUSH    PSW             ;SAVE SHIFT COUNT
        PUSH    B               ;SAVE HO TO UNPACK LATER
        MVI     C,10            ;SWITCH FAC AND ARG, SET UP A COUNT
        INX     H               ;POINT TO ARG
DADD1:  LDAX    D               ;GET A BYTE OF THE FAC
        MOV     B,M             ;GET A BYTE OF THE ARG
        MOV     M,A             ;PUT THE FAC BYTE IN ARG
        MOV     A,B             ;PUT THE ARG BYTE IN A
        STAX    D               ;PUT THE ARG BYTE IN FAC
        DCX     D               ;POINT TO THE NEXT LO BYTE OF FAC
        DCX     H               ;POINT TO THE NEXT LO BYTE OF ARG
        DCR     C               ;ARE WE DONE?
        JNZ     DADD1           ;NO, DO THE NEXT LO BYTE
        POP     B               ;GET THE HO BACK
        POP     PSW             ;GET THE SHIFT COUNT BACK
DADD2:  CPI     71              ;ARE WE WITHIN 56 BITS?
        RNC                     ;NO, ALL DONE
        PUSH    PSW             ;SAVE SHIFT COUNT
        CALL    UNPACK          ;UNPACK THE NUMBERS
        MOV     A,B             ;SAVE SUBTRACTION FLAG
        MOV     A,C             ;SAVE THE UNPACKED HO
        STA     ARG-1
        POP     PSW             ;GET SHIFT COUNT
        CALL    DSHFTR          ;SHIFT FAC RIGHT THE RIGHT NUMBER OF TIMES
        ORA     B               ;GET SUBTRACTION FLAG, HERE A=0
        JP      DADD3           ;SUBTRACT NUMBERS IF THEIR SIGNS ARE DIFFERENT
        CALL    DADDAA          ;SIGNS ARE THE SAME, ADD THE NUMBERS
        JNC     DROUND          ;ROUND THE RESULT IF NO CARRY
        INR     M               ;WE HAVE OVERLOW, ADD ONE TO THE EXPONENT
        JZ      OVERR           ;CHECK FOR OVERFLOW
        MVI     D,1             ;SHIFT NUMBER RIGHT ONE, SHIFT IN CARRY
        CALL    DSHFRA
        JMP     DROUND          ;ROUND THE RESULT
DADD3:  XWD     1000,076        ;"MVI   A", SUBTRACT THE NUMBER
        SBB     M               ;GET THE SUBTRACT INSTRUCTION IN A
        CALL    DADDA           ;SUBTRACT THE NUMBERS
        INX     H               ;POINT TO THE UNPACKED SIGN
        MOV     A,M             ;COMPLEMENT IT, SINCE THE FAC WAS SMALLER
        CMA
        MOV     M,A
        CC      DNEGR           ;NEGATE THE RESULT IF IT WAS NEATIVE
                                ;FALL INTO DNORML


        ;NORMALIZE FAC
        ;ALTERS A,B,C,D,H,L
DNORML: XRA     A               ;CLEAR SHIFT COUNT
DNORM1: MOV     B,A             ;SAVE SHIFT COUNT
        LDA     FAC-1           ;GET HO
        ORA     A               ;SEE IF WE CAN SHIFT 8 LEFT
        JNZ     DNORM5          ;WE CAN'T, SEE IF NUMBER IS NORMALIZED
        LXI     H,DFACLO-1      ;WE CAN, GET POINTER TO LO
        MVI     C,10            ;SET UP A COUNT
DNORM2: MOV     D,M             ;GET A BYTE OF FAC
        MOV     M,A             ;PUT IN BYTE FROM LAST LOCATION, THE FIRST
                                ; TIME THROUGH A IS ZERO
        MOV     A,D             ;PUT THE CURRENT BYTE IN A FOR NEXT TIME
        INX     H               ;INCREMENT POINTER TO NEXT HIGHER ORDER
        DCR     C               ;ARE WE DONE?
        JNZ     DNORM2          ;NO, DO THE NEXT BYTE
        MOV     A,B             ;SUBTRACT 0 FROM SHIFT COUNT
        SUI     10
        CPI     300             ;HAVE WE SHIFTED ALL BYTES TO ZERO?
        JNZ     DNORM1          ;NO, TRY TO SHIFT 8 MORE
        JMP     ZERO            ;YES, THE NUMBER IS ZERO
DNORM3: DCR     B               ;DECREMENT SHIFT COUNT
        LXI     H,DFACLO-1      ;GET POINTER TO LO
        CALL    DSMFLC          ;SHIFT THE FAC LEFT
        ORA     A               ;SEE IF NUMBER IS NORMALIZED
DNORM5: JP      DNORM3          ;SHIFT FAC LEFT ONE IF IT IS NOT NORMALIZED
        MOV     A,B             ;GET THE SHIFT COUNT
        ORA     A               ;SEE IF NO SHIFTING WAS DONE
        JZ      DROUND          ;NONE WAS, PROCEED TO ROUND THE NUMBER
        LXI     H,FAC           ;GET POINTER TO EXPONENT
        ADD     M               ;UPDATE IT
        MOV     M,A             ;SAVE UPDATED EXPONENT
        JNC     ZERO            ;UNDERFLOW, THE RESULT IS ZERO
        RZ                      ;RESULT IS ALREADY ZERO, WE ARE DONE
                                ;FALL INTO DROUND AND ROUND THE RESULT


        ;ROUND FAC2
        ;ALTERS A,B,H,L
DROUND: LDA     DFACLO-1        ;GET EXTRA BYTE TO SEE IF WE HAVE TO ROUND
DROUNB: ORA     A               ;ENTRY FROM DDIV
        CM      DROUNA          ;ROUND UP IF NECESSARY
        LXI     H,FAC+1         ;GET PONTER TO UNPACKED SIGN
        MOV     A,M             ;GET SIGN
        ANI     200             ;ISOLATE SIGN BIT
        DCX     H               ;POINT TO HO
        DCX     H
        XRA     M               ;PACK SIGN AND HO
        MOV     M,A             ;PUT PACKED SIGN AND HO IN FAC
        RET                     ;WE ARE DONE


        ;SUBROUTINE FOR ROUND: ADD ONE TO FAC
DROUNA: LXI     H,DFACLO        ;GET POINTER TO LO, ENTRY FROM DINT
        MXI     B,7             ;SET UP A COUNT
DRONA1: INR     M               ;INCREMENT A BYTE
        RNZ                     ;RETURN IF THERE WAS NO CARRY
        INX     H               ;INCREMENT POINTER TO NEXT HIGHER ORDER
        DCR     B               ;HAVE WE INCREMENT ALL BYTES
        JNZ     DRONA1          ;NO, TRY THE NEXT ONE
        INR     H               ;YES, INCREMENT THE EXPONENT
        JZ      OVERR           ;CHECK FOR OVERFLOW
        DCX     H               ;THE NUMBER OVERFLOWED ITS EXPONENT
        MVI     M,200           ;PUT 200 IN HO
        RET                     ;ALL DONE


        ;ADD OR SUBTRACT 2 DBL QUANTITIES
        ;ALTERS A,C,D,E,H,L
DADDD:  LXI     H,FBUFFR+^D17   ;ENTRY FROM DDIV
        LXI     D,ARGLO         ;ADD OR SUBTRACT FBUFFR+17 AND ARG
        JMP     DADDS           ;DO THE OPERATION

DADDAA: XWD     1000,076        ;"MVI   A", ENTRY FROM DADD, DMULT
        ADC     M               ;SETUP ADD INSTRUCTION FOR LOOP
DADDA:  LXI     H,ARGLO         ;GET POINTER TO ARG, ENTRY FROM DADD
DADDFO: LXI     D,DFACLO        ;GET POINTER TO FAC, ENTRY FROM FOUT
DADDS:  MVI     C,7             ;SET UP A COUNT
        STA     DADDOP          ;STORE THE ADD OR SUBTRACT INSTRUCTION
        XRA     S               ;CLEAR CARRY
DADDL:  LDAX    D               ;GET A BYTE FROM RESULT NUMBER
DADDOP: NOP                     ;THIS IS EITHER "ADC    ," OR "SBB      M"
        STAX    D               ;SAVE THE CHANGED BYTE
        INX     D               ;INCREMENT POINTERS TO NEXT HIGHER ORDER BYTE
        INX     H
        DCR     C               ;ARE WE DONE?
        JNZ     DADDL           ;NO, DO THE NEXT HIGHER ORDER BYTE
        RET                     ;ALL DONE


        ;NEGATE SIGNED NUMBER IN FAC
        ;THIS IS USED BY DADD, DINT
        ;ALTERS A,B,C,H,L
DNEGR:  MOV     A,H             ;COMPLEMENT SIGN OF FAC
        CMA                     ;USE THE UNPACKED SIGN BYTE
        MOV     M,A             ;SAVE THE NEW SIGN
        LXI     H,DFACLO-1      ;GET POINTER TO LO
        MVI     B,10            ;SET UP A COUNT
        XRA     A               ;CLEAR CARRY AND GET A ZERO
        MOV     C,A             ;SAVE ZERO IN C
DNEGR1: MOV     A,C             ;GET A ZERO
        SBB     M               ;NEGATE THE BYTE OF FAC
        MOV     M,A             ;UPDATE FAC
        INX     H               ;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
        DCR     B               ;ARE WE DONE?
        JNX     DNEGR1          ;NO, NEGATE THE NEXT BYTE
        RET                     ;ALL DONE


        ;SHIFT DBL FAC RIGHT ONE
        ;A = SHIFT COUNT
        ;ALTERS A,C,D,E,H,L
DSHFTR: LXI     H,DFACLO-1      ;GET POINTER TO LO
        MVI     M,0             ;PUT ZERO IN EXTRA LO ORDER BYTE
DSHFT1: SUI     10              ;SEE IF WE CAN SHIFT 8 RIGHT
        JC      DSHFR3          ;WE CAN'T, CHECK IF WE ARE DONE
DSHFRM: LXI     H,FAC-1         ;ENTRY FROM DMULT, GET POINTER TO HO
        MVI     E,0             ;SHIFT A ZERO INTO THE HO
        MVI     D,10            ;SET UP A COUNT
DSHFR2: MOV     C,M             ;SAVE A BYTE OF FAC
        MOV     M,E             ;PUT THE LAST BYTE IN ITS PLACE
        MOC     E,C             ;SET UP E FOR NEXT TIME THROUGH THE LOOP
        DCX     H               ;POINT TO NEXT LOWER ORDER BYTE
        DCR     D               ;ARE WE DONE?
        JNZ     DSHFR2          ;NO, DO THE NEXT BYTE
        JMP     DSHFR1          ;YES, SEE IF WE CAN SHIFT OVER 8 MORE
DSHFR3: ADI     11              ;CORRECT SHIFT COUNT
        MOV     D,A             ;SAVE SHIFT COUNT IN D
DSHFR4: XRA     A               ;CLEAR CARRY
        DCR     D               ;ARE WE DONE?
        RZ                      ;YES
DSHFRA: LXI     H,FAC-1         ;NO, GET POINTER TO LO, ENTRY FROM DADD, DMULT
        MVI     E,10            ;SET UP A COUNT, RORARE FAC ONE LEFT
DSHFR5: MOV     A,M             ;GET A BYTE OF THE FAC
        RAR                     ;ROTATE IT LEFT
        MOV     M,A             ;PUT THE UPDATED BYTE BACK
        DCX     H               ;DECREMENT POINTER TO NEXT LOWER ORDER BYTE
        DCR     E               ;ARE WE DONE?
        JNZ     DSHFR5          ;NO, ROTATE THE NEXT LOWER ORDER BYTE
        JMP     DSHFR4          ;YES, SEE IF WE ARE DONE SHIFTING


        ;ROTATE FAC LEFT ONE
        ;ALTERS A,C,H,L
DSHFLC: MVI     C,10            ;SET UP A COUNT
DSHFTL: MOV     A,M             ;GET A BYTE OF FAC
        RAL                     ;ROTATE IT LEFT ONE
        MOV     M,A             ;UPDATE BYTE IN FAC
        INX     H               ;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
        DCR     C               ;ARE WE DONE?
        JNZ     DSHFTL          ;NO, ROTATE THE NEXT BYTE
        RET                     ;ALL DONE


        ;DOUBLE PRECISION MULTIPLICATION        FAC:=ARG+FAC
        ;ALTERS ALL REGISTERS
DMULT:  FSIGN                   ;CHECK IF WE ARE MULTIPLYING BY ZERO
        RZ                      ;YES, ALL DONE, THE FAC IS ZERO
        CALL    MULDVA          ;ADD EXPONENTS AND TAKE CARE OF SIGNS
        CALL    DMULDV          ;ZERO FAC AND PUT FAC IN FBUFFR
        MOV     M,C             ;PUT UNPACKED HO IN ARG
        LXI     D,ARGLO         ;GET POINTER TO LO OF ARG
        MVI     B,7             ;SET UP A COUNT
DMULT2: LDAX    D               ;GET THE BYTE OF ARG TO MULTIPLY BY
        INX     D               ;INCREMENT POINTER TO NEXT HIGHER BYTE
        ORA     A               ;CHECK IF WE ARE MULTIPLYING BY ZERO
        PUSH    D               ;SAVE POINTER TO ARG
        JZ      DMULT5          ;WE ARE
        MVI     C,10            ;SET UP A COUNT
DMULT3: PUSH    B               ;SAVE COUNTERS
        RAR                     ;ROTATE MULTIPLIER RIGHT
        MOV     B,A             ;SAVE IT
        CC      DADDAA          ;ADD IN OLD FAC IF BIT OF MULTIPIER WAS ONE
        MVI     D,1             ;ROTATE PRODUCT RIGHT ONE
        CALL    DSHFRA
        MOV     A,B             ;GET MULTIPLIER IN A
        POP     B               ;GET COUNTERS BACK
        DCR     C               ;ARE WE DONE WITHT HIS BYTE OF ARG?
        JNZ     DMULT3          ;NO, MULTIPLY BY THE NEXT BIT OF THE MULTIPLIER
DMULT4: POP     D               ;YES, GET POINTER INTO ARG BACK
        DCR     B               ;ARE WE DONE?
        JNZ     DMULT2          ;NO, MULTIPLY BY NEXT HIGHER ORDER BY OF ARG
        JMP     NORMAL          ;ALL DONE, NORMALIZE AND ROUND RESULT
DMULT5: CALL    DSHFRM          ;SHIFT PRODUCT RIGHT ONE BYTE, WE ARE
        JMP     DMULT4          ; MULTIPLYIING BY ZERO


        ;CONSTANT FOR DIV10, DDIV10
DTEN:   000     ; 10D0
        000
        000
        000
FTEN:   000     ;10.0
        000
        040
        204

        ;DOUBLE PRECISION DIVIDE FAC BY 10
        ;ALTERS ALL REGISTERS
DDIV10: CALL    VMOVAF          ;SAVE THE FAC IN ARG
        LXI     H,DTEN          ;GET POINTER TO A DOUBLE PRECISION 10
        CALL    VMOVFM          ;MOVE TEN INTO THE FAC
                                ;FALL INTO DDIV AND DIVIDE BY TEN


        ;DOUBLE PRECISION DIVISION      FAC:=ARG/FAC
        ;ALTERS ALL REGISTERS
DDIV:   FSIGN                   ;CHECK FOR DIVISION BY ZERO
        JZ      DV0ERR          ;DON'T LET HIM DO IT
        CALL    MULDVS          ;SUBTRACT EXPONENTS AND CHECK SIGNS
        INR     M               ;ADD TWO TO EXPONENT TO CORRECT SCALING
        INR     M
        CALL    DMULDV          ;ZERO FAC AND PUT FAC IN FBUFFT
        LXI     H,ARG           ;GET POINTE RTO THE EXTRA HO BYTE WE WILL USE
        MOV     M,C             ;ZERO IT
        MXI     B,0             ;ZERO FLAG TO SEE WHEN WE START DIVIDING
DDIV1:  XWD     1000,076        ;"MVI   A", SUBTRACT FBUFFR FROM ARG
        SBB     M               ;GET SUBTRACT INSTRUCTION
        CALL    DADDD           ;DO THE SUBTRACTION
        LDAX    D               ;SUBTRACT FROM EXTRA HO BYTE
        SBB     C               ;HERE C=0
        CMC                     ;CARRY=1 IF SUBTRACTION WAS GOOD
        JC      DDIV2           ;WAS IT OK?
        XWD     1000,076        ;"MVI   A" NO, ADD FBUFFR BACK IN
        ADC     M               ;GET ADD INSTRUCTION
        CALL    DADDD           ;DO THE ADDITION
        XRA     A               ;CLEAR CARRY
        XWD     1000,332        ;"JC" OVER NEXT TWO BYTES
DDIV2:  STAX    D               ;STORE THE NEW HIGHEST ORDER BYTE
        INR     B               ;INCREMENT FLAG TO SHOW WE COULD DIVIDE
        LDA     FAC-1           ;CHECK IF WE ARE DONE DIVIDING
        INR     A               ;SET SIGN FLAG WITHOUT AFFECTING CARRY
        DCR     A
        RAR                     ;PUT CARRY IN MSG FOR DROUND
        JM      DROUNB          ;WE ARE DONE, WE HAVE 57 BITS OF ACCURACY
        RAL                     ;GET OLD CARRY BACK WHERE IT BELONDS
        LXI     H,DFACLO        ;GET POINTE RTO LO OF FAC
        MVI     C,7             ;SET UP A COUNT, SHIFT FAC LEFT ONE
        CALL    DSHFTL          ;SHIFT IN THE NEXT BIT IN THE QUOTIENT
        LXI     H,ARGLO         ;GET POINTER TO LO IN ARG
        CALL    DSHFLC          ;SHIFT DIVIDEND ONE LEFT
        MOV     A,B             ;IS THIS THE FIRST TIME AND WAS THE
        ORA     A               ; SUBTRACTION NOT GOOD? (B WILL GET
        JNZ     DDIV1           ; CHANGED ON THE FIRST OR SECOND SUBTRACTION)
        LXI     H,FAC           ;YES, SUBTRACT ONE FROM EXPONENT TO CORRECT
        DCR     M               ; SCALING
        JNZ     DDIV1           ;CONTINUE DIVIDING IF NO OVERFLOW
        JMP     OVERR           ;WE HAVE OVERFLOW!!


        ;TRANSFER FAC TO FBUFFR FOR DMULT AND DDIV
        ;ALTERS A,B,C,D,E,H,L
DMULDV: MOV     A,C             ;PUT UNPACKED HO BACK IN ARG
        STA     ARG-1
        DCX     H               ;POINT TO HO OF FAC
        LXI     D,FBUFFR+^D23   ;POINT TO END OF FBUFFR
        MVI     B,7             ;SET UP A COUNT
        MVI     C,0             ;GET A ZERO TO FILL FAC WITH
DMLDV1: MOV     A,M             ;GET A BYTE FROM FAC
        STAX    D               ;PUT IT IN FBUFFR
        MOV     M,C             ;PUT A ZERO IN FAC
        DCX     D               ;POINT TO NEXT BYTE IN FBUFFR
        DCX     H               ;POINT TO NEXT LOWER ORDER BYTE IN FAC
        DCR     B               ;ARE WE DONE?
        JNZ     DMLDV1          ;NO, TRANSFER THE NEXT BYTE
        RET                     ;ALL DONE


        ;DOUBLE PRECISION MULTIPLY THE FAC BY 10
        ;ALTERS ALL REGISTERS
DMUL10: CALL    VMOVAF          ;SAVE THE FAC IN ARG
                                ;VMOVAF EXITS WITH (DE)=FAC+1
        XCHG                    ;GET THE POINTER INTO THE FAC IN (HL)
        DCX     H               ;POINT TO THE EXPONENT
        MDV     A,M             ;GET THE EXPONENT
        ADI     2               ;MULTIPLY FAC BY 4 BY ADDING 2 TO THE EXPONENT
        JC      OVERR           ;CHECK FOR OVERFLOW
        MOV     M,A             ;SAVE THE NEW EXPONENT
        PUSH    H               ;SAVE POINTER TO FAC
        CALL    DADD            ;ADD IN THE ORIGINAL FAC TO GET 5 TIMES  FAC
        POP     H               ;GET THE POINTER TO FAC BACK
        INR     M               ;ADD ONE TO EXPONENT TO GET 10 TIMES FAC
        RNZ                     ;ALL DONE IF OVERFLOW DID NOT OCCUR
        JMP     OVERR>          ;IT DID, GIVE THE APPROPRIATE MESSAGE
PAGE
SUBTTL  FLOATING POINT INPUT ROUTINE
        ;ALTERS ALL REGISTERS
        ;THE NUMBER IS LEFT IN FAC
        ;AT ENTRY, (HL) POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
        ;THE FIRST CHARACTER IS ALSO IN A.  WE PACK THE DIGITS INTO THE FAC
        ;AS AN INTEGER AND KEEP TRACK OF WHERE THE DECIMAL POINT IS.
        ;C IS 377 IF WE HAVE NOT SEEN A DECIMAL POINT, 0 IF WE HAVE.
        ;B IS THE NUMBER OF DIGITS AFTER THE DECIMAL POINT.
        ;AT THE END, B AND THE EXPONENT (IN E) ARE USED TO DETERMINE HOW MANY
        ;TIMES WE MULTIPLY OR DIVIDE BY TEN TO GET THE CORRECT NUMBER.
FIN:
IFN     STRING,<
        ;IF WE ARE CALLED BY VAL, THE SIGNS MAY NOT BE CRUNCHED
        CPI     "-"             ;SEE IF NUMBER IS NEGATIVE
        PUSH    PSW             ;SAVE SIGN
        JZ      FIN1            ;IGNORE MINUS SIGN
        CPI     "+"             ;IGNORE A LEADING SIGN
        JZ      FIN1>
        DCX     H               ;SET CHARACTER POINTER BACK ONE
FIN1:
IFN     LENGTH-2,<
        CALL    ZERO            ;CLEAR FAC
        MOV     B,A             ;CLEAR FLAGS: B=DECIMAL PLACE COUNT
        MOV     D,A             ;D=SIGN OF EXPONENT
        MOV     E,A             ;E=EXPONENT
        CMA
        MOV     C,A             ;C="." FLAG
        ;HERE TO GET THE NEXT DIGIT OF THE NUMBER, A DECIMAL POINT OR AN "E"
FINC:   CHRGET                  ;GET A CHARACTER
        JC      FINDIG          ;DO WE HAVE A DIGIT?
        CPI     "."             ;TEST FOR DECIMAL POINT
        JZ      FINDP
        CPI     "E"             ;CHECK FOR BEGINNING OF EXPONENT
        JNZ     FINE            ;"NONE OF THE ABOVE" SO END OF NUMBER
        ;HERE TO CHECK FOR THE SIGN OF THE EXPONENT
        CHRGET                  ;CHECK FOR ITS SIGN
IFN     STRING,<
        PUSH    H               ;SAVE TEXT POINTER
        LXI     H,FINEC         ;PUT FINEC ON STACK SO WE CAN JUMP
        XTHL>                   ; TO IT IN LESS BYTES
        DCR     D               ;SET SIGN OF EXPONENT FLAG
        CPI     MINUTK          ;NEGATIVE EXPONENT?
IFE     STRING,<
        JZ      FINEC>
IFN     STRING,<
        RZ
        CPI     "-"
        RZ>
        INR     D               ;NO, RESET FLAG
IFN     STRING,<
        CPI     "+"
        RZ>
        CPI     PLUSTK          ;IGNORE "+"
IFE     STRING,<
        JZ      FINEC>
IFN     STRING,<
        RZ
        POP     PSW>            ;GET FINEC OFF STACK
        DCX     H               ;CHECK IF LAST CHARACTER A DIGIT
        ;HERE TO GET THE NEXT DIGIT OF THE EXPONENT
FINEC:  CHRGET                  ;GET NEXT CHARACTER
        JC      FINEDG          ;IS IT A DIGIT?
        INR     D               ;NO, EXPONENT ALL IN
        JNZ     FINE            ;SET ITS SIGN
        XRA     A
        SUB     E
        MOV     E,A
        INR     C               ;MAKE SURE C IS NOT 377
        ;HERE TO CHECK IF WE HAVE SEEN 2 DECIMAL POINTS AND SET THE DECIMAL
        ; POINT FLAG
FINDP:  INR     C               ;DECIMAL POINTS!! -- SET FLAG
        JZ      FINC            ;CONTINUE SCANNING CHARACTERS
                                ;WE DON'T WANT TWO SO END OF NUMBER
        ;HERE TO MULTIPLY OR DIVIDE BY 10 THE CORRECT NUMBER OF TIMES.
        ;WE HAVE ALREADY READ IN ALL THE DIGITS.
FINE:   PUSH    H               ;SAVE POINTER FOR LATER
        MOV     A,E             ;EXPONENT=EXPONENT-# OF DECIMAL PLACES
        SUB     B
FINE2:  CP      FINMUL          ;MULTIPLY BY THEN IF EXPONENT IS POSITIVE
        JP      FINE3           ;DIVIDE BY TEN IF EXPONENT IS NEGATIVE
        PUSH    PSW             ;SAVE EXPONENT
        CALL    DIV10           ;DIVIDE NUMBER BY TEN
        POP     PSW             ;GET EXPONENT
        INR     A               ;INCREMENT IT
FINE3:  JNZ     FINE2           ;DO AGAIN IF WE ARE NOT DONE
IFE     STRING,<
        POP     H>              ;GET CHARACTER POINTER
IFN     STRING,<
        POP     D               ;GET CHARACTER POINTER
        POP     PSW             ;GET SIGN
        CZ      NEG             ;NEGATE IF NECESSARY
        XCHG>                   ;GET CHARACTER POINTER IN (HL)
        RET>                    ;ALL DONE
IFE     LENGTH-2,<
        XCHG                    ;SAVE THE TEXT POINTER IN (DE)
        LXI     B,377+$CODE     ;CLEAR FLAGS:  B=DECIMAL PLACE COUNT
                                ;C="." FLAG
        MOV     H,C             ;ZERO (HL)
        MOV     L,C
        CALL    CONISS          ;ZERO FAC, SET VALTYP TO "INTEGER"
        XCHG                    ;GET THE TEXT POINTER BACK IN (HL)
        ;HERE TO CHECK FOR A DIGIT, A DECIMAL POINT, "E" OR "D"
FINC:   CHRGET                  ;GET THE NEXT CHARACTER OF THE NUMBER
        JC      FINDIG          ;WE HAVE A DIGIT
        CPI     "."             ;CHECK FOR A DECIMAL POINT
        JZ      FINDP           ;WE HAVE ONE, I GUESS
        CPI     "E"             ;CHECK FOR A SINGLE PRECISION EXPONENT
        JZ      FINEX           ;WE HAVE A SINGLE PRECISION NUMBER
        CPI     "D"             ;CHECK FOR A DOUBLE PRECISION EXPONENT
        JNZ     FINE            ;WE DON'T HAVE ONE, THE NUMBER IS FINISHED
        ORA     A               ;DOUBLE PRECISION NUMBER -- TURN OFF ZERO FLAG
FINEX:  CALL    FINFRC          ;FORCE THE FAC TO BE SNG OR DBL
        PUSH    H               ;SAVE THE TEXT POINTER
        LXI     H,FINEC         ;GET ADDRESS TO JUMP TO, THIS IS TO SAVE BYTES
        XTHL                    ;PUT IT ON STACK AND GET TEXT POINTER
        ;HERE TO CHECK FOR THE SIGN OF THE EXPONENT
        CHRGET                  ;GET THE FIRST CHARACTER OF THE EXPONENT
        DCR     D               ;SET SIGN OF EXPONENT TO MINUS
        CPI     MINUTK          ;CHECK IF THE EXPONENT IS NEGATIVE
        RZ                      ;IT IS
        CPI     "-"             ;THIS IS IN CASE WE ARE CALLED BY VAL
        RZ
        INR     D               ;EXPONENT IS STILL POSITIVE, RESET FLAG
        CPI     PLUSTK          ;IGNORE A LEADING PLUS SIGN
        RZ
        CPI     "+"
        RZ
        DCX     H               ;THE FIRST CHARACTER WAS NOT A SIGN, GO BACK
                                ; AND CHECK FOR A DIGIT
        POP     PSW             ;POP FINEC OFF THE STACK, WE NO LONGER NEED IT
        ;HERE TO GET THE NEXT DIGIT OF THE EXPONENT
FINEC:  CHRGET                  ;GET THE NEXT CHARACTER
        JC      FINEDG          ;PACK THE NEXT DIGIT INTO THE EXPONENT
        INR     D               ;IT WAS NOT A DIGIT, PUT THE CORRECT SIGN ON
        JNZ     FINE            ; THE EXPONENT, IT IS POSITIVE
        XRA     A               ;THE EXPONENT IS NEGATIVE
        SUB     E               ;NEGATE IT
        MOV     E,A             ;SAVE IT AGAIN
        ;HERE TO FINISH UP THE NUMBER
FINE:   LDA     VALTYP          ;FINISH UP -- WHAT KIND OF NUMBER IS IT?
        CPI     2
        JNZ     FINEF           ;IT IS A FLOATING POINT ONE
        ;HERE TO FINISH UP AN INTEGER
        POP     PSW             ;IT IS AN INTEGER, GET ITS SIGN
        XCHG                    ;SAVE THE TEXT POINTER IN (DE)
        CZ      INEG            ;NEGATE IT IF NECESSARY
        XCHG                    ;GET THE TEXT POINTER BACK IN (HL)
        RET                     ;ALL DONE
        ;HERE TO FINISH UP A FLOATING POINT NUMBER
FINEF:  PUSH    H               ;SAVE THE TEXT POINTER
        MOV     A,E             ;FIND OUT HOW MANY TIMES WE HAVE TO MULTIPLY
        SUB     B               ; OR DIVIDE BY TEN
        ;HERE TO MULTIPLY OR DIVIDE BY TEN THE CORRECT NUMBER OF TIMES
FINEF2: CP      FINMUL          ;MULTIPLY IF WE HAVE TO
        CM      FINDIV          ;DIVIDE IF WE HAVE TO
        JNZ     FINEF2          ;MULTIPLY OR DIVIDE AGAIN IF WE ARE NOT DONE
        ;HERE TO PUT THE CORRECT SIGN ON THE NUMBER
        POP     D               ;GET THE TEXT POINTER
        POP     PSW             ;GET THE SIGN
        CZ      NEG             ;NEGATE IF NECESSARY
        XCHG                    ;GET THE TEXT POINTER IN (HL)
        LDA     VALTYP          ;WE WANT -32768 TO BE AN INT, BUT UNTIL NOW
        CPI     4               ; IT WOULD BE A SNG
        RNZ                     ;IT IS NOT SNG, SO IT IS NOT -32768
        PUSH    H               ;WE HAVE A SNG, SAVE TEXT POINTER
        LXI     H,POPMRT        ;GET ADDRESS THAT POP'S H OFF STACK BECAUSE
        PUSH    H               ; CONIS2 DOES FUNN THINGS WITH THE STACK
        CALL    CONIS2          ;CHECK IF WE AHVE -32768
        RET                     ;WE DON'T, POPHRT IS STILL ON THE STACK SO
                                ; WE CAN JUST RETURN

        ;HERE TO CHECK IF WE HAVE SEEN 2 DECIMAL PONTS AND SET THE DECIMAL
        ; POINT FLAG
FINDP:  INR     C               ;SET THE FLAG
        JNZ     FINEF           ;WE HAD 2 DECIMAL POINTS, NOW WE ARE DONE
        CALL    FINFRC          ;THIS IS THE FIRST ONE, CONVERT FAC TO SNG
        JMP     FINC            ;CONTINUE LOOKING FOR DIGITS

        ;FORCE THE FAC TO BE SNG OR DBL
        ;IF THE ZERO FLAG IS ON, THEN FORCE THE FAC TO BE SNG
        ;IF THE ZERO FLAG IS OFF, FORCE THE FAC TO BE DBL
FINFRC: PUSH    H               ;SAVE TEXT POINTER
        PUSH    D               ;SAVE EXPONENT INFORMATION
        PUSH    B               ;SAVE DECIMAL POINT INFORMATION
        PUSH    PSW             ;SAVE WHAT WE WANT THE FAC TO BE
        CZ      FRCSNG          ;CONVERT TO SNG IF WE AHVE TO
        POP     PSW             ;GET TYPE FLAG BACK
        CNZ     FRCDBL          ;CONVERT TO DBL IF WE HAVE TO
        POP     B               ;GET DECIMAL POINT INFORMATION BACK
        POP     D               ;GET EXPONENT INFORMATION BACK
        POP     H               ;GET TEXT POINTER BACK
        RET>                    ;ALL DONE
        ;THIS SUBROUTINE MULIPLIES BY TEN ONCE.
        ;IT IS A SUBROUTINE BECAUSE IT SAVES BYTES WHEN WE CHECK IF A IS ZERO
FINMUL: RZ                      ;RETURN IF EXPONENT IS ZERO, ENTRY FROM FOUT
FINMLT: PUSH    PSW             ;SAVE EXPONENT, ENTRY FROM FOUT
IFN     LENGTH-2,<
        CALL    MUL10>          ;MULTIPLY BY TEN
IFE     LENGTH-2,<
        LDA     CALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
        CPI     4
        PUSH    PSW             ;SAVE THE TYPE
        CZ      MUL10           ;WE HAVE A SNG, MULTIPLY BY 10.0
        POP     PSW             ;GET THE TYPE BACK
        CNZ     DMUL10>         ;WE HAVE A DBL, MULTIPLY BY 1000
        POP     PSW             ;GET EXPONENT
DCRART: DCR     A               ;DECREASE IT
        RET                     ;ALL DONE
IFE     LENGTH-2,<
FINDIC: PUSH    PSW             ;WE HAVE TO DIVIDE -- SAVE COUNT
        LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
        CPI     4
        PUSH    PSW             ;SAVE THE TYPE
        CZ      DIV10           ;WE HAVE A SNG NUMBER
        POP     PSW             ;GET THE TYPE BACK
        CNZ     DDIV10          ;WE HAVE A DBL NUMBER
        POP     PSW             ;GET COUNT BACK
        INR     A               ;UPDATE IT
        RET>
        ;HERE TO PACK THE NEXT FIGIT OF THE NUMBER INTO THE FAC
        ;WE MULTIPLY THE FAC BY TEN AND ADD IN THE NEXT DIGIT
FINDIG:
IFN     LENGTH-2,<
        PUSH    D               ;DIGITS: SAVE EXPONENT INFORMATION
        MOV     D,A             ;PROTECT DIGIT FROM BELOW
        MOV     A,B             ;INCREMENT DECIMAL PLACE COUNT
        ADC     C               ; IF PAST THE DECIMAL POINT
        MOV     B,A
        PUSH    B               ;SAVE NECESSARY DATA
        PUSH    H
        PUSH    D               ;SAVE DIGIT
        CALL    MUL10           ;MULTIPLY OLD NUMBER BY 10
        POP     PSW             ;GET NEXT DIGIT
        SUI     "0"             ;SUBTRACT OFF ASCII CODE
IFE     EXTFNC,<
        CALL    PUSHF           ;PUT NUMBER ON STACK
        CALL    FLOAT           ;CONVERT TO FLOATING POINT NUMBER
        POPR
        CALL    FADD>           ;ADD IN NEXT DIGIT
IFN     EXTFNC,<
        CALL    FINLOG>
        POP     H               ;RECALL DATA
        POP     B
        POP     D
        JMP     FINC>           ;GET NEXT CHARACTER
IFE     LENGTH-2,<
        PUSH    D               ;SAVE EXPONENT INFORMATION
        MOV     A,B             ;INCREMENT DECIMAL PLACE COUNT IF WE ARE
        ADC     C               ; PAST THE DECIMAL POINT
        MOV     B,A
        PUSH    B               ;SAVE DECIMAL POINT INFORMATION
        PUSH    H               ;SAVE TEXT POINTER
        MOV     A,M             ;GET THE DIGIT
        SUI     "0"             ;CONVERT IT TO ASCII
        PUSH    PSW             ;SAVE THE DIGIT
        LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
        CPI     4
        JNC     FINDGV          ;WE DO NOT HAVE AN INTEGER
        ;HERE TO PACK THE NEXT DIGIT OF AN INTEGER
        LHLD    FACLO           ;WE HAVE AN INTEGER, GET IT IN (HL)
        LXI     D,^D3277+$CODE  ;SEE IF WE WILL OVERFLOW
        COMPAR                  ;COMPAR RETURNS WITH CARRY ON IF
        JNC     FINDG2          ; (HL) .LT. (DE), SO THE NUMBER IS TOO BIG
        MOV     D,H             ;COPY (HL) INTO (DE)
        MOV     E,L
        DAD     H               ;MULTIPLY (HL) BY 2
        DAD     H               ;MULTIPLY (HL) BY 2, (HL) NOW IS 4*(DE)
        DAD     D               ;ADD IN OLD (HL) TO GET 5*(DE)
        DAD     H               ;MULTIPLY BY 2 TO GET TEN TIMES THE OLD (HL)
        POP     PSW             ;GET THE DIGIT
        MOV     C,A             ;SAVE IT SO WE CAN USE DAD, B IS ALREADY ZERO
        DAD     B               ;ADD IN THE NEXT DIGIT
        MOV     A,H             ;CHECK FOR OVERFLOW
        ORA     A               ;OVERFLOW OCCURRED IF THE MSB IS ON
        JM      FINDG1          ;WE HAVE OVERFLOW!!
        SHLO    FACLO           ;EVERYTHING IS FINE, STORE THE NEW NUMBER
FINDGE: POP     H               ;ALL DONE, GET THE TEXT POINTER BACK
        POP     B               ;GET DECIMAL POINT INFORMATION BACK
        POP     D               ;GET EXPONENT INFORMATION BACK
        JMP     FINC            ;GET THE NEXT CHARACTER
        ;HERE TO HANDLE 32768, 32769
FINDG1: MOV     A,C             ;GET THE DIGIT
        PUSH    PSW             ;PUT IT BACK ON THE STACK
        ;HERE TO CONVERT THE INTEGER DIGITS TO SINGLE PRECISION DIGITS
FINDG2: CALL    CONSI           ;CONVERT THE INTEGER TO SINGLE PRECISION
        XRA     A               ;DO NOT TAKE THE FOLLOWING JUMP
        ;HERE TO DECIDE IF WE HAVE A SINGLE OR DOUBLE PRECISION NUMBER
FINDGV: JNZ     FINDGD          ;FALL THROUGH IF VALTYP WAS 4 I.E. SNG PREC
        MOVRI   224,164,044,000 ;GET 1000000, DO WE HAVE 7 DIGITS ALREADY?
        CALL    FCOMP           ;IF SO, FAC .GE. 1000000
        JP      FINDG3          ;WE DO, CONVERT TO DOUBLE PRECISION
        POP     PSW             ;GET THE NEXT DIGIT
        CALL    FINLOG          ;PACK IT INTO THE FAC
        JMP     FINDGE          ;GET FLAGS OFF STACK AND WE ARE DONE
        ;HERE TO CONVERY A 7 DIGIT DINGLE PRECISION NUMBER TO DOUBLE PRECISION
FINDG3: CALL    CONDS           ;CONVERT SINGLE TO DOUBLE PRECISION
        ;HERE TO PACK IN THE NEXT DIGIT OF A DOUBLE PRECISION NUMBER
FINDGD: CALL    DMUL10          ;MULTIPLY THE FAC BY 10
        CALL    VMOVAF          ;SAVE THE FAC IN ARG
        POP     PSW             ;GET THE NEXT DIGIT
        CALL    FLOAT           ;CONVERT THE DIGIT TO SINGLE PRECISION
        CALL    CONDS           ;NOW, CONVERT THE DIGIT TO DOUBLE PRECISION
        CALL    DADD            ;ADD IN THE DIGIT
        JMP     FINDGE>         ;GET THE FLAGS OFF THE STACK AND WE ARE DONE
IFN     EXTFNC,<
        ;SUBROUTINE FOR FIN, LOG
FINLOG: CALL    PUSHF           ;SAVE FAC ON STACK
        CALL    FLOAT           ;CONVERT A TO A FLOATING POINT NUMBER
IFN     LENGTH-2,<
        JMP     FADDT>          ;ADD IT IN
IFE     LENGTH-2,<
        POPR                    ;GET PREVIOUS NUMBER OFF STACK
        JMP     FADD>>          ;ADD IT IN
        ;HERE WE PACK IN THE NEXT DIGIT OF THE EXPONENT
        ;WE MULTIPLY THE OLD EXPONENT BY TEN AND ADD IN THE NEXT DIGIT
        ;NOTE: EXPONENT OVERFLOW IS NOT CHECKED FOR
FINEDG: MOV     A,E             ;EXPONENT DIGIT -- MULTIPLY EXPONENT BY 10
        RLC                     ;FIRST BY 4
        RLC
        ADD     E               ;ADD 1 TO MAKE 5
        RLC                     ;NOW DOUBLE TO GET 10
        ADD     M               ;ADD IT IN
        SUI     "0"             ;SUBTRACT OFF ASCII CODE
        MOV     E,A             ;STORE EXPONENT
        JMP     FINEC           ;CONTINUE
PAGE
SUBTTL  FLOATING POINT OUTPUT ROUTINE
        ;ENTRY TO LINPRT
INPRT:  PUSH    H               ;SAVE LINE NUMBER
        LXI     H,INTXT##       ;PRINT MESAGE
        CALL    STROUT
        POP     H               ;FALL INTO LINPRT
        ;PRINT THE 2 BYTE NUMBER IN H,L
        ;ALTERS ALL REGISTERS
LINPRT:
IFN     LENGTH-2,<
        XCHG                    ;SET UP REGISTERS FOR FLOATR
        XRA     A
        MVI     B,230
        CALL    FLOATR          ;CONVERT TO FLOATING POINT
IFE     LENGTH-2,<
        CALL    CONISS          ;PUT THE LINE NUMBER IN THE FAC AS AN INTEGER
        XRA     A               ;SET FORMAT TO FREE FORMAT
        CALL    FOUINI          ;SET UP THE SIGN
        LXI     H,STROUI##      ;PUT PRINT STRING ADDRESS ON STACK SO WE WILL
        PUSH    H               ; RETURN TO IT AND DO AN "INX   H"
                                ;THIS GETS RID OF THE SPACE FOR THE SIGN AT
                                ; THE BEGINNING OF A LINE NUMBER
                                ;FALL INTO FOUT
IFE     LENGTH-2,<
        PUSH    B               ;PUT DUMMY FIELD LENGTHS ON STACK
        JMP     STROUI##        ;PRINT THE NUMBER
        ;FLOATING OUTPUT OF FAC
        ;ALTERS ALL REGISTERS
        ;THE ORIGINAL CONTENTS OF THE FAC IS LOST
IFN     LENGTH-2,<
FOUT1:  LXI     H,FBUFFR        ;GET BEGINING OF CHARACTER BUFFER
        PUSH    H               ;SAVE IT FOR WHEN WE RETURN
        ;PUT THE SIGN OF THE NUMBER IN THE BUFFER AND MAKE IT POSITIVE
        FSIGN                   ;GET SIGN OF NUMBER
        MVI     M," "           ;PRINT SPACE IF POSITIVE
        JP      FOUT1
        MVI     M,"-"           ;PRINT A MINUS SIGN IF NEGATIVE
FOUT1:  INX     H               ;INCREMENT POINTER TO NEXT CHRACTER POSIT
        MVI     M,"0"           ;PUT A ZERO IN BUFFER IN CASE NUMBER=0
        JZ      FOUT19          ;DO IT IF THE NUMBER IS ZERO
        PUSH    H               ;SAVE BUFFER POINTER
        CM      NEG             ;NEGATE NUMBER IF NEGATIVE
;HERE WE GET THE FAC IN THE RANGE 100000 .LE. FAC .LE. 999999 AND ROUND IT TO
;AN INTEGER.  WE KEEP A COUNT OF HOW MANY TIMES WE MULTIPLY OR DIVIDE BY TEN
;SO WE KNOW WHAT THE EXPONENT WILL BE.  THE FAC IS THEN CONVERTED TO AN
;INTEGER IN C,D,E.  WE USE A TABLE OF POWERS OF TEN TO CALCULATE EACH DIGIT.
;THIS ALGORITHM IS USED FOR SPEED.
        XRA     A               ;PUT TEN'S EXPONENT COUNT ON STACK
        PUSH    PSW
        CALL    FOUTCB          ;SEE IF NUMBER IS TOO BIG OR TOO SMALL
FOUT3:  MOVRI   221,103,117,370 ;IS NUMBER .LE. 99999.9499?  IT IS TOO SMALL
        CALL    FCOMP           ;FCOMP RETURNS 377, 0 OR 1 IN A, SO THE
                                ; PARITY WILL BE OFF IFF 1 IS RETURN
        JPO     FOUT5           ;NO, NUMBER IS IN RANGE
        POP     PSW
        CALL    FINMLT          ;YES, MULTIPLY IT BY TEN TO GET
        PUSH    PSW             ; IT IN RANGE
        JMP     FOUT3           ;SEE IF NUMBER IS NOW IN RANGE
FOUT9:  CALL    DIV10           ;NO, DIVIDE NUMBER BY TEN, IT IS TOO BIG
        POP     PSW             ;ADD ONE TO EXPONENT
        INR     A
        PUSH    PSW
        CALL    FOUTCB          ;IS NUMBER .LE. 999999.499?
                                ;YES, NUMBER IS IN PRINTING RANGE, I.E.
                                ; ALL DIGITS TO BE PRINTED ARE THE INTEGER PART
FOUT5:  CALL    FADDH           ;ROUND NUMBER TO NEAREST INTEGER
        INR     A               ;MAKE A NON-ZERO, SINCE NUMBER IS POSITIVE
                                ; AND NON-ZERO, ROUND WILL EXIT WITH THE HO
                                ; IN A, SO THE MSB WILL ALWAYS BE ZERO AND
                                ; ADDING ONE WILL NEVER CAUSE A TO BE ZERO
        CALL    QINT            ;GET INTEGER PART IN C,D,E
        CALL    MOVFR           ;SAVE NUMBER IN FAC
        ;DECIDE IF THE NUMBER SHOULD BE PRINTED IN FIXED OR FLOATING NOTATION
        LXI     B,2*400+6+$CODE ;SET DECIMAL POINT COUNT FOR E NOTATION
                                ;C = DIGIT COUNT
        POP     PSW             ;GET EXPONENT
        ADD     C               ;SHOULD THE NUMBER BE PRINTED IN E NOTATION?
        JM      FOUT6           ;YES, IT IS .LT. 1
        CPI     7
        JNC     FOUT6           ;YES,  IT IS .GT. 999999
        INR     A
        MOV     B,A             ;B = DECIMAL POINT COUNT
        MVI     A,1             ;SET FIXED POINT FLAG, THE EXPONENT IS ZERO
                                ; IF WE ARE USING FIXED POINT NOTATION
FOUT6:  DCR     A               ;E NOTATION: ADD 5 TO ORIGINAL EXPONENT
        POP     H               ;GET BUFFER POINTER FROM STACK
        PUSH    PSW             ;SAVE EXPONENT FOR LATER
        ;CALCULATE THE DIGITS OF THE NUMBER
        LXI     D,FOUTBL        ;STORE LOC OF LARGEST POWER OF TEN
FOUT8:  DCR     B               ;SEE IF IT IS TIME TO PRINT A DECIMAL POINT
        MVI     M,"."           ;PUT A DECIMAL POINT IN THE BUFFER
        CZ      INXHRT          ;INCREMENT THE BUFFER POINTER IF IT IS TIME
        PUSH    B               ;SAVE FLAGS
        PUSH    H               ;SAVE CHARCATER POINTER
        PUSH    D               ;SAVE POWER OF TEN POINTER
        CALL    MOVRF           ;GET NUMBER IN C,D,E
        POP     H               ;GET POWER OF TEN POINTER
        MVI     B, "0"-1        ;B = NEXT DIGIT TO BE PRINTED
FOUT10: INR     B               ;ADD ONE TO DIGIT
        MOV     A,E             ;SUBTRACT LO
        SUB     M
        MOV     E,A
        INX     H               ;POINT TO NEXT BYTE OF POWER OF TEN
        MOV     A,D             ;SUBTRACT MO
        SBB     M
        MOV     D,A
        INX     H
        MOV     A,C             ;SUBTRACT HO
        SBB     M
        MOV     C,A
        DCX     H               ;POINT TO BEGINNING OF POWER OF TEN
        DCX     H
        JNC     FOUT10          ;SUBTRACT AGAIN IF RESULT WAS POSITIVE
        CALL    FADDA           ;IT WASN'T, ADD POWER OF TEN BACK IN
        INX     H               ;INCREMENT POINTER TO NEXT POWER OF TEN
        CALL    MOVFR           ;SAVE C,D,E IN FAC
        XCHG                    ;GET POWER OF TEN POINTER IN (DE)
        POP     H               ;GET BUFFER POINTER
        MOV     M,B             ;PUT CHARACTER IN BUFFER
        INX     H               ;INCREMENT BUFFER POINTER
        POP     B               ;GET COUNTERS OFF STACK
        DCR     C               ;WAS THAT THE LAST DIGIT
        JNZ     FOUT8           ;DO MORE IF NOT
        DCR     B               ;SEE IF DECIMAL POINT GOES AFTER LAST DIGIT
        JZ      FOUT12          ;IT DOES, WE HAVE NO ZEROES TO SUPPRESS
        ;SUPPRESS THE TRAILING ZEROS
FOUT11: DCX     H               ;GO BACK TO LAST CHARACTER
        MOV     A,M             ;GET IT
        CPI     "0"             ;IGNORE TRAILING ZEROS
        JZ      FOUT11
        ;SUPPRESS DECIMAL POINT IF WE HAVE AN INTEGER
        CPI     "."             ;IGNORE DECIMAL POINT BEFORE TRAILING ZEROS
        CNZ     INXHRT          ;IF NO DP, MOVE POINER TO NEXT POSITION
FOUT12: POP     PSW             ;GET DECIMAL EXPONENT
        JZ      FOUT17          ;RETURN IF NUMBER WAS IN FIXED POINT FORMAT
        ;FLOATING POINT NOTATION -- PUT AN "E" IN THE BUFFER
        MVI     M,"E"           ;PUT AN "E" IN THE BUFFER
        INX     H               ;PUT SIGN OF EXPONENT IN BUFFER
        ;PUT IN THE SIGN OF THE EXPONENT
        MVI     M,"+"           ;A PLUS IF POSITIVE
        JP      FOUT14
        MVI     M,"-"           ;A MINUS IF NEGATIVE
        CMA                     ;NEGATE EXPONENT
        INR     A
        ;CALCULATE THE TWO DIGIT EXPONENT
FOUT14: MVI     B,"0"-1         ;INITIALIZE TEN'S DIGIT COUNT
FOUT15: INR     B               ;INCREMENT DIGIT
        SUI     12              ;SUBTRACT TEN
        JNC     FOUT15          ;DO IT AGAIN IF RESULT WAS POSITIVE
        ADI     "0"+12          ;ADD BACK IN TEN AND CONVERT TO ASCII
        LPUT THE EXPONENT IN THE BUFFER
        INX     H
        MOV     M,B             ;PUT TEN'S DIGIT OF EXPONENT IN BUFFER
FOUT19: INX     H               ;WHEN WE JUMP TO HERE, A IS ZERO
        MOV     M,A             ;PUT ONE'S DIGIT IN BUFFER
        INX     H               ;INCREMENT POINTER
FOUT17: MOV     M,C             ;PUT ZERO AT END OF BUFFER
        POP     H               ;EXIT WITH (HL) POINTING TO STRING
        RET                     ;ALL DONE
        ;SEE IF FAC .LE. 999999.499
FOUTCB: MOVRI   224,164,043,367 ;COMPARE NUMBER WITH CONSTANT
        CALL    FCOMP
        POP     H               ;GET RETURN ADDRESS OFF STACK
        JPO     FOUT9           ;NUMBER TOO BIG, DIVIDE BY TEN
        PCHL                    ;NUMBER OK, RETURN
        ;CONSTANTS FOR FOUT
FHALF:  000     ;1/2
        000     ;THIS CONSTANT IS ALSO USED BY SQR, SIN, COS
        000
        200
        ;POWER OF TEN TABLE
FOUTBL: 240     ; 100000
        206
        001
        020     ; 10000
        047
        000
        350     ; 1000
        003
        000
        144     ; 100
        000
        000
        012     ; 10
        000
        000
        001     ; 1
        000
        000>
IFE     LENGTH-2,<
        ;OUTPUT THE VALUE IN THE FAC ACCORDING TO THE FORMAT SPECIFICATIONS
        ; IN A,B,C
        ;ALL REGISTERS ARE ALTERED
        ;THE ORIGINAL CONTENTS OF THE FAC IS LOST

        ;THE FORMAT IS SPECIFIED IN A, B AND C AS FOLLOWS:
        ;THE BITS OF A MEAN THE FOLLOWING:
;BIT 7  0 MEANS FREE FORMAT OUTPUT, I.E. THE OTHER BITS OF A MUST BE ZERO,
;       TRAILING ZEROS ARE SUPPRESSED, A NUMBER IS PRINTED IN FIXED OR FLOATING
;       POINT NOTATION ACCORDING TO ITS MAGNITUDE, THE NUMBER IS LEFT
;       JUSTIFIED IN ITS FIELD, B AND C ARE IGNORED.
;MD     1 MEANS FIXED FORMAT OUTPUT, I.E. THE OTHER BITS OF A ARE CHECKED FOR
;MD     FORMATTING INFORMATION, THE NUMBER IS RIGHT JUSTIFIED IN ITS FIELD,
;MD     TRAILING ZEROS ARE NOT SUPPRESSED.  THIS IS USED FOR PRINT USING.
;BIT 6  1 MEANS GROUP THE DIGITS IN THE INTEGER PART OF THE NUMBER INTO GROUPS
;MD     OF THREE AND SEPARATE THE GROUPS BY COMMAS
;MD     0 MEANS DON'T PRINT THE NUMBER WITH COMMAS
;BIT 5  1 MEANS FILL THE LEADING SPACES IN THE FIELD WITH ASTERISKS ("*")
;BIT 4  1 MEANS OUTPUT THE NUMBER WITH A FLOATING DOLLAR SIGN ("$")
;BIT 3  1 MEANS PRINT THE SIGN OF A POSITIVE NUMBER AS A PLUS SIGN ("+")
;       INSTEAD OF A SPACE
;BIT 2  1 MEANS PRINT THE SIGN OF THE NUMBER AFTER THE NUMBER
;BIT 1  UNUSED
;BIT 0  1 MEANS PRINT THE NUMBER IN FLOATING POINT NOTATION I.E. "E NOTATION"
;       IF THIS BIT IS ON, THE COMMA SPECIFICATION (BIT 6) IS IGNORED.
;MD     0 MEANS PRINT THE NUMBER IN FIXED POINT NOTATION.  NUMBER .GE. 1E16
;       CANNOT BE PRINTED IN FIXED POINT NOTATION.

        ;B AND C TELL HOW BIG THE FIELD IS:
;B  =   THE NUMBER OF PLACES IN THE FIELD TO THE LEFT OF THE DECIMAL POINT
;       (B DOES NOT INCLUDE THE DECIMAL POINT)
;C  =   THE NUMBER OF PLACES IN THE FIELD TO THE RIGHT OF THE DECIMAL POINT
;MD     (C INCLUDES THE DECIMAL POINT)
;MD     B AND C DONOT INCLUDE THE 4 POSITIONS FOR THE EXPONENT IF BIT 0 IS ON
        ;FOUT ASSUMES B+C .LE. 24 (DECIMAL)

        ;ENTRY TO PRINT THE FAC IN FREE FORMAT
FOUT:   XRA     A               ;SET FORMAT FLAGS TO FREE FORMATED OUTPUT
        ;ENTRY TO PRINT THE FAC USING THE FORMAT SPECIFICATIONS IN A, B, AND C
PUFOUT: CALL    FOUINI          ;SAVE THE FORMAT SPECIFICATION IN A AND PUT
                                ;A SPACE FOR POSITIVE NUMBERS IN THE BUFFER
        PUSH    B               ;SAVE THE FIELD LENGTH SPECIFICATIONS
        ANI     10              ;CHECK IF POSITIVE NUMBERS GET A PLUS SIGN
        JZ      FOUT1           ;THEY DON'T
        MVI     M,"+"           ;THEY DO, PUT IN A PLUS SIGN
FOUT1:  LDA     VALTYP          ;SEE WHAT KIND OF A VALUE WE HAVE
        MOV     B,A             ;SAVE IT
        XCHG                    ;SAVE BUFFER POINTER
        MOV     A,B             ;GET THE SIGN OF THE FAC
        XCHG                    ;PUT THE BUFFER POINTER BACK IN (HL)
        MOV     A,B             ;GET THE VALTYP BACK
        JP      FOUT2           ;IF WE HAVE A NEGATIVE NUMBER, NEGATE IT
        MVI     M,"-"           ; AND PUT A MINUS SIGN IN THE BUFFER
        PUSH    H               ;SAVE THE BUFFER POINTER
        CALL    VNEG            ;NEGATE THE NUMBER
        POP     H               ;GET THE BUFFER POINTER BACK
FOUT2:  INX     H               ;POINT TO WHERE THE NEXT CHARACTER GOES
        LDA     TEMP3           ;GET THE FORMAT SPECIFICATION
        MOV     D,A             ;SAVE IT FOR LATER
        RAL                     ;PUT THE FREE FORMAT OR NOT BIT IN THE CARRY
        LDA     VALTYP          ;GET THE VALTYP, VNEG COULD HAVE CHANGED THIS
                                ; SINCE -32768 IS INT AND 32768 IS SNG,
                                ; SO B IS NOT ACCURATE
        JC      FOUTFX          ;THE MAN WANTS FIXED FORMATTED OUTPUT
        ;HERE TO PRINT NUMBERS IN FREE FORMAT
        POP     B               ;WE CAN IGNORE THE OLD B AND C
        MVI     "0"             ;PUT A ZERO IN THE BUFFER IN CASE THE NUMBER
        JZ      FOUTZR          ; IS ZERO.  IT IS, FINISH IT UP
        CPI     4               ;DECIDE WHAT KIND OF A VALUE WE HAVE
        JNC     FOUFRV          ;WE HAVE A SNG OR DBL
        ;HERE TO PRINT AN INTEGER IN FREE FORMAT
        LXI     B,$CODE         ;SET THE DECIMAL POINT COUNT AND COMMA COUNT
                                ; TO ZERO
        CALL    FOUTCI          ;CONVERT THE INTEGER TO DECIMAL
                                ;FALL INTO FOUTZS AND ZERO SUPPRESS THE THING

        ;ZERO SUPPRESS THE DIGITS IN FBUFFR
        ;ASTERISK FILL AND ZERO SUPPRESS IF NECESSARY
        ;SET UP B AND CONDITION CODES IF WE HAVE A TRAILING SIGN
FOUTZS: LXI     H,FBUFFR+1      ;GET POINTER TO THE SIGN
        MOV     B,M             ;SAVE THE SIGN IN B
        MVI     C," "           ;DEFAULT FILL CHARACTER TO A SPACE
        LDA     TEMP3           ;GET FORMAT SPECS TO SEE IF WE AHVE TO
        MOV     E,A             ; ASTERISK FILL.  SAVE IT
        ANI     40
        JZ      FOTZS1          ;WE DON'T
        MOV     A,B             ;WE DO, SEE IF THE SIGN WAS A SPACE
        CMP     C               ;ZERO FLAG IS SET IF IT WAS
        MVI     C,"*"           ;SET FILL CHARACTER TO AN ASTERISK
        JNZ     FOTZS1          ;SET THE SIGN TO AN ASTERISK IF IT WAS A SPACE
        MOV     B,C             ;B HAS THE SIGN, C THE FILL CHARACTER
FOTZS1: MOV     M,C             ;FILL IN THE ZERO OR THE SIGN
        CHRGET                  ;GET THE NEXT CHARACTER IN THE BUFFER
                                ;SINCE THERE ARE NO SPACES, "CHRGET" IS
                                ; EQUIVALENT TO "INX    H"/"MOV A,M"
        CPI     "0"             ;DO WE HAVE A ZERO?
        JZ      FOTZS1          ;YES, SUPPRESS IT
        CPI     54              ;54=","  DO WE HAVE A COMMA?
        JZ      FOTSZ1          ;YES. SUPPRESS IT
        CPI     "."             ;ARE WE AT THE DECIMAL POINT?
        JNZ     FOTZS2          ;NO, I GUESS NOT
        DCX     H               ;YES, BACK UP AND PUT A ZERO BEFORE IT
        MVI     M,"0"
FOTZS2: MOV     A,E             ;GET THE FORMAT SPECS TO CHECK FOR A FLOATING
        ANI     20              ; DOLLAR SIGN
        JZ      FOTZS3          ;WE DON'T HAVE ONE
        DCX     H               ;WE HAVE ONE, BACK UP AND PUT IN THE DOLLAR
        MVI     M,"S"           ; SIGN
FOTZS3: MOV     A,E             ;DO WE HAVE A TRAILING SIGN?
        ANI     4
        RNZ                     ;YES, RETURN; NOTE THE NON-ZERO FLAG IS SET
FOFXIS: DCX     H               ;NO, BACK UP ONE AND PUT THE SIGN BACK IN
                                ;PEOPLE JUMP HERE WHO WANT A "DCX       H" AND
                                ; DON'T CARE ABOUT M
        MOV     M,B             ;PUT IN THE SIGN
        RET                     ;ALL DONE

        ;HERE TO INITIALLY SET UP THE FORMAT SPECS AND PUT A SPACE FOR THE
        ;SIGN OF A POSITIVE NUMBER
FOUINI: STA     TEMP3           ;SAVE THE FORMAT SPECIFICATION
        LXI     H,FBUFFR+1      ;GET A POINTER INTO BUGGET
        MVI     M," "           ;PUT IN A SPACE
        RET                     ;ALL DONE

        ;HERE TO PRINT A SNG OR DBL IN FREE FORMAT
FOUFRV: PUSH    H               ;SAVE THE BUFFER POINTER
        JZ      FOUFRS          ;WE HAVE A SNG
        ;HERE TO SET UP THE FLAG TO PRINT A DBL IN FREE FORMAT
        MVI     D,20            ;WE HAVE A DBL, SET THE DIGIT COUNT
        XWD     1000,001        ;"LXI   B" OVER THE NEXT TWO BYTES
        ;HERE TO SET UP THE FLAG TO PRINT A SNG IN FREE FORMAT
FOUFRS: MVI     D,6             ;SET THE DIGIT COUNT
        CALL    FOUTNV          ;NORMALIZE THE FAC SO ALL SIGNIFICANT DIGITS
                                ; ARE IN THE INTEGER PART
        LXI     B,2*400+$CODE   ;B = DECIMAL POINT COUNT
                                ;C = COMMA COUNT
                                ;SET COMMA COUNT TO ZERO AND DECIMAL POINT
                                ; COUNT FOR E NOTATION
        ADD     D               ;SEE IF NUMBER SHOULD BE PRINTED IN E NOTATION
        JM      FOFRS1          ;IT SHOULD, IT IS .LT .1
        INR     D               ;CHECK IF IT IS TOO BG
        CMP     D
        JNC     FOFRS1          ;IT IS TOO BIG, IT IS .GT. 10^D-1
        INR     A               ;IT IS OK FOR FIXED POINT NOTATION
        MOV     B,A             ;SET DECIMAL POINT COUNT
        MVI     A,1             ;SET FIXED POINT FLAG, THE EXPONENT IS ZERO
                                ; IF WE ARE USING FIXED POINT NOTATION
FOFRS1: DCR     A               ;E NOTATION: ADD D-1 TO ORIGINAL EXPONENT
        POP     H               ;GET THE BUGGER POINTER BACK
        PUSH    PSW             ;SAVE THE EXPONENT FOR LATER
        CALL    FOUTCV          ;CONVERT THE NUMBER TO DECIMAL DIGITS
        ;HERE TO SUPPRESS THE TRAILING ZEROS
FOFRS2: DCX     H               ;MOVE BACK TO THE LAST CHARACTER
        MOV     A,M             ;GET IT AND SEE IF IT WAS ZERO
        CPI     "0"
        JZ      FOFRS2          ;IT WAS, CONTINUE SUPPRESSING
        COU     "."             ;HAVE WE SUPPRESSED ALL THE FRACTIONAL DIGITS?
        CNZ     INXHRT          ;YES, IGNORE THE DECIMAL POINT ALSO
        POP     PSW             ;GET THE EXPONENT BACK
        JZ      FOUTON          ;WE ARE DONE IF WE ARE IN FIXED POINT NOTATION
                                ;FALL IN AND PUT THE EXPONENT IN THE BUFFER

        ;HERE TO PUT THE EXPONENT AND "E" OR "D" IN THE BUFFER
        ;THE EXPONENT IS IN A
FOFLDN: MOV     B,A             ;SAVE THE EXPONENT
        LDA     VALTYP          ;GET THE VALTYP TO DEIDE IF WE PRINT AN "E"
        CPI     4               ; ON A "D"
        MOV     A,B             ;GET THE EXPONENT BACK
        JZ      FOUCEE          ;WE HAVE TO PRINT AN "E"
        MVI     M,"D"           ;GET THE "D"
        XWD     1000,001        ;"LXI   B" OVER THE NEXT TWO BYTES
FOUCEE: MVI     M,"E"           ;GET AN "E"
        INX     H               ;PUT SIGN OF EXPONENT IN BUFFER
        ;PUT IN THE SIGN OF THE EXPONENT
        MVI     M,"+"           ;A PLUS IF POSITIVE
        JP      FOUCE1
        MVI     M,"-"           ;A MINUS IF NEGATIVE
        CMA                     ;NEGATE EXPONENT
        INR     A
        ;CALCULATE THE TWO DIGIT EXPONENT
FOUCE1: MVI     B,"0"-1         ;INITIALIZE TEN'S DIGIT COUNT
FOUCE2: INR     B               ;INCREMENT DIGIT
        SUI     12              ;SUBTRACT TEN
        JNC     FOUCE2          ;DO IT AGAIN IF RESULT WAS POSITIVE
        ADI     "0"+12          ;ADD BACK IN TEN AND CONVERT TO ASCII
        ;PUT THE EXPONENT IN THE BUFFER
        INX     H
        MOV     M,B             ;PUT THEN'S DIGIT OF EXPONENT IN BUFFER
        INX     H               ;WHEN WE JUMP TO HERE, A IS ZERO
        MOV     M,A             ;PUT ONE'S DIGIT IN BUFFER
FOUTZR: INX     H               ;INCREMENT POINTER, HERE TO FINISH UP PRINTING
                                ; A FREE FORMAT ZERO
FOUTON: MVI     M,0             ;PUT A ZERO AT THE END OF THE NUMBER
        XCHG                    ;SAVE THE POINTER TO THE END OF THE NUMBER
                                ; IN (DE) FOR FFXFLV
        LXI     H,FBUFFR+1      ;GET A POINTER TO THE BEGINNING
        RET                     ;ALL DONE

        ;HERE TO PUT A POSSIBLE COMMA COUNT IN C, AND ZERO IF WE ARE NOT
        ;USING THE COMMA SPECIFICATION
FOUTCC: MOV     C,A             ;SAVE A POSSIBLE COMMA COUNT
FOUICC: LDA     TEMP3           ;GET THE FORMAT SPECS
        ANI     100             ;LOOK AT THE COMMA BIT
        RNZ                     ;WE ARE USING COMMAS, JUST RETURN
        MOV     C,A             ;WE AREN'T, ZERO THE COMMA COUNT
        RET                     ;ALL DONE

        ;HERE TO PRINT A NUMBER IN FIXED FORMAT
FOUTFC: CPI     4               ;CHECK WHAT KIND OF VALUE WE HAVE
        MOV     A,D             ;GET THE FORMAT SPECS
        JNC     FOUFXV          ;WE HAVE A SNG OR A DBL
        ;HERE TO PRINT AN INTEGER IN FIXED FORMAT
        RAR                     ;CHECK IF WE HAVE TO PRINT IT IN FLOATING
        JC      FFXIFL          ; POINT NOTATION
        ;HERE TO PRINT AN INTEGER IN FIXED FORMAT-FIXED POINT NOTATION
        LXI     B,6*400+3+$CODE ;SET DECIMAL POINT COUNT TO 6 AND
                                ; COMMA COUNT TO 3
        CALL    FOICC           ;CHECK IF WE DON'T HAVE TO USE THE COMMAS
        POP     D               ;GET THE FIELD LENGTHS
        MOV     A,D             ;SEE IF WE HAVE TO PRINT EXTRA SPACES BECAUSE
        SUI     5               ; THE FIELD IS TOO BIG
        CP      FOTZER          ;WE DO, PUT IN ZEROS, THEY WILL LATER BE
                                ; CONVERTED TO SPACES OR ASTERISKS BY FOUTZS
        PUSH    D               ;SAVE THE FIELD LENGTHS AGAIN
        CALL    FOUTC1          ;CONVERT THE NUMBER TO DECIMAL DIGITS
        POP     D               ;GET THE FIELD LENGTHS BACK
        ORA     E               ;DO WE NEED A DECIMAL POINT?  HERE A=0
        CZ      FOFXIS          ;WE DON'T, BACKSPACE OVER IT.  AT FOFXIS,
                                ; WE DON'T CARE ABOUT B, WE ONLY WANT THE
                                ; "DCX  H".  LATER ON WE WILL DO A "MVI M,0"
                                ; AND COVER UP WHAT WAS IN B.
        CNZ     FOTZER          ;FOFXIS PRESERVED THE CONDITION CODES
                                ;IF WE DO HAVE DECIMAL PLACES, FILL THEM UP
                                ; WITH ZEROS
                                ;FALL IN AND FINISH UP THE NUMBER

        ;HERE TO FINISH UP A FIXED FORMAT NUMBER
FOUTTS: PUSH    H               ;SAVE BUFFER POINTER
        CALL    FOUTZS          ;ZERO SUPPRESS THE NUMBER
        POP     H               ;GET THE BUFFER POINTER BACK
        JZ      FFXIX1          ;CHECK IF WE HAVE A TRAILING SIGN
        MOV     M,B             ;WE DO, PUT THE SIGN IN THE BUFFER
        INX     H               ;INCREMENT THE BUFFER POINTER
FFXIXI: MVI     M,0             ;PUT A ZERO AT THE END OF THE NUMBER

        ;HERE TO CHECK IF A FIXED FORMAT-FIXED POINT NUMBER OVERFLOWED ITS
        ;FIELD LENGTH
        ;D = THE B IN THE FORMAT SPECIFICATION
        ;THIS ASSUMES THE LOCATION OF THE DECIMAL POINT IS IN TEMP2
        LXI     H,FBUFFR        ;GET A POINTER TO THE BEGINNING
FOUBE1: INX     H               ;INCREMENT POINTER TO THE NEXT CHARACTER
FOUBE5: LDA     TEMP2           ;GET THE LOCATION OF THE DECIMAL POINT
        SUB     L               ;FIGURE OUT HOUW MUCH SPACE WE ARE TAKING
        SUB     D               ;IS THIS THE RIGHT AMOUNT OF SPACE TO TAKE?
        RZ                      ;YES, WE ARE DONE, RETURN FROM FOUT
        MOV     A,M             ;NO, WE MUST HAVE TOO MUCH SINCE WE STARTED
                                ; CHECKING FROM THE BEGINNING OF THE BUFFER
                                ; AND THE FIELD MUST BE SMALL ENOUGH TO FIT IN
                                ; THE BUFFER.  GET THE NEXT CHARACTER IN
                                ; THE BUFFER
        CPI     " "             ;IF IT IS A SPACE OR AN ASTERISK, WE CAN
        JZ      FOUBE1          ; IGNORE IT AND MAKE THE FIELD SHORTER WITH
        CPI     "*"             ; NO ILL EFFECTS
        JZ      FOUBE1
        DCX     H               ;MOVE THE POINTER BACK ONE TO READ THE
                                ; CHARACTER WITH CHRGET
        PUSH    H               ;SAVE THE POINTER

        ;HERE WE SEE IF WE CAN IGNORE THE LEADING ZERO BEFORE A DECIMAL POINT.
        ;THIS OCCURS IF WE SEE THE FOLLOWING: (IN ORDER)
        ;       A SIGN (EITHER "-" OR "+")      [OPTIONAL]
        ;       A DOLLAR SIGN                   [OPTIONAL]
        ;       A ZERO                          [MANDATORY]
        ;       A DECIMAL POINT                 [MANDATORY]
        ;       ANOTHER DIGIT                   [MANDATORY]
        ;IF YOU SEE A LEADING ZERO, IT MUST BE THE ONE BEFORE A DECIMAL POINT
        ;PR ELSE FOUTZS WOULD HAVE SUPPRESSED IT, SO WE CAN JUST "INX   H"
        ;OVER THE CHARACTER FOLLOWING THE ZERO, AND NOT CHECK FOR THE
        ;DECIMAL POINT EXPLICITLY.
FOUBE2: PUSH    PSE             ;PUT THE LAST CHARACTER ON THE STACK.  THE
                                ; ZERO FLAG IS SET.  THE FIRST TIME THE ZERO
                                ; ZERO FLAG IS NOT SET.
        LXI     B,FOUBE2        ;GET THE ADDRESS WE GO TO IF WE SEE A CHARACTER
        PUSH    B               ; WE ARE LOOKING FOR
        CHRGET                  ;GET THE NEXT CHARACTER
        CPI     "-"             ;SAVE IT AND GET THE NEXT CHARACTER
        RZ                      ; A MINUS SIGN, A PLUS SIGN OR A DOLLAR SIGN
        CPI     "+"
        RZ
        CPI     "$"
        RZ
        POP     B               ;IT ISN'T, GET THE ADDRESS OFF THE STACK
        CPI     "0"             ;IS IT A ZERO?
        JNZ     FOUBE4          ;NO, WE CAN NOT GET RID OF ANOTHER CHARACTER
        INX     H               ;SKIP OVER THE DECIMAL POINT
        CHRGET                  ;GET THE NEXT CHARACTER
        JNC     FOUBE4          ;IT IS NOT A DIGIT, WE CAN'T SHORTEN THE FIELD
        DCX     H               ;WE CAN!!!  POINT TO THE DECIMAL POINT
        XWD     1000,001        ;"LXI   B" OVER THE NEXT 2 BYTES
FOUBE3: DCX     H               ;POINT BACK ONE CHARACTER
        MOV     M,A             ;PUT THE CHARACTER BACK

        ;IF WE CAN GET RID OF THE ZERO, WE PUT THE CHARACTERS ON THE STACK
        ;BACK INTO THE BUFFER ONE POSITION IN FRONT OF WHERE THEY ORIGINALLY
        ;WERE.  NOTE THAT THE MAXIMUM NUMBER OF STACK LEVELS THIS USES IS
        ;THREE -- ONE FOR THE LAST ENTRY FLAG, ONE FOR A POSSIBLE SIGN,
        ;AND ONE FOR A POSSIBLE DOLLAR SIGN.  WE DON'T HAVE TO WORRY ABOUT
        ;THE FIRST CHARACTER BEING IN THE BUFFER TWICE BECAUSE THE POINTER
        ;WHEN FOUT EXITS WILL BE POINTING TO THE SECOND OCCURANCE.
        POP     PSW             ;GET THE CHARACTER OFF THE STACK
        JZ      FOUBE3          ;PUT IT BACK IN THE BUFFER IF IT IS NOT THE
                                ; LAST ONE
        POP     B               ;GET THE BUFFER POINTER OFF THE STACK
        JMP     FOUBE4          ;SEE IF THE FIELD IS NOW SMALL ENOUGH
        ;HERE IF THE NUMBER IS TOO BIG FOR THE FIELD
FOUBE4: POP     PSW             ;GET THE CHARACTERS OFF THE STACK
        JZ      FOUBE4          ;LEAVE THE NUMBER IN THE BUFFER ALONE
        POP     H               ;GET THE POINTER TO THE BEGINNING OF THE
                                ; NUMBER MINUTE 1
        MVI     M,"%"           ;PUT IN A PERCENT SIGN TO INDICATE THE NUMBER
                                ; WAS TOO LARGE FOR THE FIELD
        RET                     ;ALL DONE -- RETURN FROM FOUT

        ;HERE TO PRINT A SNG OR DBL IN FIXED FORMAT
FOUFXV: PUSH    H               ;SAVE THE BUFFER POINTER
        RAR                     ;GET FIXED OR FLOATING NOTATION FLAG IN CARRY
        JC      FFXFLV          ;PRINT THE NUMBER IN E-NOTATION
        JZ      FFXSFX          ;WE HAVE A SNG
        ;HERE TO PRINT A DBL IN FIXED FORMAT--FIXED POINT NOTATION
        LXI     D,FFXDXM        ;GET POINTER TO 1D16
        CALL    DCOMPD          ;WE CAN'T PRINT A NUMBER .GE. 10^16 IN FIXED
                                ; POINT NOTATION
        LXI     D,16*400+$CODE  ;SET D = NUMBER OF DIGITS TO PRINT FOR A DBL
                                ;C = 0 FOR DBL (THIS IS FOR COMMAS)
        JM      FFXSDC          ;IF THE FAC WAS SMALL ENOUGH, GO PRINT IT
        ;HERE TO PRINT IN FREE FORMAT WITH A PERCENT SIGN A NUMBER .GE. 10^16
FFXSDO: XRA     A               ;SET THE FORMAT SPECS TO FREE FORMAT
        STA     TEMP3
        POP     H               ;GET THE BUFFER POINTER
        DCX     H               ;SET IT UP TO JUMP BACK INTO FOUT
                                ;NOW (HL)=FBUFFR+1
        CALL    FOUT1           ;PRINT THE NUMBER IN FREE FORMAT, THE SIGN
                                ; IS ALREADY IN THE BUFFER
        DCX     H               ;POINT IN FRONT OF THE NUMBER
        MVI     M,"%"           ;PUT IN THE PERCENT SIGN
        RET                     ;ALL DONE--RETURN FROM FOUT
        ;HERE TO PRINT A SNG IN FIXED FORMAT--FIXED POINT NOTATION
FFXSFX: MOVRI   226,016,033,312 ;GET 1E16, CHECK IF THE NUMBER IS TOO BIG
        CALL    FCOMP
        JP      FFXSD0          ;IT IS,PRINT IT IN FREE FORMAT WITH A % SIGN
        LXI     D,6*400+2+$CODE ;SET UP FLAGS FOR SNG --
                                ;D = NUMBER OF DIGITS TO PRINT IN A SNG
                                ;C = 2 (THIS IS FOR THE COMMAS)
        ;HERE TO ACTUALLY PRINT A SNG OR DBL IN E NOTATION
FFXSDC: FSIGN                   ;SEE IF WE HAVE ZERO
        CNZ     FOUTNV          ;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
                                ; BE PRINTED ARE IN THE INTEGER PART
        POP     H               ;GET THE BUFFER POINTER
        POP     B               ;GET THE FIELD LENGTH SPECS
        JM      FFXXVS          ;DO DIFFERENT STUFF IF ??? EXPONENT IS NEGATIVE
        ;HERE TO PRINT A NUMBER WITH NO FRACTIONAL DIGITS
        PUSH    B               ;SAVE THE FIELD LENGTH SPECS AGAIN
        MOV     C,A             ;SAVE THE EXPONENT
        MOV     A,B             ;WE HAVE TO PRINT LEADING ZEROS IF THE FIELD
        SUB     D               ; HAS MORE CHARACTERS THAN THERE ARE DIGITS IN
        SUB     C               ; THE NUMBER
        CP      FOTZER          ;FOUTZS WILL LATER SUPPRESS THEM
        MOV     A,C             ;SET UP THE COMMA COUNT
        ADD     E
        MOV     E,C             ;WE NO LONGER NEED THE NUMBER WE SETUP IN E
FFXXV1: SUI     3               ;REDUCE A MOD 3
        JNC     FFXXV1
        ADI     5               ;ADD 3 BACK AND ADD IN 2 MORE FOR SCALING
        CALL    FOUTCC          ;CHECK IF WE HAVE TO USE COMMAS AT ALL
        MOV     A,E             ;SETUP THE DECIMAL POINT COUNT
        ADD     D
        INR     A
        MOV     B,A             ;IT GOES IN B
        PUSH    D               ;SAVE SNG OR DBL AND EXPONENT INFORMATION
        CALL    FOUTCV          ;CONVERT THE NUMBER TO DECIMAL DIGITS
        POP     D               ;GET THE SNG OR DBL AND EXPONENT INFO BACK
        ORA     E               ;PUT IN DIGITS AFTER THE NUMBER IF IT
                                ; IS BIG ENOUGH, HERE A=0
        CNZ     FOTZRC          ;THERE CAN BE COMMAS IN THESE ZEROS
        POP     D               ;GET THE FIELD LENGTH SPECS
        ORA     E               ;HERE A=0
        CNZ     FOUTDP          ;PRINT A DECIMAL POINT IF NECESSARY
        DCR     A               ;SEE IF WE SHOULD PRINT SOME ZEROS TO FILL IN
        CP      FOTZER          ; THE DECIMAL PLACES
        JMP     FOUTTS          ;GO CHECK THE SIZE, ZERO SUPPRESS, ETC. AND
                                ; FINISH THE NUMBER
        ;HERE TO PRINT A SNG OR DBL THAT HAS FRACTIONAL DIGITS
FFXXVS: MOV     E,A             ;SAVE THE EXPONENT, WE DON'T NEED WHAT IS IN E
        MOV     A,C             ;DIVIDE BY TEN THE RIGHT NUMBER OF TIMES SO
        ORA     A               ; THE RESULT WILL BE ROUNDED CORRECTLY AND
        CNZ     DCRART          ; HAVE THE CORRECT NUMBER OF SIGNIFICANT
        ADD     E               ; DIGITS
        PUSH    PSW             ;SAVE THIS NUMBER FOR LATER
FFXXV2: CM      FINDIV          ;THIS IS THE DIVIDE LOOP
        JM      FFXXV2
        MOV     A,E             ;WE HAVE TWO CASES DEPENDING ON WHETHER THE
        ADD     D               ; THE NUMBER IS .LT. .1 OR NOT
        MOV     A,B
        JM      FFXXV3
        ;HERE TO PRINT NUMBERS .GE. .1
        SUB     D               ;PRINT SOME LEADING ZEROS IF THE FIELD IS
        SUB     E               ; BIGGER THAN THE NUMBER OF DIGITS WE WILL
        CP      FOTZER          ; PRINT
        POP     PSW             ;WE DON'T NEED THE NUMBER WE SAVED BEFORE
        MOV     B,E             ;GET ALL THE PERTINENT INFO IN B,C
        PUSH    B               ;SAVE THE EXPONENT AND "C" IN FIELD SPEC
        MOV     A,E             ;SET UP THE DECIMAL POINT COUNT
        ADD     D
        INR     A
        MOV     B,A
        MOV     A,D             ;SET UP THE COMMA COUNT
        ANI     2               ;THESE 2 INSTRUCTIONS MAP 6 TO 4
        ADI     2               ; AND 16 TO 2
        ADD     E
        CALL    FOUTCC          ;CHECK IF WE HAVE TO DO THE COMMA THING
        JMP     FFXXV6          ;CONVERT THE DIGITS AND DO THE TRIMMING UP
        ;HERE TO PRINT A NUMBER .LT. 1
FFXXV3: CALL    FOTZER          ;PUT ALL ZEROS BEFORE THE DECIMAL POINT
        MOV     A,C             ;SAVE C
        CALL    FOUTOP          ;PUT IN A DECIMAL POINT
        MOV     C,A             ;RESTORE C
        POP     PSW             ;GET THE NUMBER WE SAVED
        JM      FFXXV4          ;DECIDE HOW MANY ZEROS TO PRINT BETWEEN THE
        XRA     A               ; DECIMAL POINT AND THE FIRST DIGIT WE WILL
        SUB     E               ; PRINT.  HERE THE FIELD IS BIG ENOUGH TO
        SUB     D               ; HOLD ALL THE DIGITS
        JMP     FFXXV5          ;GO PRINT THEM
FFXXV4: MOV     A,C             ;HERE WE HAD TO DIVIDE BY TEN SO THE FIELD
        SUB     D               ; IS SMALLER THAN ALL SIGNIFICANT DIGITS IN
        DCR     A               ; THE NUMBER
FFXXV5: CALL    FOTZER          ;PRINT THE ZEROS
        MOV     B,E             ;SAVE THE EXPONENT IN B
        PUSH    B               ;SAVE EXPONENT AND THE "C" IN THE FIELD SPEC
        MOV     B,A             ;ZERO THE DECIMAL PLACE COUNT
        MOV     C,A             ;ZERO THE COMMA COUNT
FFXXV6: CALL    FOUTCV          ;CONVERT THE NUMBER TO DECIMAL DIGITS
        POP     D               ;GET THE EXPONENT AND FIELD SPEC BACK
        ORA     E               ;CHECK IF WE HAVE TO PRINT ANY ZEROS AFTER
                                ; THE LAST DIGIT
        JZ      FFXXV7          ;CHECK IF THERE WERE ANY DECIMAL PLACES AT ALL
        ADD     D               ;PRINTE SOME MORE TRAILING ZEROS
        DCR     A
        CP      FOTZER
        JMP     FOUTTS          ;FINISH UP THE NUMBER
        ;THERE WERE NO DECIMAL PLACES, IGNORE ALL DIGITS AFTER THE DECIMAL
        ;POINT
FFXXV7: LHLD    TEMP2           ;THE END OF THE NUMBER IS WHERE THE DP IS
        JMP     FOUTTS          ;FINISH UP THE NUMBER

        ;HERE TO PRINT AN INTEGER IN FIXED FORMAT--FLOATING POING NOTATION
FFXIFL: PUSH    H               ;SAVE THE BUFFER POINTER
        PUSH    D               ;SAVE THE FORMAT SPECS
        CALL    CONSI           ;CONVERT THE INTEGER TO A SNG
        POP     D               ;GET THE FORMAT SPECS BACK
        POP     H               ;GET THE BUFFER POINTER BACK
        XRA     A               ;SET FLAGS TO PRINT THE NUMBER AS A SNG
                                ;FALL INTO FFXFLV

        ;HERE TO PRINT A SNG OR DBL IN FIXED FORMAT-FLOTATING POINT NOTATION
FFXFLV: JZ      FFXSFL          ;IF WE HAVE A SNG, SET THE RIGHT FLAGS
        MVI     E,20            ;WE HAVE A DBL, GET HOW MANY DIGITS WE HAVE
        XWD     1000,001        ;"LXI   B" OVER THE NEXT TWO BYTES
FFXSFL: MVI     E,6             ;WE HAVE A DBL, GET HOW MANY DIGITS WE PRINT
        FSIGN                   ;SEE IF WE HAVE ZERO
        CNZ     FOUTNV          ;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
                                ; BE PRINTED ARE IN THE INTEGER PART
        POP     H               ;GET THE BUFFER POINTER BACK
        POP     B               ;GET THE FIELD LENGTH SPECS
        PUSH    PSW             ;SAAVE THE EXPONENT
        MOV     A,C             ;CALCULATE HOW MANY SIGNIFICANT DIGITS WE MUST
        ORA     A               ; PRINT
        PUSH    PSW             ;SAVE THE "C" FIELD SPEC FOR LATER
        CNZ     DCRART
        ADD     B
        MOV     C,A
        MOV     A,D             ;GET THE FIELD SPEC
        ANI     4               ;SEE IF THE SIGN IS A TRAILING SIGN
        CPI     1               ;SET CARRY IF A IS ZERO
        SBB     A               ;SET D=0 IF WE HAVE A TRAILING SIGN,
        MOV     D,A             ; D=377 IF WE DO NOT
        ADD     C
        MOV     C,A             ;SET C=NUMBER OF SIGNIFICANT DIGITS TO PRINT
        SUB     E               ;IF WE HAVE LESS THAN E, THEN WE MUST GET RID
FFXLV1: CM      FINDIV          ; OF SOME BY DIVIDING BY TEN AND ROUNDING
        JM      FFXLV1
        PUSH    B               ;SAVE THE "B" FIELD SPEC AND # OF SIG DIGITS
        MOV     A,B             ;SET THE DECIMAL PLACE COUNT
        INR     A
        SUB     D               ;TAKE INTO ACCOUNT IF THE SIGN IS TRAILING
        MOV     B,A
        MVI     C,0             ;SET COMMA COUNT TO ZERO, THE COMMA SPEC IS
        PUSH    D               ; IGNORED.  SAVE TRAILING SIGN INFO
        CALL    FOUTCV          ;CONVERT THE NUMBER TO DECIMAL DIGITS
        POP     D               ;GET THE TRAILING SIGN INFO BACK
        POP     B               ;GET # OF SIG DIGITS AND "B" FIELD SPEC BACK
        MOV     A,C             ;PRINT TRAILING ZEROS IF THE FIELD LENGTH IS
        SUB     E               ; LONGER THAN THE NUMBER OF DIGITS WE CAN PRINT
        CP      FOTZRC          ;THE DECIMAL POINT COULD COME OUT IN HERE
        POP     PSW             ;GET THE "C" FIELD SPEC BACK
        CZ      FOFXIS          ;IF C=0, THE LAST THING WAS A DECIMAL POINT,
                                ; SO IGNORE IT/  ALL WE CARE ABOUT IS THE
                                ; "DCX  H" AND NOT THE "MOV     M,B" AT FOFXIS
        POP     PSW             ;GET THE EXPONENT BACK
        ADD     E               ;SCALE IT CORRECTLY
        SUB     B
        SUB     D
        PUSH    B               ;SAVE THE "B" FIELD SPEC
        CALL    FOFLON          ;PUT THE EXPONENT IN THE BUFFER
        XCHG                    ;GET THE POINTER TO THE END IN (HL)
                                ; IN CASE WE HAVE A TRAILING SIGN
        POP     D               ;GET THE "B" FIELD SPEC IN D, PUT ON A POSSIBLE
        JMP     FOUTTS          ; TRAILING SIGN AND WE ARE DONE

        ;NORMALIZE THE NUMBER IN THE FAC SO ALL THE DIGITS ARE IN THE INTEGER
        ;PART,  RETURN THE BASE 10 EXPONENT IN A
        ;D,E ARE LEFT UNALTERED
FOUTNV: PUSH    D               ;SAVE (DE)
        LDA     VALTYP          ;GET WHAT KIND OF VALUE WE HAVE
        CPI     4
        JNZ     FOUTND          ;WE HAVE A DBL
        ;NORMALIZE A SNG
        XRA     A               ;ZERO THE EXPONENT
        PUSH    PSW             ;SAVE IT
        CALL    FOUNDSC         ;IS THE FAC TOO BIG OR TOO SMALL?
FOUNS1: MOVRI   221,103,117,370 ;GET 99999.9499 TO SEE IF THE FAC IS BIG
        CALL    FCOMP           ; ENOUGH YET
        JPO     FOUNS3          ;IT IS, WE ARE DONE
        POP     PSW             ;IT ISN'T, MULTIPLY BY TEN
        CALL    FINMLT
        PUSH    PSW             ;SAVE THE EXPONENT AGAIN
        JMP     FOUNDS1         ;NOW SEE IF IT IS BIG ENOUGH
FOUNS2: POP     PSW             ;THE FAC IS TOO BIG, GET THE EXPONENT
        CALL    FINDIV          ;DIVIDE IT BY TEN
        PUSH    PSW             ;SAVE THE EXPONENT AGAIN
        CALL    FOUNSC          ;SEE IF THE FAC IS SMALL ENOUGH
FOUNS3: POP     PSW             ;WE ARE DONE, GET THE EXPONENT BACK
        POP     D               ;GET (DE) BACK
        RET                     ;ALL DONE
        ;HERE TO SEE IF THE FAC IS SMALL ENOUGH YET
FOUNSC: MOVRI   224,164,043,367 ;GET 999999.499 TO SEE IF THE FAC IS TOO BIG
        CALL    FCOMP
        POP     H               ;GET THE RETURN ADRESS OFF THE STACK
        JPO     FOUNS2          ;IT IS TOO BIG, MAKE IT SMALLER
        PCHL                    ;IT IS SMALL ENOUGH, RETURN
        ;HERE TO NORMALIZE A DBL NUMBER
>
PAGE
SUBTTL  EXPONENTIATION AND THE SQUARE ROOT FUNCTION
IFE     EXTFNC,<
        ;SQUARE ROOT FUNCTION  ---  X=SQR(A)
        ;FIRST WE SCALE THE ARUGMENT TO BETWEEN .5 AND 2 BY LOOKING AT THE
        ;EXPONENT AND USING SQR(M*2^(2*N))=2^N*SQR(M).  THEN NEWTON'S METHOD
        ;IS USED TO COMPUTE SQR(M).  THE EXPONENT IS SAVED TO SCALE THE
        ;RESULT AT THE END.
        ;NEWTON'S METHOD FOR SQUARE ROOT:
        ;  X(0)=A
        ;  X(N+1)=(X(N)+A/X(N))/2
SQR:    FSIGN                   ;CHECK FOR ERROR CONDITION
        JM      FCERR           ;CAN'T TAKE SQR OF NEGATIVE NUMBER
        RZ                      ;  0=SQR(0)
        LXI     H,FAC           ;SCALE ARGUMENT TO BETWEEN .5 AND 2
        MOV     A,M             ;GET EXPONENT
        RAR                     ;GET EXPONENT OF SCALE FACTOR
                                ;USE  SQR(M*2^(2*N))=2^N*SQR(M)
        PUSH    PSW             ;SAVE IT
        PUSH    H               ;SAVE POINTER TO EXPONENT
        MVI     A,100           ;SET EXPONENT OF SCALED DOWN NUMBER
        RAL
        MOV     M,A             ;REPLACE IT
        LXI     H,FBUFFR        ;SAVE A
        CALL    MOVMF
        MVI     A,4             ;SET ITERATION COUNT
SQR1:   PUSH    PSW             ;SAVE COUNT
        CALL    PUSHF           ;SAVE X(N)
        LXI     H,FBUFFR        ;COMPUTE A/X(N)
        CALL    MOVRM           ;GET A IN THE REGISTERS
        CALL    FDIV
        POPR
        CALL    FADD            ;ADD IN X(N)
        LXI     H,FHALF         ;DIVIDE BY 2
        CALL    FMULTS
        POP     PSW             ;GET COUNT
        DCR     A               ;ARE WE DONE?
        JNZ     SQR1            ;NO, DO MORE ITERATIONS
        POP     H               ;YES, SET EXPONENT OF ANSWER
        POP     PSW             ;GET SCALE FACTOR
        ADI     300             ;CONVERT TO AN EXPONENT
        ADD     M               ;ADD EXPONENT IN
        MOV     M,A             ;REPLACE EXPONENT
        RET>                    ;ALL DONE
IFN     EXTFNC,<
        ;SUBROUTINE FOR PPWR, ATN
PSHNEG: LXI     H,NEG           ;GET THE ADDRESS OF NEG
        XTHL                    ;SWITCH RET ADDR AND ADDR OF NEG
        PCHL                    ;RETURN, THE ADDRESS OF NEG IS ON THE STACK
        ;SQUARE ROOT FUNCTION
        ;WE USE SQR(X)=X^.5
SQR:    CALL    PUSHF           ;SAVE ARG
        LXI     H,FHALF         ;GET 1/2
        CALL    MOVFM           ;  SQR(X)=X^0.5
FPWRT:  POPR                    ;GET ARG IN REGISTERS, ENTRY TO FPWR IF
                                ; ARGUMENT IS ON STACK.  FALL INTO FPWR
        ;EXPONENTIATION    ---    X^Y
        ;N.B.  0^0=1
        ;FIRST WE CHECK IF Y=0, IF SO, THE RESULT IS 1.
        ;NEXT, WE CHECK IF X=0, IF SO, THE RESULT IS 0.
        ;THEN WE CHECK IF X IS POSITIVE, IF NOT, WE CHECK THAT Y IS A
        ;NEGATIVE INTEGER, AND WHETHER IT IS EVEN OR ODD.  IF Y IS A NEGATIVE
        ;INTEGER, WE NEGATE X.  IF NOT, LOG WILL GIVE AN FC ERROR WHEN WE CALL
        ;IT.  IF X IS NEGATIVE AND Y IS ODD, WE PUSH THE ADDRESS OF NEG ON THE
        ;STACK SO WE WILL RETURN TO IT AND GET A NEGATIVE RESULT.  TO COMPUTE
        ;THE RESULT WE USE X^Y=EXP(Y*LOG(X))
FPWR:   FSIGN                   ;SEE IF Y IS ZERO
        JZ      EXP             ;IT IS, RESULT IS ONE
        MOV     A,B             ;SEE IF X IS ZERO
        ORA     A
        JZ      ZERO0           ;IT IS, RESULT IS ZERO
        PUSHR                   ;SAVE X ON STACK
        MOV     A,C             ;CHECK THE SIGN OF X
        ORI     177             ;TURN THE ZERO FLAG OFF
        CALL    MOVRF           ;GET Y IN THE REGISTERS
        JP      FPWR1           ;NO PROBLEMS IF X IS POSITIVE
        PUSHR                   ;SAVE Y
        CALL    INT             ;SEE IF Y IS AN INTEGER
        POPR                    ;GET Y BACK
        PUSH    PSW             ;SAVE LO OF INT FOR EVEN AND ODD INFORMATION
        CALL    FCOMP           ;SEE IF WE HAVE AN INTEGER
        POP     H               ;GET EVEN-ODD INFORMATION
        MOV     A,H             ;PUT EVEN-ODD FLAG IN CARRY
        RAR
FPWR1:  POP     H               ;GET X BACK IN FAC
        SHLD    FAC-1           ;STORE HO'S
        POP     H               ;GET LO'S OFF STACK
        SHLD    FACLO           ;STORE THEM IN FAC
        CC      PSHNEG          ;NEGATE NUMBER AT END IF Y WAS ODD
        CZ      NEG             ;NEGATE THE NEGATIVE NUMBER
FPWR2:  PUSHR                   ;SAVE Y AGAIN
        CALL    LOG             ;COMPUTE  EXP(Y=LOG(X))
        POPR                    ;IF X WAS NEGATIVE AND Y NOT AN INTEGER THEN
        CALL    FMULT>          ; LOG WILL BLOW HIM OUT OF THE WATER
;       JMP     EXP
PAGE
SUBTTL  EXPONENTIAL FUNCTON
IFN     EXTFNC,<
        ;WE FIRST SAVE THE ORIGINAL ARGUMENT AND MULTIPLY THE FAC BY LOG2(E)
        ;THE RESULT IS USED TO DETERMINE IF WE WILL GET OVERFLOW SINCE
        ;EXP(X)=2^(X=LOG2(E)) WHERE LOG2(E)=LOG(E) BASE 2. THEN WE SAVE THE
        ;INTEGER PART OF THIS TO SCALE THE ANSWER AT THE END, SINCE
        ;2^Y=2^INT(Y)*2^(Y-INT(Y)) AND 2*INT(Y) IS EASY TO COMPUTE.  SO WE
        ;NOW COMPUTE 2^(X*LOG2(E)-INT(X*LOG2(E))) BY
        ;P(LN(2)*(INT(X*LOG2(E))+1)-X) WHERE P IS AN APPROXIMATION
        ;POLYNOMIAL.  THE RESULT IS THEN SCALED BY THE POWER OF 2 WE
        ;PREVIOUSLY SAVED.
EXP:    CALL    PUSHF           ;SAVE ARGUMENT
        MOVRI   201,070,252,073 ;GET LOG(E) BASE 2,   CALCULATE:
        CALL    FMULT           ;   INT(ARG/LN(2)) = INT(ARG*LOG2(E))
        LDA     FAC             ;CARRY=0 IF FAC IS TOO BIG
        CPI     210             ; I.E. IF ABS(FAC) .GE. 128
        JNC     MLDVEX          ;IT IS TOO BIG
        CALL    INT             ;IS ARGUMENT TOO BIG?
        ADI     200             ;CHECK FOR OVERFLOW
        ADI     2
        JC      MLDVEX          ;WE HAVE OVERFLOW!!
        PUSH    PSW             ;SAVE SCALE FACTOR
        LXI     H,FONE          ;ADD ONE TO THE NUMBER
        CALL    FADDS
        CALL    MULLN2          ;MULTIPLY BY LN(2)
        POP     PSW             ;GET SCALE FACTOR OFF STACK
        POPR                    ;GET ARGUMENT
        PUSH    PSW             ;;
        CALL    FSUB            ;;
        CALL    NEG             ;;
        LXI     H,EXPCON        ;;
        CALL    POLY            ;;
        LXI     D,$CODE         ;;
        POP     B               ;;
        MOV     C,D             ;;
        JMP     FMULT
        ;CONSTANTS FOR EXP
EXPCON: 10      ;DEGREE
        100     ; -.0001413161
        056
        224
        164
        160     ; .001329882
        117
        056
        167
        156     ; -.00830136
        002
        210
        172
        346     ; .04165735
        240
        052
        174
        120     ; -.1666653
        252
        252
        176
        377     ; .4999999
        377
        177
        177
        000     ; -1.0
        000
        200
        201
        000     ; 1.0
        000
        000
        201>
PAGE
SUBTTL  POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR
IFN     EXTFNC,<
        ;EVALUATE P(x^2)*X
        ;POINTER TO DEGREE+1 IS IN (HL)
        ;THE CONSTANTS FOLLOW THE DEGREE
        ;CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
        ;WE COMPUTE:
        ; C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
POLYX:  CALL    PUSHF           ;SAVE X
        LXI     D,FMULTT        ;PUT ADDRESS OF FMULTT ON STACK
        PUSH    D               ; RETURN WE WILL MULTIPLY BY X
        PUSH    H               ;SAVE CONSTANT POINTER
        CALL    MOVRF           ;SQUARE X
        CALL    FMULT
        POP     H               ;GET CONSTANT POINTER
                                ;FALL INTO POLY
        ;POLYNOMIAL EVALUATOR
        ;POINTER TO DEGREE+1 IS IN (HL), IT IS UPDATED
        ;THE CONSTANTS FOLLOW THE DEGREE
        ;CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
        ;WE COMPUTE:
        ; C0+C1*X+C2*C^2+C3*X^3+...+C(N-1)*X^(N-1)+C(N)*X^N
POLY:   CALL    PUSHF           ;SAVE X
        MOV     A,M             ;GET DEGREE
        INX     H               ;INCREMENT POINTER TO FIRST CONSTANT
        CALL    MOVFM           ;MOVE FIRST CONSTANT TO FAC
        XWD     1000,006        ;"MVI   B" OVER NEXT BYTE
POLY1:  POP     PSW             ;GET DEGREE
        POPR                    ;GET X
        DCR     A               ;ARE WE DONE?
        RZ                      ;YES, RETURN
        PUSHR                   ;NO, SAVE X
        PUSH    PSW             ;SAVE DEGREE
        PUSH    H               ;SAVE CONSTANT POINTER
        CALL    FMULT           ;EVALUATE THE POLY, MULTIPLY BY X
        POP     H               ;GET LOCATION OF CONSANTS
        CALL    MOVRM           ;GET CONSTANT
        PUSH    H               ;STORE LOCATION OF CONSTANTS SO FADD AND FMULT
        CALL    FADD            ; WILL NOT SCREW THEM UP, ADD IN CONSTANT
        POP     H               ;MOVE CONSTANT POINTER TO NEXT CONSTANT
        JMP     POLY1>          ;SEE IF DONE
        ;PSEUDO-RANDOM NUMBER GENERATOR
        ;IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED
        ;IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS STARTED
        ; USING THE ARGUMENT    ;;
        ;TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE, WE MULTIPLY THE
        ;PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT, AND ADD IN ANOTHER
        ;RANDOM CONSTANT.  THEN THE HO AND LO BYTES ARE SWITCHED, THE
        ;EXPONENT IS PUT WHERE IT WILL BE SHIFTED IN BY NORMAL, AND THE
        ;EXPONENT IN THE FAC SET TO 200 SO THE RESULT WILL BE LESS THAN 1.
        ;THIS IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
        ;THE HO AND LO BYTES WERE SWITCHED SO WE HAVE A RANDOM CHANCE OF
        ;GETTING A NUMBER LESS THAN OR GREATER THAN .5
RND:
IFN     LENGTH-2,<
        FSIGN>                  ;GET SIGN OF ARG
IFE     LENGTH-2,<
        CALL    VSIGN           ;GET THE SIGN OF THE ARG
        PUSH    PSW             ;SAVE THE SIGN
        CM      FRCSNG          ;IF IT IS NEGATIVE, FORCE IT TO BE A SNG
        MVI     A,4             ; SINCE WE WILL USE IT
        STA     VALTYP          ;MAKE SURE THE RESULT IS "SINGLE PRECISION"
        POP     PSW>            ;GET THE SIGN BACK
        JM      RND1            ;START NEW SEQUENCE IF NEGATIVE
        LXI     H,RNDX          ;GET LAST NUMBER GENERATED
        CALL    MOVFM
        RZ                      ;RETURN LAST NUMBER GENERATED IF ZERO
IFE     EXTFNC,<
        CALL    FMULTS>         ;MULTIPLY BY CONSTANT A
IFN     EXTFNC,<
        CALL    MOVRM
        CALL    FMULT>
        MOVRI   150,050,261,106 ;ADD IN CONSTANT OF ORDER 2^(-24)
        CALL    FADD
RND1:   CALL    MOVRF           ;SWITCH HO AND LO BYTES
        MOV     A,E             ;GET LO
        MOV     E,C             ;PUT HO IN LO BYTE
        MOV     C,A             ;PUT LO IN HO BYTE
        MVI     M,200           ;MAKE RESULT POSITIVE
        DCX     H               ;GET POINTER TO EXPONENT
        MOV     B,M             ;PUT EXPONENT IN OVERFLOW POSITION
        MVI     M,200           ;SET EXP SO RESULT WILL BE BETWEEN 0 AND 1
        CALL    NORMAL          ;NORMALIZE THE RESULT
        LXI     H,RNDX          ;SAVE RANDOM NUMBER GENERATED FOR NEXT
        JMP     MOVMF           ; TIME
        ;CONSTANTS AND STORAGE FOR RND
RNDX:   122     ;LAST RANDOM NUMBER GENERATED, BETWEEN 0 AND 1
        307
        117
        200
        172     ;RANDOM NUMBER OF ORDER 2^24
        104
        065
        230
PAGE
SUBTTL  SINE, COSINE AND TANGENT FUNCTIONS
IFN     EXTFNC,<
        ;COSINE FUNCTION
        ;IDEA:  USE COS(X)=SIN(X+PI/2)
COS:    LXI     H,PI2           ;ADD PI/2 TO FAC
        CALL    FADDS>
                                ;FALL INTO SIN
        ;SINE FUNCTION
        ;IDEA: USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV
        ;THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED BECAUSE
        ;SIN(X+2*PI)=SIN(X).  THEN THE ARGUMENT CAN BE COMPARED WITH PI/2 BY
        ;COMPARING THE RESULT OF THE DIVISION WITH PI/2/(2*PI)=1/4.
        ;IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS I OR IV.
        ;AN APPROXIMATION POLYNOMIAL IS THEN USED TO COMPUTE SIN(X).
SIN:    CALL    PUSHF           ;DIVIDE FAC BY 2*PI
        MOVRI   203,111,017,333 ;AFTER DIVIDING BY 2*PI, RESULT IS
        CALL    MOVFR           ; BETWEEN 0 AND 1
        POPR
        CALL    FDIV
        CALL    PUSHF           ;DISREGARD INTEGER PART SINCE SIN
        CALL    INT             ; IS PERIODIC WITH PERIOD 2*PI
        POPR
        CALL    FSUB
IFE     EXTFNC,<
        LXI     B,177*400+$CODE ;GET 1/4
        MOV     D,C
        MOV     E,C
        CALL    FSUB>
IFN     EXTFNC,<
        LXI     H,FR4           ;SEE WHAT QUADRANT WE ARE IN
        CALL    FSUBS>
        FSIGN
        STC                     ;SEE EQUADRANT I FLAG
        JP      SIN1            ;FIRST QUADRANT, GET BACK ORIGINAL X
        CALL    FADDM           ;ADD 1/2
        FSIGN
        ORA     A               ;CLEAR CARRY
SIN1:   PUSH    PSW             ;SAVE QUADRANT FLAG
        CP      NEG             ;NEGATE IF IN QUADRANTS I, II, OR III
IFE     EXTFNC,<
        LXI     B,177*400+$CODE ;GET 1/4
        MOV     D,C
        MOV     E,C
        CALL    FADD>
IFN     EXTFNC,<
        LXI     H,FR4           ;ADD 1/4.  IN QUADRANTS II, III
                                ; USE THE IDENTITY: SIN(PI-X)=SIN(X)
                                ;IN QUADRANT IV, USE THE IDENTITY:
        CALL    FADDS>          ;   SIN(X-2*2)=SIN(X)
        POP     PSW             ;GET QUADRANT FLAG
        CNC     NEG             ;NEGATE IF IN QUADRANTS II, III OR IV
IFE     EXTFNC,<                ;EVALUATE APPROXIMATION POLYNOMIAL
        CALL    PUSHF           ;SAVE X
        CALL    MOVRF           ;SQUARE X
        CALL    FMULT
        CALL    PUSHF           ;SAVE X^W
        LXI     H,SINCON
        CALL    MOVFM           ;MOVE FIRST CONSTANT INTO FAC
        POPR                    ;GET X^2
        MVI     A,4             ;GET DEGREE
POLY1:  PUSH    PSW             ;SAVE DEGREE
        PUSHR                   ;SAVE X^2
        PUSH    H               ;SAVE CONSTANT POINTER
        CALL    FMULT           ;EVALUATE THE POLY, MULTIPLY BY X^2
        POP     H               ;GET POINTER TO CONSTANTS
        CALL    MOVRM           ;GET CONSTANT
        PUSH    H               ;SAVE POINTER
        CALL    FADD            ;ADD IN CONSTANT
        POP     H               ;MOVE POINTER TO NEXT CONSTANT
        POPR                    ;GET X^2
        POP     PSW             ;GET DEGREE
        DCR     A               ;SEE IF DONE
        JNZ     POLY1           ;NO, DO NEXT TERM
        JMP     FMULTT>         ;MULTIPLY BY X AND WE ARE DONE
IFN     EXTFNC,<
        LXI     H,SINCON        ;CALCUALTE THE SIN BY EVALUATING
        JMP     POLYX           ; THE APPROXIMATION POLYNOMIAL
        ;CONSTANTS FOR SIN, COS
IFN     EXTFNC,<
PI2:    333     ; PI/2
        017
        111
        201
FR4:    000     ; 1/4
        000
        000
        177>
SINCON:
IFN     EXTFNC,<
        5>      ;DEGREE
        272     ; 39.701067
        327
        036
        206
        144     ; -76.57498
        046
        231
        207
        130     ; 81.60223
        064
        043
        207
        340     ; -41.34168
        135
        245
        206
        332     ; 6.283185
        017
        111
        203
IFN     EXTFNC,<
        ;TANGENT FUNCTION
        ;TAN(X)=SIN(X)/COS(X)
TAN:    CALL    PUSHF           ;SAVE ARG
        CALL    SIN             ;   TAN(X)=SIN(X)/COS(X)
        POP     B               ;GET X OFF STACK
        POP     H               ;PUSHF SMASHES (DE)
        CALL    PUSHF
        XCHG                    ;GET LO'S WHERE THEY BELONG
        CALL    MOVFR
        CALL    COS
        JMP     FDIVT>
PAGE
SUBTTL  ARCTANGENT FUNCTION
IFN     EXTFNC,<
        ;IDEA: USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
        ;AN APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X)
ATN:    FSIGN                   ;SEE IF ARG IS NEGATIVE
        CM      PSHNEG          ;IF ARG IS NEGATIVE, USE:
        CM      NEG             ;   ARCTAN(X)=-ARCTAN(-X)
        LDA     FAC             ;SEE IF FAC .GT. 1
        CPI     201
        JC      ATN2
        LXI     B,201*400+$CODE ;GET THE CONSTANT 1
        MOV     D,C
        MOV     E,C             ;COMPUTE RECIPROCAL TO USE THE IDENTITY:
        CALL    FDIV            ;  ARCTAN(X)=PI/2-ARCTAN(1/X)
        LXI     H,FSUBS         ;PUT FSUBS ON THE STACK SO WE WILL RETURN
        PUSH    H               ; TO IT AND SUBTRACT THE REULT FROM PI/2
ATN2:   LXI     H,ATNCON        ;EVALUATE APPROXIMATION POLYNOMIAL
        CALL    POLYX
        LXI     H,PI2           ;GET POINTER TO PI/2 IN CASE WE HAVE TO
        RET                     ; SUBTRACT THE RESULT FROM PI/2
        ;CONSTANTS FOR ATN
ATNCON: 11      ;DEGREE
        112     ; .002866226
        327
        073
        170
        002     ; -.01616574
        156
        204
        173
        376     ; .04290961
        301
        057
        174
        164     ; -.07528964
        061
        232
        175
        204     ; .1065626
        075
        132
        175
        310     ; -.142089
        177
        221
        176
        344     ; .1999355
        273
        114
        176
        154     ; -.3333315
        252
        252
        177
        000     ; 1.0
        000
        000
        201>
PAGE
SUBTTL  SYSTEM INITIALIZATION CODE
RADIX   10              ;IN ALL NON-MATH PACKAGE CODE
;THIS IS THE SYSTEM INITIALIZATION CODE
;IT SHOULD BE LOADED AT THE END OF THE BASIC
;INTERPRETER
INTERNAL        INIT
EXTERNAL        CRDO,LINGET,QINLIN,READY,SCRTCH,STROUT,REASON,BUF
EXTERNAL        SNERR,OMERR,ILLFUN
FUNIO==<^D256*^O312>+^O40+$CODE
INITSA: BLOCK   10
INITAT: LXI     H,AUTTXT
        CALL    STROUT
INIT:
IFN     REALIO,<
        IN      1               ;IGNORE GARBAGE CHARACTER IN INTERFACE
        IN      ^D255           ;SEE WHAT KIND OF I/O HE IS
        ANI     ^O100           ;IS HE FUNNY TTY?
        JZ      NOTSIO
        LXI     H,FUNIO
        SHLD    CNLCA2##+2
        MVI     H,^O310
        SHLD    CNLCA3##+2
IFN     LENGTH,<
        MVI     H,^O304         ;SUBSTITUE "CNZ"
        SHLD    CNLCA4##+2>
FUNIO==$CODE+<^D256*^O312>+2
        LXI     H,FUNIO
        SHLD    CNLCA1##+2
NOTSIO: IN      ^D255
        ANI     ^O40
        JZ     NOTPIO
FUNIO==$CODE+<^D256*^O312>+2
        LXI     H,FUNIO
        SHLD    CNLCA2+2
        MVI     H,^O310
        SHLD    CNLCA3+2
IFN     LENGTH,<
        MVI     H,^O304
        SHLD    CNLCA4+2>
FUNIO==$CODE+<^D256*^O312>+1
        LXI     H,FUNIO
        SHLD    CNLCA1+2
NOTPIO:>
        LXI     H,$CODE+^D65535
        SHLD    CURLIN##        ;IN CASE OF ERROR
        LXI     H,TSTACK        ;SET UP TEMP STACK
        SPHL
        SHLD    STKTOP##
IFN     CONTRW,<
        XRA     A
        STA     CNTWFL##>
        CALL    CRDO            ;TYPE A CR
IFN     STRING,<
        LXI     H,TEMPST##
        SHLD    TEMPPT##>
IFN     REALIO,<
        LXI     H,MEMORY        ;ASK HOW MUCH MEMORY AVAILABLE
        CALL    STROUT          ;CALL THE STRING PRINTER
        CALL    QINLIN          ;GET A LINE OF INPUT
        CHRGET                  ;GET A CHAR
        CPI     "A"
        JZ      INITAT
        ORA     A
        JNZ     USEDE9          ;NON ZERO, DONT USE DEFAULT
        LXI     H,LASTWR
LOOPMM: INX     H
        MVI     A,311
        MOV     M,A
        CMP     M
        JNZ     USEDEF
        DCR     A
        MOV     M,A
        CMP     M
        JZ      LOOPMM
        JMP     USEDEF
USEDE9: LXI     H,BUF
        CALL    LINGET          ;GET DECIMAL AMOUNT OF MEMORY IN [D,E]
        ORA     A
        JNZ     SNERR           ;MAKE SURE HE HAS A TERMINATOR
        XCHG
        DCX     H
USEDEF: DCX     H>
IFE     REALIO,<
        LXI     H,$CODE+16190>
        PUSH    H               ;ALSO SAVE FOR LATER
TTYW:   LXI     H,TTYWID
        CALL    STDOUT
        CALL    QINLIN
        CHRGET
        ORA     A
        JZ      DFLENT
        LXI     H,BUF
        CALL    LINGET
        MOV     A,D
        ORA     A
        JNZ     TTYW
        MOV     A,E
        CPI     16
        JC      TTYW
        STA     LINPT1##        ;DECLARE LINPT1 EXTERNAL
IFN     LENGTH,<
        STA     LINPT2##
IFN     STRING,<
        STA     LINPT3##>
MORCPS: SUI     14
        JNC     MORCPS
        ADI     28
        CMA
        INR     A
        ADD     E
        STA     LINPT4##
DFLENT:
IFN     STRING,<                ;SET UP DEFAULT STRING SPACE
        LXI     D,$CODE+^D65536-^D50+1
        POP     H
        SHLD    MEMSIZ##        ;SAVE IN REAL MEMORY SIZE
        SHLD    FRETOP##        ;STRINGS START FROM HERE DOWN
        DAD     D               ;CALC STRBOT BY SUBTRACTING 200 FROM STKTOP
        JNC     OMERR           ;MUST BE POSITIVE
        DCX     H               ;ONE LOWER IS STKTOP
        PUSH    H>              ;SAVE IT ON STACK
IFE     EXTFNC,<

; FUNCTION DELETION ROUTINE FOR 4K MACHINE
; TO ADD A NEW FUNCTION JUST UPDATE TBLDO

ASKAGN: LXI     H,TBLDO         ;START OF FUNCTION TABLE
LOPASK: PUSHM                   ;PUT ON CANDIDATE FOR START OF FREE MEMORY
        LXI     D,TBDASK        ;DONE ASKING?
        COMPAR
        JZ      FINFUN          ;YES, GET FIRST FREE MEM LOC
                                ;INTO [D,E] AND QUIT
        PUSHM                   ;PUT ON MESSAGE LOCATION
        XTHL                    ;[H,L]=MESSAGE POINTER
                                ;POINTER INTO TBLDO GOES ON THE STACK
        CALL    STROUT          ;PRINT THE MESSAGE
        CALL    QINLIN          ;SEE WHAT HE HAS TO SAY
        CHRGET                  ;SEE WHAT THE FIRST CHARACTER OF INPUT WAS
        POP     H               ;POP OFF POINTER INTO TBLDO
        CPI     "Y"
FINFUN: POP     D               ;POP OFF CANDIDATE FOR START OF
                                ;FREE MEMORY
        JZ      HAVFNS          ;HE WANTS IT SO WE ARE DONE
        CPI     "N"             ;IF A BAD ANSWER
        JNZ     ASKAGN          ;MAKE HIM START OVER
        PUSHM                   ;PUSH ON FUNCTION CALL
                                ;LOCATION THAT WE FIX UP
        XTML                    ;[H,L]=FIXUP PLACE
                                ;POINTER INTO TBLDO GOES ON THE STACK
        LXI     D,ILLFUN        ;THIS IS WHAT WE STORE
        MOV     M,E
        INX     H
        MOV     M,D
        POP     H               ;GET TBLDO POINTER
        JMP     LOPASK>         ;GO ASK AGAIN FOR ANOTHER FUNCTION
IFN     EXTFNC,<
ASKAGN: LXI     H,FNS           ;ASK IF WANTS SIN, COS, ATN
        CALL    STROUT          ;THE STRING
        CALL    QINLIN
        CHRGET
        CPI     "Y"
        LXI     D,INITSA        ;ASSUME NOT DELETE ANY FNS
        JZ      HAVFNS          ;YUP.
        CPI     "A"
        JZ      OKCHAR
        CPI     "N"
        JNZ     ASKAGN
OKCHAR: LXI     H,ILLFUN        ;MAKE SURE BOMBS IF TRIES TO CALL THEM
        LXI     D,ATN
        SHLD    ATNFIX##
        CPI     "A"             ;DELETE ATN BUT NOT SIN, COS?
        JZ      HAVFNS          ;TEST
        SHLD    COSFIN##
        SHLD    TANFIX##
        SHLD    SINFIX##
        LXI     D,COS>
HAVFNS:                         ;TEXT ALWAYS PRECEDED BY ZERO
        XCHG                    ;PUT BOTTOM OF MEMORY IN [H,L]
        MVI     M,0             ;STORE IT
        INX     H               ;INCREMENT POINTER
        SHLD    TXTTAB##        ;SAVE BOTTOM OF MEMORY
        XTHL
        LXI     D,TSTACK
        COMPAR
        JC      OMERR
        POP     D
        SPHL
        SHLD    STKTOP
        XCHG
        CALL    REASON
        MOV     A,E             ;SUBTRACT VARTAB FROM STKTOP
        SUB     L               ;LOW PART
        MOV     L,A             ;
        MOV     A,D             ;HIGH PART
        SBB     H               ;
        MOV     H,A             ;LEAVE IN [B,C]
        LXI     B,$CODE+65520
        DAD     B
        CALL    CRDO            ;TYPE CRLF
        CALL    LINPRT          ;PRINT # OF BYTES FREE
        LXI     H,WORDS         ;TYPE THE HEADING
        CALL    STROUT          ;"ALTAIR BASIC VERSION-----"
        LXI     H,STROUT
        SHLD    REPINI##+1
        CALL    SCRTCH          ;NOW SET UP EVERYTHING ELSE
IFN     LPTSW,<
        MVI     A,4
        OUT     2               ;CLEAR THE LPT
        XRA     A
        STA     PRTFLG##
        STA     LPTPOS##>
IFE     CONSSW,<LXI     H,READY>
IFN     CONSSW,<
        LXI     H,CONSDO##>
        SHLD    $CODE+2
        PCHL
IFE     EXTFNC,<
TBLDO:  ADR(INITSA)
        ADR(FNS)
        ADR(SINFIX)
        ADR(SIN)
        ADR(FN2)
        ADR(RNDFIX)
        ADR(RND)
        ADR(FNS3)
        ADR(SQRFIX)
        ADR(SQR)
TBDASK:                         ;END OF ASK TABLE
FNS:    DC"WANT SIN"
        0
FNS2:   DC"WANT RND"
        0
FNS3:   DC"WANT SQR"
        0>
IFN     EXTFNC,<
FNS:    DC"WANT SIN-COS-TAN-ATN"
        0>
AUTTXT: ACRLF
        ^D10
        DC"WRITTEN BY BILL GATES & PAUL ALLEN & MONTE DAVIDOFF."
        ACRLF
        0
TTYWID: DC"TERMINAL WIDTH"
        0
WORDS:  DC" BYTES FREE"
        ACRLF
        ACRLF
        DC"ALTAIR BASIC VERSION 3.0"
        ACRLF
IFE     LENGTH,<DC"[FOUR-K VERSION]">
IFE     LENGTH-1,<DC"[EIGHT-K VERSION">
IFE     LENGTH-2,<DC"[BIG VERSION]">
        ACRLF
        0
MEMORY: DC"MEMORY SIZE"
        0
LASTWR::                        ;LAST WORD OF SYSTEM CODE+1
        BLOCK   ^D30            ;SPACE FOR TEMP STACK
TSTACK::
IFE     LENGTH,<
        BLOCK   ^D13000>
IFN     LENGTH,<
        BLOCK   ^D10000>
        .C2==:.P
END
