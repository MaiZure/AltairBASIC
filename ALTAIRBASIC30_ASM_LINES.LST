00100   SEARCH  MCS808                  ;THE UNIVERSAL FILE
00200   SUBTTL  COMMON FILE
00300   SALL
00400   LENGTH==2                       ; 0 MEANS 4K, 1 MEANS 8K, 2 MEANS 12K
00500   REALIO==1
00600   CASSW==0                        ;CASSETTE SWITCH (CSAVE,CLOAD)
00700   PURE==0                         ;ON FOR PURE CODE
00800   LPTSW==0
00900   DSKFUN==0                       ;ON TO READ/WRITE
01000   CONSSW==0
01200   CLMWID==^D14                    ;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
01300   RAMBOT=^O20000                  ;BOTTOM LOCATION OF RAM FOR PURE SWITCH
01400   CONTRW==1                       ;ALLOW ^O
01500   IFE     REALIO,<
01600           LPTSW==0                ;SIMULATOR DEFAULTS
01700           CASSW==0
01800           CONSSW==0
01900           DSKFUN==0
02000           CONTRW==0>
02200   IFE     LENGTH,<
02300           EXTFNC==0               ;ON MEANS EXTENDED FUNCTIONS
02400           MULDIM==0               ;ON MEANS MULTIPLE DIMENSIONED ARRAYS ALLOWED
02500           STRING==0               ;ON MEANS STRINGS ALLOWED
02600           CASSW==0
02700           LPTSW==0
02800           DSKFUN==0
02900           CONSSW==0
03000           CONTRW==0>
03200   IFE     LENGTH-1,<
03300           EXTFUN==1
03400           MULDIM==1
03500           STRING==1>
03700   IFE     LENGTH-2,<
03800           EXTFUN==1
03900           MULDIM==1
04000           STRING==1>
04200   DEFINE  SYNCHK(A),<RST  1
04300                   A>
04400   DEFINE  CHRGET,<RST     2>
04500   DEFINE  OUTCHR,<RST     3
04600   DEFINE  COMPAR,<RST     4
04700   DEFINE  FSIGN,<RST      5
04800   DEFINE  PUSHM,<RST      6
04900   DEFINE  PUSHFM,<PUSHM
05000                   PUSHM>
05100   DEFINE  ACLRF,<
05200           ^D13
05300   IFN     STRING,<^D10>>
05400   DEFINE  PUSHR,<
05500           PUSH    D
05600           PUSH    B>
05700   DEFINE  POPR,<
05800           POP     B
05900           POP     D>
06000   DEFINE  MOVRI(B,C,D,E),<
06100           XWD     ^O1000,^O001    ;; "LXI B"
06200           EXP     C
06300           EXP     B
06400           XWD     ^O1000,^O021    ;; "LXI D
06500           EXP     E
06600           EXP     D>
06800   IF1,<
06900   IFE     LENGTH,<PRINTX  /SMALL/>
07000   IFE     LENGTH-1,<PRINTX        /MEDIUM/>
07100   IFE     LENGTH-2,<PRINTX        /BIG
07200   IFE     REALIO,<PRINTX  /SIMULATE/>
07300   IFN     REALIO,<PRINTX  /ON MACHINE/>
07400   IFN     CASSW,<PRINTX   /CASSETTE/>
07500   IFN     PURE,<PRINTX    /PURE/>
07600   IFN     LPTSW,<PRINTX   /LPT/>
07700   IFN     DSKFUN,<PRINTX  /DISK/>
07800   IFN     CONSSW,<PRINTX  /CONSOLE/>>
07900   PAGE
00020   SUBTTL  VERSION 3.0 -- MORE FEATURES TO GO
00040   TITLE   BASIC MCS 8080  GATES/ALLEN/DAVIDOFF
00060   IFNDEF  LENGTH,<PRINTX !!! MUST HAVE COM !!!
00080           END>
00100   MCSSIM(START)
00120   COMMENT *
00160   --------- ---- -- ---- ----- --- ---- -----
00180   COPYRIGHT 1975 BY BILL GATES AND PAUL ALLEN
00200   --------- ---- -- ---- ----- --- ---- -----
00260   ORIGINALLY WRITTEN ON THE PDP-10 FROM
00280   FEBRUARY 9 TO  APRIL 9
00320   BILL GATES WROTE THE RUNTIME STUFF.
00340   PAUL ALLEN WROTE THE NON-RUNTIME STUFF.
00360   MONTE DAVIDOFF WROTE THE MATH PACKAGE.
00400   THINGS TO DO:
00420   GOSUB / INPUT BUG  (BUF SMASH)
00440   PRINT PUNCTUATION MANDATORY
00460   MULTIPLE LET
00480   RESTART AT 0 SHOULD  GO THROUGH  STKINI
00500   USER DEFINED FUNCTIONS(MULTI-ARG,MULTI-LINE,STRINGS)
00520   MAKE STACK BOUNDARY STUFF EXACT
00540   PUNCH,RENUMBER...
00560   INLINE CONSTANT CONVERSION--MAKE IT WORK
00580   *
00600   RADIX 10                        ;THROUGHOUT
00620   .P==0                           ;FOR SIMULATOR FIXUPS
00640   NUMLEV==17+LENGTH*2             ;NUMBER OF STACK LEVELS RESERVED
00660                                   ;WITH AN EXPLICIT CALL TO GETSTK
00680   LPTLEN==72                      ;WIDTH OF LINE-PRINTER
00700   LINLEN==72                      ;TELETYPE LINE LENGTH
00720   BUFLEN==72                      ;INPUT BUFFER SIZE
00740   STRSIZ==4
00760   IFE     LENGTH-2<STRSIZ==3>
00780   NUMTMP==3                       ;NUMBER OF STRING TEMPORARIES
00800   IFE     LENGTH-2,<NUMTMP=5>
00820   CR==13
00840   CONTW==15                       ;CHARACTER TO SUPRESS OUTPUT
00860   ODONE==128                      ;BIT FOR OUTPUT DONE
00880   IDONE==1                        ;BIT FOR INPUT DONE
00900   TTOCHN==1                       ;TELETYPE OUTPUT CHANNEL
00920   TTICHN==1                       ;TELETYPE INPUT CHANNEL
00960   LISTEN==0                       ;ON MEANS LISTEN FOR ^C
01000   FUNCTS==1                       ;ON MEANS USER FUNCTIONS ALLOWED
01020                                   ;! CANNOT BE ON WITH LENGTH=0 (SUBFLG)
01040   IFN     REALIO,<
01060   LISTEN==1>
01080   IFE     LENGTH,<
01120   FUNCTS==0>
01200   INTERNAL        .C1,BUF,READY,REASON,SNERR,EMERR,REPINI
01220   INTERNAL        STREND,CURLIN,DV0ERR,ERROV
01240   IFN     REALIO,<
01260   INTERNAL        CNLCA1,CNLCA2,CNLCA3>
01280   IFN     EXTFNC,<INTERNAL        ATNFIX,COSFIX,SINFIX,TANFIX
01300   EXTERNAL        FPWR,EXP>
01320   EXTERNAL        QINT,ZERO,MOVE,FOUT,FIN,FCOMP,FADD,PUSHF,INT,INIT
01340   EXTERNAL        MOVFR,MOVRF,MOVRM,INPRT,LINPRT
01360   EXTERNAL        MOVFM,MOVMF,TSTACK,FLOATRI,FADDS
01380   INTERNAL        ILLFUN,FAC,FACLD,TXTTAB,STROUT,SCRTCH
01400   EXTERNAL        INRART,NEG,FLOAT
01420   INTERNAL        OUTDO,STROUI
01440   INTERNAL        STKTOP,ERROR,FCERR
01460   IFN     STRING,<
01462   INTERNAL         VALTYP,TEMPPT
01464   INTERNAL        TEMPST,STRLIT
01466   IFN     LENGTH-2,<
01468   INTERNAL        TMERR>
01480   INTERNAL        MEMZIS,FRETOP
01500   EXTERNAL        SIGNS>
01520   INTERNAL        FBUFFR,MINUTK,PLUSTK,CRDO,LINGET,INTXT,QINLIN
01540   IFN     MULDIM,<INTERNAL        BSERR>
01560   IFN     MULDIM,<EXTERNAL        UMULT>
01580   IFE     LENGTH,<INTERNAL        RNDFIX,SQRFIX,SINFIX>
01600   INTERNAL        SIGN
01620   EXTERNAL        SIGNC,POPHRT
01640   IFN     CONTRW,<
01660   INTERNAL        CNTWFL>
01680   IFN     LPTSW,<
01700           INTERNAL        LPTPOS,PRTFLG>
01720   IFE     LENGTH-2,<
01730   EXTERNAL        CONSIH,VMOVFA,VMOVAF,ISIGN,FPWRQ,CONIA,GETBCD,VSIGN
01740   EXTERNAL        VMOVMF,VMOVFM,FRCINT,FRCSNG,FRCDBL,VNEG,PUFOUT,DCXBRT,IADD
01760   EXTERNAL        ISUB,IMULT,IDIV,ICOMP,INEG,DADD,DSUB,DMULT,DDIV,DCOMP,VINT
01780   EXTERNAL        TMERR,VMOVE,VALINT,VALSNG,FRCSTR,CHKSTR,MAKINT
01800   INTERNAL        DFACLO,ARG,ARGLO,VALTYP,ERRTM,TEMP2,TEMP3,GETYPE>
01820   PAGE
01840   SUBTTL  SOME EXPLANATION
01880   COMMENT *
01920   ALTAIR BASIC CONFIGURES MEMORY AS FOLLOWS:
01960   LOW LOCATIONS
02000           RST     SUBROUTINES
02040                   0       STARTUP
02060                           INITIALLY A JMP TO THE INITIALIZATION CODE
02080                           BUT CHANGED TO A JMP TO READY.
02100                           RESTARTING THE MACHINE AT 0 DURING PROGRAM
02120                           EXECUTION CAN LEAVE THINGS MESSED UP.
02160                   1       SYNCHK
02180                           A CHECK IS MADE TO MAKE SURE THE
02200                           CHARACTER POINTER POINTS AT A SPECIFIC
02220                           CHARACTER. IF NOT THE "SYNTAX ERROR"
02240                           ROUTINE IS CALLED. IF SO,
02260                           THE CHRGET RST IS DROPPED INTO SO
02280                           THE CHARACTER AFTER THE MATCHED
02300                           ONE WILL BE PUT IN [A] AND
02320                           THE CONDITION CODES WILL REFLECT THIS
02340                           EXAMPLE: SYNCHK THENTK (THE MATCH CHARACTER IS
02360                           GIVEN IN THE LOCATION AFTER THE RST)
02380                           WOULD CHECK TO MAKE SURE [H,L] POINTED TO A THENTK
02400                           AND IF SO FETCH THE NEXT CHARACTER INTO [A]
02420                           IF NOT, A "SYNTAX ERROR" WOULD BE GIVEN.
02460                   2       CHRGET
02480                           USING [H,L] AS THE TEXT POINTER
02500                           THE TEXT POINTER IS INCREMENTED
02520                           AND THE NEXT CHARACTER IS FETCHED INTO [A]
02540                           IF THE CHARACTER IS A " " IT IS SKIPPED
02560                           OVER AND THE NEXT CHARACTER IS FETCHED,
02580                           THE STATEMENT TERMINATIONS ":" AND 0
02600                           LEAVE THE ZERO FLAG SET.
02620                           THE NUMERICS "0" THROUGH "9" LEAVE THE CARRY
02640                           FLAG SET. THE CURRENT CHARACTER CAN BE
02660                           REFETCHED INTO [A] BY DOING A MOV A,M.
02680                           IF THE CONDITION CODES MUST BE SET UP AGAIN
02700                           DCX H,CHRGET WILL WORK. IT IS VERY DIFFICULT
02720                           TO REEXAMINE THE CHARACTER BEFORE THE CURRENT
02740                           ONE SINCE SPACES MAY BE IN-BETWEEN.
02760                           DCX H,DCX M,CHRGET WILL NOT ALWAYS WORK.
02800                   3       OUTCHR
02820                           THE CHARACTER IN [A] IS PRINTED ON
02840                           THE USER'S TERMINAL. [A] AND THE
02860                           CONDITION CODES ARE PRESERVED
02900                   4       COMPAR
02920                           [D,E] AND [H,L] ARE COMPARED AS UNSIGNED
02940                           DOUBLE-BYTE INTEGERS. CARRY IS SET IF
02960                           [H,L] IS LESS THAN [D,E]. ZERO IS SET IF THEY
02980                           ARE EQUAL. [A] IS SMASHED. THE ONLY DEFINITE
03000                           THING THAT CAN BE SAID ABOUT [A] ON RETURN
03020                           IS THAT IF THE ZERO FLAG IS SET, [A] WILL
03040                           EQUAL 0.
03080                   5       FSIGN
03100                           THE FAC (FLOATING ACCUMULATOR)
03120                           WHICH IS USED TO STORE NUMERIC RESULTS
03140                           IS CHECKED TO SEE WHAT SIGN ITS
03160                           VALUE HAS.
03200                   6       PUSHM
03220                           A DOUBLE BYTE QUANTITY POINTED
03240                           TO BY [H,L] IS PUSHED ONTO THE
03260                           STACK, [B,C] IS SET EQUAL TO THE
03280                           VALUE PUSHED, [H,L] IS INCREMENTED BY TWO
03320                   7       IN THE 4K VERSION RST 7 IS UNUSED AND THE LOCATIONS
03340                           ASSOCIATED WITH IT ARE USED TO CONTINUE
03360                           THE CODE FOR RST 6. IN THE 8K A JMP IS MADE
03380                           AROUND THE FIRST THREE RST 7 LOCATIONS
03400                           DURING RST 6 EXECUTION, RST 7 INITIALLY
03420                           CONTAINS A RET, BUT THE USER CAN CHANGE IT TO
03440                           A JMP TO AN INTERRUPT SERVICE ROUTINE.
03480           FUNCTION DISPATCH ADDRESSES
03500                   FUNDSP CONTAINS THE ADDRESSES OF THE
03520                   FUNCTION ROUTINES IN THE ORDER OF THE
03540                   FUNCTION NAMES IN THE CRUNCH LIST.
03560                   THE FUNCTIONS THAT TAKE MORE THAN ONE ARGUMENT
03580                   ARE AT THE END. SEE THE EXPLANATION AT ISFUN.
03620           THE OPERATOR TABLE
03640                   THE OPTAB TABLE CONTAINS AN OPERATORS PRECEDENCE
03660                   FOLLOWED BY THE ADDRESS OF THE ROUTINE TO PERFORM
03680                   THE OPERATION. THE INDEX INTO THE
03700                   OPERATOR TABLE IS MADE BY SUBTRACTING OFF THE CRUNCH VALUE
03720                   OF THE LOWEST NUMBERED OPERATOR. THE ORDER
03740                   OF OPERATORS IN THE CRUNCH LIST AND IN OPTAB IS IDENTICAL.
03760                   THE PRECEDENCES ARE ARBITRARY,EXCEPT FOR THEIR
03780                   COMPARATIVE SIZES. NOTE THAT THE PRECENDENCE FOR
03800                   UNARY OPERATORS SUCH AS NOT AND NEGATION ARE
03820                   SETUP SPECIALLY WITHOUT USING A TABLE.
03860           THE RESERVED WORD ON CRUNCH LIST
03880                   WHEN A COMMAND OR PROGRAM LINE IS TYPED IN
03900                   IT IS STORED IN BUF. AS SOON AS THE WHOLE LINE
03920                   HAS BEEN TYPED IN (INLIN RETURNS) CRUNCH IS
03940                   CALLED TO CONVERT ALL RESERVED WORDS TO THEIR
03960                   CRUNCH VALUES, THIS REDUCES THE SIZE OF THE
03980                   PROGRAM AND SPEEDS UP EXECUTION BY ALLOWING
04000                   TABLE DISPATCHES TO PERFORM FUNCTIONS,STATEMENTS,
04020                   AND OPERATIONS. THIS IS BECAUSE ALL THE STATEMENT
04040                   NAMES ARE STORED CONSECUTIVELY IN THE CRUNCH LIST.
04060                   WHEN A MATCH IS FOUND BETWEEN A STRING
04080                   OF CHARACTERS AND A WORD IN THE CRUNCH LIST
04100                   THE ENTIRE TEXT OF THE MATCHED WORD IS TAKEN OUT OF
04120                   THE INPUT LINE AND RESERVED WORD TAKEN IS PUT
04140                   IN ITS PLACE. A RESERVED WORD TOKEN IS ALWAYS EQUAL
04160                   TO OCTAL 200 PLUS THE POSITION OF THE MATCHED WORD
04180                   IN THE CRUNCH LIST.
04220           STATEMENT DISPATCH ADDRESSES
04240                   WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
04260                   CHARACTER OF THE STATEMENT IS EXAMINED
04280                   TO SEE IF IT IS LESS THAN THE RESERVED
04300                   WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME,
04320                   IF SO, THE "LET" CODE IS CALLED TO
04340                   TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
04360                   OTHERWISE A CHECK IS MADE TO MAKE SURE THE
04380                   RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
04400                   STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
04420                   TO DISPATCH TO IS FETCHED FROM STMDSP (THE STATEMENT
04440                   DISPATCH TABLE) USING THE RESERVED WORD
04460                   NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
04480                   THE TABLE.
04520           ERROR MESSAGES
04540                   WHEN AN ERROR CONDITION IS DETECTED
04560                   [E] MUST BE SET UP TO INDICATE WHICH ERROR
04580                   MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
04600                   TO ERROR. THE STACK WILL BE RESET AND ALL
04620                   PROGRAM CONTEXT WILL BE LOST. VARIABLES
04640                   VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
04660                   ONLY THE VALUE OF [E] IS IMPORTANT WHEN
04680                   THE BRANCH IS MADE TO ERROR, [E] IS USED AS AN
04700                   INDEX INTO ERRTAB WHICH GIVES THE TWO
04720                   CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
04740                   USER'S TERMINAL.
04780           IMPURE STORAGE
04800                   ALL TEMPORARIES,FLAGS,POINTERS, THE BUFFER AREA,
04820                   THE FLOATING ACCUMULATOR,AND ANYTHING ELSE THAT
04840                   IS USED TO STORE A CHANGING VALUE SHOULD BE LOCATED
04860                   IN THIS AREA. CARE MUST BE MADE IN MOVING LOCATIONS
04880                   IN THIS AREA SINCE THE JUXTAPOSITION OF TWO LOCATIONS
04900                   IS OFTEN DEPENDED UPON.
04940           TEXTUAL MESSAGES
04960                   CONSTANT MESSAGES ARE STORED HERE. UNLESS
04980                   THE CODE TO CHECK IF A STRING MUST BE COPIED
05000                   IS CHANGED THESE STRINGS MUST BE STORED ABOVE
05020                   DSCTMP, OR ELSE THEY WILL BE COPIED BEFORE
05040                   THEY ARE PRINTED.
05080           FNDFOR
05100                   MOST SMALL ROUTINES ARE FAIRLY SIMPLE
05120                   AND ARE DOCUMENTED IN PLACE. FNDFOR IS
05140                   USED FOR FINDING "FOR" ENTRIES ON
05160                   THE STACK. WHENEVER A "FOR" IS EXECUTED AN
05180                   18 BYTE ENTRY IS PUSHED ONTO THE STACK.
05200                   BEFORE THIS IS DONE, HOWEVER, A CHECK
05220                   MUST BE MADE TO SEE IF THERE
05240                   ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
05260                   FOR THE SAME LOOP VARIABLE. IF SO, THAT "FOR" ENTRY
05280                   AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
05300                   ARE ELIMINATED FROM THE STACK. THIS IS SO A
05320                   PROGRAM THAT JUMPS OUT OF THE MIDDLE
05340                   OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
05360                   AND AGAIN WON'T USE UP 18 BYTES OF STACK
05380                   SPACE EVERY TIME. THE "NEXT" CODE ALSO
05400                   CALLS FNDFOR TO SEARCH FOR A "FOR" ENTRY WITH
05420                   THE LOOP VARIABLE IN
05440                   THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
05460                   THE STACK IS RESET. IF NO MATCH IS FOUND A
05480                   "NEXT WITHOUT FOR" ERROR OCCURS. GOSUB EXECUTION
05500                   ALSO PUTS A 6 BYTE ENTRY ON STACK.
05520                   WHEN A RETURN IS EXECUTED FNDFOR IS
05540                   CALLED WITH A VARIABLE POINTER THAT CAN'T
05560                   BE MATCHED. WHEN "FNDFOR" HAS RUN
05580                   THROUGH ALL THE "FOR" ENTRIES ON THE STACK
05600                   IT RETURNS AND THE RETURN CODE MAKES
05620                   SURE THE ENTRY THAT WAS STOPPED
05640                   ON IS A GOSUB ENTRY. THIS ASSURES THAT
05660                   IF YOU GOSUB TO A SECTION OF CODE
05680                   IN WHICH A FOR LOOP IS ENTERED BUT NEVER
05700                   EXITED THE RETURN WILL STILL BE
05720                   ABLE TO FIND THE MOST RECENT
05740                   GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
05760                   "GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
05780                   THE GOSUB ENTRY.
05820           NON-RUNTIME STUFF
05840                   THE CODE TO INPUT A LINE,CRUNCH IT, GIVE ERRORS,
05860                   FIND SPECIFIC LINE IN THE PROGRAM
05880                   PERFORM A "NEW", "CLEAR", AND "LIST" ARE
05900                   ALL IN THIS AREA. GIVEN THE EXPLANATION OF
05920                   PROGRAM STORAGE GIVEN BELOW THESE ARE
05940                   ALL STRAIGHTFORWARD.
05980           NEWSTT
06000                   WHENEVER A STATEMENT FINISHED EXECUTION IT
06020                   DOES A "RET" WHICH TAKES
06040                   EXECUTION BACK TO NEWSTT. STATEMENTS THAT
06060                   CREATE OR LOOK AT SEMI-PERMANENT STACK ENTRIES
06080                   MUST GET RID OF THE RETURN ADDRESS OF NEWSTT AND
06100                   JMP TO NEWSTT WHEN DONE. NEWSTT ALWAYS
06120                   CHRGETS THE FIRST CHARACTER AFTER THE STATEMENT
06140                   NAME BEFORE DISPATCHING. WHEN RETURNING
06160                   BACK TO NEWSTT THE ONLY THING THAT
06180                   MUST BE SET UP IS THE TEXT POINTER IN
06200                   [H,L]. NEWSTT WILL CHECK TO MAKE SURE
06220                   [H,L] IS POINTING TO A STATEMENT TERMINATOR.
06240                   IF A STATEMENT SHOULDN'T BE PERFORMED UNLESS
06260                   IT IS PROPERLY FORMATTED (I.E "NEW") IT CAN
06280                   SIMPLY DO A "RNZ" AFTER READING ALL OF
06300                   ITS ARGUMENTS. SINCE THE ZERO FLAG
06320                   BEING OFF INDICATES THERE IS NOT
06340                   A STATEMENT TERMINATOR NEWSTT WILL
06360                   DO THE JMP TO THE "SYNTAX ERROR"
06380                   ROUTINE. IF A STATEMENT SHOULD BE STARTED
06400                   OVER IT CAN DO LHLD TEMP,RET SINCE THE [H,L]
06420                   AT NEWSTT IS ALWAYS STORED IN TEMP. OF COURSE
06440                   CARE MUST TAKEN THAT NO ROUTINE
06460                   THAT SMASHES TEMP HAS BEEN CALLED.
06480                   THE ^C CODE STORES TEMP IN OLDTXT AND CURLIN (THE
06500                   CURRENT LINE NUMBER) IN OLDLIN SINCE THE ^C CHECK
06520                   IS MADE BEFORE THE STATEMENT POINTED TO IS
06540                   EXECUTED. "STOP" AND "END" STORE THE TEXT POINTER
06560                   IN [H,L] WHICH POINTERS AT THEIR TERMINATING
06580                   CHARACTER IN OLDTXT.
06620           STATEMENT CODE
06640                   THE INDIVIDUAL STATEMENT CODE COMES
06660                   NEXT. THE APPROACH USED IN EXECUTING EACH
06680                   STATEMENT IS DOCUMENTED IN THE STATEMENT CODE
06700                   ITSELF.
06740           FRMEVL, THE FORMULA EVALUATOR
06760                   GIVEN AN [H,L] POINTING TO THE STARTING
06780                   CHARACTER OF A FORMULA FRMEVL
06800                   EVALUATES THE FORMULATE AND LEAVES
06820                   THE VALUE IN THE FLOATING ACCUMULATOR (FAC).
06840                   [H,L] IS RETURNED POINTING TO THE FIRST CHARACTER
06860                   THAT COULD NOT BE INTERPRETED AS PART OF THE
06880                   FORMULA. THE ALGORITHM USES THE STACK
06900                   TO STORE TEMPORARY RESULTS:
06940                           0. PUT A DUMMY PRECEDENCE OF ZERO ON
06960                                   THE STACK.
06980                           1. READ LEXEME (CONSTANT,FUNCTION,
07000                                   VARIABLE,FORMULA IN PARENS)
07020                                   AND TAKE THE LAST PRECEDENCE VALUE
07040                                   OFF THE STACK
07060                           2. SEE IF THE NEXT CHARACTER IS AN OPERATOR
07080                                   IF NOT,RETURN. THIS MAY CAUSE
07100                                   OPERATOR APPLICATION OR AN ACTUAL
07120                                   RETURN FROM FRMEVL
07160                                   AND COMPARE IT TO THE PRECEDENCE
07180                                   OF THE LAST OPERATOR ON THE STACK
07200                           4. IF = OR LESS REMEMBER THE TEXT
07220                                   POINTER AT THE START OF THIS OPERATOR
07240                                   AND DO A RETURN TO CAUSE
07260                                   APPLICATION OF THE LAST OPERATOR.
07280                                   EVENTUALLY RETURN TO STEP 2
07300                                   BY RETURNING TO RETAOP.
07320                           5. IF GREATER PUT THE LAST PRECEDENCE
07340                                   BACK ON, SAVE THE CURRENT
07360                                   TEMPORARY RESULT, OPERATOR ADDRESS
07380                                   AND PRECEDENCE AND RETURN TO STEP 1.
07420                   RELATIONAL OPERATORS ARE ALL HANDLED THROUGH
07440                   A COMMON ROUTINE. SPECIAL
07460                   CARE IS TAKEN TO DETECT TYPE MISMATCHES SUCH AS 3+"F"
07500           EVAL -- THE ROUTINE TO READ A LEXEME
07520                   EVAL CHECKS FOR THE DIFFERENT TYPES OF
07540                   ENTITIES IT IS SUPPOSED TO DETECT.
07560                   LEADING PLUSES ARE IGNORED,
07580                   DIGITS AND "." CAUSE FIN (FLOATING INPUT)
07600                   TO BE CALLED. FUNCTION NAMES CAUSE THE
07620                   FORMULA INSIDE THE PARENTHESES TO BE EVALUATED
07640                   AND THE FUNCTION ROUTINE TO BE CALLED. VARIABLE
07660                   NAMES CAUSE PTRGET TO BE CALLED TO GET A POINTER
07680                   TO THE VALUE, AND THEN THE VALUE IS PUT INTO
07700                   THE FAC. AN OPEN PARENTHESIS CAUSES FRMEVL
07720                   TO BE CALLED (RECURSIVELY), AND THE ")" TO
07740                   BE CHECKED FOR. UNARY OPERATORS (NOT AND
07760                   NEGATION)  PUT THEIR PRECEDENCE ON THE STACK
07780                   AND ENTER FORMULA EVALUATION AT STEP 1, SO
07800                   THAT EVERYTHING UP TO AN OPERATOR GTEATER THAN
07820                   THEIR PRECEDENCE OR THE END OF THE FORMULA
07840                   WILL BE EVALUATED. WHEN FRMEVL DOES A RETURN
07860                   BECAUSE IT SEES AN OPERATOR OF HIGHER PRECEDENCE
07880                   IT DOES NOT PASS THE TEXT POINTER IN [H,L], SO
07900                   AFTER THE UNARY OPERATION HAS BEEN PERFORMED
07920                   ON THE FAC THE TEXT POINTER MUST BE FETCHED FROM
07940                   A TEMPORARY LOCATION THAT FRMEVL USES AND
07960                   A RETURN BACK TO FRMEVL DONE.
08000           DIMENSION AND VARIABLE SEARCHING
08020                   SPACE IS ALLOCATED FOR VARIABLES AS THEY ARE
08040                   ENCOUNTERED. THUS "DIM" STATEMENTS MUST BE
08060                   EXECUTED TO HAVE EFFECT. 6 BYTES ARE ALLOCATED
08080                   FOR EACH SIMPLE VARIABLE, WHETHER IT IS A STRING,
08100                   NUMBER OR USER DEFINED FUNCTION. THE FIRST TWO
08120                   BYTES GIVE THE NAME OF THE VARIABLE AND THE LAST FOUR
08140                   GIVE ITS VALUE. (VARTAB) GIVES THE FIRST LOCATION
08160                   WHERE A SIMPLE VARIABLE NAME IS FOUND AND (ARYTAB)
08180                   GIVES THE LOCATION TO STOP SEARCHING FOR SIMPLE
08200                   VARIABLES. A "FOR" ENTRY HAS A TEXT POINTER
08220                   AND A POINTER TO A VARIABLE VALUE SO NEITHER
08240                   THE PROGRAM OR THE SIMPLE VARIABLES CAN BE
08260                   MOVED WHILE THERE ARE ACTIVE "FOR" ENTRIES ON THE STACK
08280                   USER DEFINED FUNCTION VALUES ALSO CONTAIN
08300                   POINTERS INTO SIMPLE VARIABLE SPACE SO NO USER-DEFINED
08320                   FUNCTION VALUES CAN BE RETAINED IF SIMPLE VARIABLES
08340                   AREMOVED. ADDING A SIMPLE VARIABLE
08360                   ADDING SIX TO ARYTAB AND STREND, BLOCK TRANSFERING
08380                   THE ARRAY VALUES UP BY SIX AND MAKING SURE THE
08400                   NEW (STREND) IS NOT TO CLOSE TO THE STACK.
08420                   THIS MOVEMENT OF ARRAY VARIABLES MEANS
08440                   THATNO POINTER TO AN ARRAY WILL STAY VALID WHEN
08460                   NEW SIMPLE VARIABLES CAN BE ENCOUNTERED. THIS IS
08480                   WHY ARRAY VARIABLES ARE NOT ALLOWED "FOR"
08500                   LOOP VARIABLES. SETING UP ANEW ARRAY VARIABLE
08520                   MERELY INVOLVES BUILDING THE DESCRIPTOR,
08540                   UPDATING STRENDM AND MAKING SURE THERE IS
08560                   STILL ENOUGH ROOM BETWEEN STREND AND THE
08580                   STACK. WITHOUT MULTIPLE DIMENSIONS THE FORMAT
08600                   OF AN ARRAY VARIABLE IS SIMPLY:
08620                           SECOND CHARACTER
08640                           FIRST CHARACTER
08660                           NUMBER OF BYTES USED BY VALUES
08680                           VALUES
08700                   THE FORMAT WHEN MULTPLY DIMENSIONED VARIABLES
08720                   ARE ALLOWED IS DESCRIBED IN THE "MULDIM" CODE.
08740                   PTRGET, THE ROUTINE WHICH RETURNS A POINTER
08760                   TO A VARIABLE VALUE, HAS TWO IMPORTANT FLAGS. ONE IS
08780                   "DIMFLG" WHICH INDICATED WHETHER "DIM" CALLED PTRGET
08800                   OR NOT. IF SO, NO PRIOR ENTRY FOR THE VARIABLE IN
08820                   QUESTION SHOULD BE FOUND, AND THE INDEX INDICATED
08840                   HOW MUCH SPACE TO SET ASIDE. SIMPLE VARIABLES CAN
08860                   BE "DIMENSIONED", BUT THE ONLY EFFECT WILL BE TO
08880                   SET ASIDE SPACE FOR THE VARIABLE IF IT HASN'T BEEN
08900                   ENCOUNTERED YET. THE OTHER IMPORTANT FLAG IS SUBFLG
08920                   WHICH INDICATES WHETHER A SUBSCRIPTED VARIABLE SHOULD BE
08940                   ALLOWED IN THE CURRENT CONTEXT. IF SUBFLG IS NON-ZERO
08960                   THE OPEN PARENTHESIS FOR A SUBSCRIPTED VARIABLE
08980                   WILL NOT BE SCANNED BY PTRGET, AND PTRGET WILL RETURN
09000                   WITH A TEXT POINTER POINTING TO THE "(, IF
09020                   THERE WAS ONE.
09040           STRINGS
09060                   IN THE VARIABLE TABLE STRINGS ARE STORED JUST LIKE
09080                   NUMBERIC VARIABLES. SIMPLE STRINGS HAVE FOUR VALUE
09100                   BYTES WHICH ARE INITIALIZED TO ALL ZEROES (WHICH
09120                   REPRESENTS THE NULL STRING). THE ONLY DIFFERENCE
09140                   IN HANDLING IS THAT WHEN PTRGET SEES A "$" AFTER THE
09160                   NAME OF A VARIABLE, PTRGET SETS VALTYP TO ONE AND TURNS
09180                   ON THE MSB (MOST-SIGNIFICANT-BIT) OF THE VALUE OF
09200                   THE FIRST CHARACTER OF THE VARIABLE NAME.
09220                   HAVING THIS BIT ON IN THE NAME OF THE VARIABLE ENSURES
09240                   THAT THE SEARCH ROUTINE WILL NOT MATCH
09260                   'A' WITH 'AS' OR 'A$' WITH 'A'. THE MEANING OF
09280                   THE FOUR VALUE BYTES ARE:
09300                           LOW
09320                                   LENGTH OF THE STRING
09340                                   UNUSED
09360                                   LOW 8 BITS
09380                                   HIGH 8 BITS  OF THE ADDRESS
09400                                           OF THE CHARACTERS IN THE
09420                                           STRING IF LENGTH,NE.0.
09440                                           MEANINGLESS OTHERWISE.
09460                           HIGH
09480                   THE VALUE OF A STRING VARIABLE (THESE 4 BYTES)
09500                   IS CALLED THE STRING DESCRIPTOR TO DISTINGUISH
09520                   IT FROM THE ACTUAL STRING DATA. WHENEVER A
09540                   STRING CONSTANT IS ENCOUNTERED IN A FORMULA OR AS
09560                   PART OF AN INPUT STRING, OR AS PART OF DATA, STRLIT
09580                   IS CALLED, CAUSING A DESCRIPTOR TO BE BUILD FOR
09600                   THE STRING. IF THE STRING CONSTANT IS IN BUF (WHICH
09620                   IT WILL BE IF THE STRING IS BEING "INPUT", OR THE
09640                   STRING IS PART OF SOME FORMULA IN A DIRECT STATEMENT
09660                   THE VALUE IS COPIED INTO STRING SPACE SINCE BUF
09680                   IS ALWAYS CHANGING. "STRCPY" IS USED TO COPY
09700                   STRINGS.
09740                   STRING FUNCTIONS AND THE ONE STRING OPERATOR "+"
09760                   ALWAYS RETURN THEIR VALUES IN STRING SPACE.
09780                   ASSIGNING A STRING A CONSTANT VALUE IN A PROGRAM
09800                   THROUGH A "READ" OR ASSIGNMENT STATEMENT
09820                   WILL NOT USE ANY STRING SPACE SINCE
09840                   THE STRING DESCRIPTOR  WILL POINT INTO THE
09860                   PROGRAM ITSELF. IN GENERAL, COPYING IS DONE
09880                   WHEN A STRING VALUE IS IN BUF, OR IT IS IN STRING
09900                   SPACE AND THERE IS AN ACTIVE POINTER TO IT.
09920                   THUS F$=G$ WILL CAUSE COPYING IF G$ HAS ITS
09940                   STRING DATA IN STRING SPACE. F$=CHR$(7)
09960                   WILL USE ONE BYTE OF STRING SPACE TO STORE THE
09980                   NEW ONE CHARACTER STRING CREATED BY "CHR$", BUT
10000                   THE ASSIGNMENT ITSELF WILL CAUSE NO COPYING SINCE
10020                   THE ONLY POINTER AT THE NEW STRING IS A
10040                   TEMPORARY DESCRIPTOR CREATED BY FRMEVL WHICH WILL
10060                   GO AWAY AS SOON AS THE ASSIGNMENT IS DONE.
10080                   IT IS THE ANTURE OF GARBAGE COLLECTION THAT
10100                   DISALLOWS HAVING TWO STRING DESCRIPTORS POINT TO THE SAME
10120                   AREA IN STRING SPACE. STRING FUNCTIONS AND OPERATORS
10140                   MUST PROCEED AS FOLLOWS:
10160                           1) FIGURE OUT THE LENGTH OF THEIR RESULT
10180                           2) CALL GETSPA TO FIND SPACE FOR THEIR
10200                           RESULT. THE ARGUMENTS TO THE FUNCTION
10220                           OR OPERATOR MAY CHANGE SINCE GARBAGE COLLECTION
10240                           MAY BE INVOLVED. THE ONLY THING THAT CAN
10260                           BE SAVED DURING THE CALL TO GETSPA IS A POINTER
10280                           TO THE DESCRIPTORS OF THE ARGUMENTS.
10300                           3) CONSTRUCT THE RESULT DESCRIPTOR IN DSCTMP.
10320                           GETSPA RETURNS THE LOCATION OF THE AVAILABLE
10340                           SPACE.
10360                           4) CREATE THE NEW VALUE BY COPYING PARTS
10380                           OF THE ARGUMENTS OR WHATEVER.
10400                           5) FREE UP THE ARGUMENTS BY CALLING FRETMP.
10420                           6) JUMP TO PUTNEW TO GET THE DESCRIPTOR IN
10440                           DSCTMP TRANSFERRED INTO A NEW STRING TEMPORARY.
10480                   THE REASON FOR STRING TEMPORARIES IS THAT GARBAGE
10500                   COLLECTION HAS TO KNOW ABOUT ALL ACTIVE STRING DESCRIPTORS
10520                   SO IT KNOWS WHAT IS AND ISN'T IN USE. STRING TEMPORARIES ARE
10540                   USED TO STORE THE DESCRIPTORS OF STRING EXPRESSIONS.
10580                   INSTEAD OF HAVING AN ACTUAL VALUE STORED IN THE
10600                   FAC, AND HAVING THE VALUE OF A TEMPORARY RESULT
10620                   BEING SAVED ON THE STACK, AS HAPPENS WITH NUMERIC
10640                   VARIABLES, STRINGS HAVE THE POINTER TO A STRING DESCRIPTOR
10660                   STORED IN THE FAC, AND IT IS THIS POINTER
10680                   THAT GETS SAVED ON THE STACK BY FORMULA EVALUATION.
10700                   STRING FUNCTIONS CANNOT FREE THEIR ARGUMENTS UP RIGHT
10720                   AWAY SINCE GETSPA MAY FORCE
10740                   GARBAGE COLLECTION AND THE ARGUMENT STRINGS
10760                   MAY BE OVER-WRITTEN SINCE GARBAGE COLLECTION
10780                   WILL NOT BE ABLE TO FIND AN ACTIVE POINTER TO
10800                   THEM. FUNCTION AND OPERATOR RESULTS ARE BUILT IN
10820                   DSCTMP SINCE STRING TEMPORARIES ARE ALLOCATED
10840                   (PUTNEW) AND DEALLOATED (FRETMP) IN A FIFO ORDERING
10860                   (I.E. A STACK) SO THE NEW TEMPORARY CANNOT
10880                   BE SET UP UNTIL THE OLD ONE(S) ARE FREED. TRYING
10900                   TO BUILD A RESULT IN A TEMPORARY AFTER
10920                   FREEING UP THE ARGUMENT TEMPORARIES COULD RESULT
10940                   IN ONE OF THE ARGUMENT TEMPORARIES BEING OVERWRITTEN
10960                   TOO SOON BY THE NEW RESULT.
11000                   STRING SPACE IS ALLOCATED AT THE VERY TOP
11020                   OF MEMORY. MEMSIZE POINTS BEYOND THE LAST LOCATION OF
11040                    STRING SPACE. STRING ARE STORED IN HIGH LOCATIONS
11060                   FIRST. WHENEVER STRING SPACE IS ALLOCATED (GETSPA)
11080                   FRETOP, WHICH IS INITIALIZED TO [MEMSIZ], IS UPDATED
11100                   TO GIVE THE HIGHEST LOCATION IN STRING SPACE
11120                   THAT IS NOT IN USE. THE RESULT IS THAT
11140                   FRETOP GETS SMALLER AND SMALLER, UNTIL SOME
11160                   ALLOCATION WOULD MAKE [FRETOP] LESS THAN OR EQUAL TO
11180                   [STKTOP]. THIS MEANS STRING SPACE HAS RUN INTO THE
11200                   STACK AND THAT GARBAGE COLLECTION MUST BE CALLED.
11240                   GARBAGE COLLECTION:
11260                           0. MINPTR=[STKTOP] [FRETOP]=[MEMSIZ]
11280                           1. REMMIN=0
11300                           2. FOR EACH STRING DESCRIPTOR
11320                           (TEMPORARIES, SIMPLE STRINGS, STRING ARRAYS)
11340                           IF THE STRING IS NOT NULL AND ITS POINTER IS
11360                           .GT.MINPTR AND .LT.FRETOP,
11380                           MINPTR=THIS STRING DESCRIPTOR
11400                           REMMIN=POINTER AT THIS STRING DESCRIPTOR
11420                           END
11440                           3. IF REMMIN.NE.0 (WE FOUND AN UNCOLLECTED STRING)
11460                           BLOCK TRANSFER THE STRING DATA POINTED
11480                           TO IN THE STRING DESCRIPTOR POINTED TO BY REMMIN
11500                           SO THAT THE LAST BYTE OF STRING DATA IS AT
11520                           [FRETOP]. UPDATE FRETOP SO THAT IT
11540                           POINTS TO THE LOCATION JUST BELOW THE ONE
11560                           THE STRING DATA WAS MOVED INTO. UPDATE
11580                           THE POINTER IN THE DESCRIPTOR SO IT POINTS
11600                           TO THE NEW LOCATION OF THE STRING DATA.
11620                           GO TO STEP 1
11660                   AFTER CALLING GARBAGE COLLECTION GETSPA AGAIN CHECKS
11680                   TO SEE IF [A] CHARACTERS ARE AVAILABLE BETWEEN
11700                   [STKTOP] AND [FRETOP] , IF NOT AN "OUT OF STRING"
11720                   ERROR IS INVOKED.
11760           MATH PACKAGE
11780                   THE MATH PACKAGE CONTAINS FLOATING INPUT (FIN),
11800                   FLOATING OUTPUT (FOUT) FLOATING COMPARE (FCOMP)
11820                   ... AND ALL THE NUMERIC OPERATORS AND FUNCTIONS.
11840                   THE FORMATS,CONVENTIONS AND ENTRY POINTS ARE ALL
11860                   DESCRIBED IN THE MATH PACKAGE ITSELF.
11900           INIT -- THE INITIALIZATION ROUTINE
11920                   INITIALIZATION FIRST LOOKS AT THE SWITCH REGISTERS
11940                   TO SEE WHAT TYPE OF I/O SHOULD BE DONE.
11960                   ANY NON-STANDARD I/O CAUSES LOCATIONS IN BASIC
11980                   TO BE CHANGED. THEN THE AMOUNT OF MEMORY,
12000                   TERMINAL WIDTH,AND WHICH FUNCTIONS TO BE RETAINED
12020                   ARE ASCERTAINED FROM THE USER. A ZERO IS PUT DOWN
12040                   AT THE FIRST LOCATION NOT USED BY THE MATH-PACKAGE
12060                   AND TXTTAB IS SET UP TO POINT AT THE NEXT LOCATION.
12080                   THIS DETERMINES WHERE PROGRAM STORAGE WILL START. THE
12100                   HIGHEST MEMORY LOCATION MINUS THE AMOUNT OF DEFAULTED
12120                   STRING SPACE (50) GIVES THE FIRST LOCATION USED BY THE
12140                   STACK. SPECIAL CHECKS ARE MADE TO MAKE SURE
12160                   ALL QUESTIONS IN INIT ARE ANSWERED REASONABLY, SINCE
12180                   ONCE INIT FINISHES THE LOCATIONS IT USES ARE
12200                   USED FOR PROGRAM STORAGE. THE LAST THING INIT DOES IS
12220                   CHANGE LOCATION ZERO TO BE A JUMP TO READY INSTEAD
12240                   OF INIT. ONCE THIS IS DONE THERE IS NO WAY TO RESTART
12260                   INIT.
12300           STORAGE
12320                                   A ZERO.
12340                   [TXTTAB]        POINTER TO NEXT LINE'S POINTER
12360                                   LINE # OF THIS LINE (2 BYTES)
12380                                   CHARACTERS ON THIS LINE
12400                                   ZERO
12420                                   POINTER AT THE NEXT LINE'S POINT
12440                                               (POINTED TO BY THE ABOVE POINTER)
12460                                   ... REPEATS ...
12480                   LAST LINE:      POINTER AT ZERO POINTER
12500                                   LINE # OF THIS LINE
12520                                   CHARACTERS ON THIS LINE
12540                                   ZERO
12560                                   DOUBLE ZERO (POINTED TO BY THE ABOVE POINTER)
12580                   [VARTAB]        SIMPLE VARIABLES. 6 BYTES PER VALUE.
12600                                   2 BYTES GIVE THE NAME, 4 BYTES THE VALUE
12620                                   ... REPEATS ...
12640                   [ARYTAB]        ARRAY VARIABLES. 2 BYTES NAME, 2 BYTE
12660                                   LENGTH, VALUE (EXTRA IF MULDIM ON)
12680                                   ... REPEATS  ...
12700                   [STREND]        FREE SPACE
12720                                   ... REPEATS ...
12740                                   MOST RECENT STACK ENTRY
12760                                   ... REPEATS ...
12780                   [STKTOP]        FIRST STACK ENTRY
12800                                   FREE STRING SPACE
12820                                   ... REPEATS ...
12840                   [FRETOP]        STRING SPACE IN USE
12860                                   ... REPEATS ...
12880                   [MEMSIZ]        HIGHEST MACHINE LOCATION
12900                                   UNUSED EXCEPT BY THE VAL FUNCTION.
12920   HIGH LOCATIONS
12960   *
12980   PAGE
13000   SUBTTL  RST ROUTINES
13020   RELOC 0
13040   START:  DI                      ;DISENABLE INTERRUPTS
13060           JMP     INIT            ;INIT IS THE INITIALIZE ROUTINE 
13080                                   ;IT SETS UP CERTAIN
13100                                   ;LOCATIONS DELETES FUNCTIONS IF
13120                                   ;DESIRED AND
13140                                   ;CHANGES THIS TO JMP READY
13160   IFN     LENGTH-2,<
13180           ADR(DEINT)              ;STORE HERE THE ROUTINE
13200                                   ;TO TURN THE FAC INTO
13220                                   ;A TWO-BYTE SIGNED INTEGER
13240           ADR(GIVABF)>            ;STORE HERE THE ADDRESS
13260                                   ;OF THE ROUTINE TO CONVERT [A,B]
13280                                   ;TO A FLOATING POINT NUMBER IN THE FAC
13300   IFE     LENGTH-2,<
13320           ADR(FECINT)             ;TURN FAC INTO AN INTEGER IN [H,L]
13340           ADR(MAKINT)>            ;TURN [H,L] INTO A VALUE IN THE FAC
13360                                   ;SET VALTYP FOR INTEGER
13380   RELOC 8
13400   ;
13420   ; SYNCHK LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
13440   ; IS A SPECIFIC THING (CONTAINED IN THE LOCATION AFTER THE CALL)
13460   ; IF NOT IT CALLS THE 'SYNTAX ERROR' ROUTINE, OTHERWISE IT GOBBLES
13480   ; THE NEXT CHARACTER AND RETURNS. (BY FALLING INTO CHRGET)
13500   ;
13520   ; ALL REGISTERS ARE PRESERVED EXCEPT [A]=NEW CHAR
13540   ; AND (H,L) ENDS UP POINTING AT THE CHARACTER AFTER THE ONE
13560   ; WHICH WAS CHECKED.
13580   ;
13600           MOV     A,M             ;GET THE CURRENT CHARACTER
13620           XTHL                    ;GET CALL ADDRESS IN TO [H,L]
13640                                   ;PUT TEXT POINTER ON STACK
13660           CMP     M               ;SEE IF [A] =CURRENT CHARACTER
13680                                   ;IS THE RIGHT THING.
13700           INX     H               ;FIX RETURN ADDRESS.
13720           XTHL                    ;PUT RETURN ADDRESS BACK AND RESTORE
13740                                   ;THE TEXT POINTER.
13760           JNZ     SNERR           ;IF THE CHARACTER WASN'T RIGHT CALL
13780                                   ;THE 'SYNTAX ERROR' ROUTINE
13800                                   ;OTHERWISE FALL THROUGH
13820                                   ;AND GET ANOTHER CHARACTER.
13840   ;
13860   ; CHRGET, USING [H,L] AS THE CURRENT TEXT POINTER FETCHES
14880   ; A NEW CHARACTER INTO [A] AFTER INCREMENTING [H,L]
14900   ; AND SETS CONDITION CODES ACCORDING TO WHATS IT [A]
14920   ;       C=       NUMERIC    ("0" THROUGH "9")
13940   ;       Z=       ":" OR END-OF-LINE (A 0)
13960   ;
13980   ; ALL REGISTERS SAVED EXCEPT [A]=NEW CHAR
14000   ; [H,L]=[H,L]+1
14020   ;
14040   RELOC 16
14060   IFE     LENGTH,<CHRGTR:>
14080           INX     H               ;UPDATE THE TEXT POINTER
14100           MOV     A,M             ;GET NEW CHARACTER
14120           CPI     ":"             ;MAKE ":" HAVE ZERO ON AND
14140                                   ;CARRY OFF
14160                                   ;ALL ALPHABETICS & RESERVED
14180                                   ;WORDS GET ZERO & CARRY OFF
14200   RNC                             ;.GT.":" GO BACK
14220   JMP     CHRCON                  ;NO ROOM FOR WHOLE ROUTINE
14240   ;
14260   ; THIS RST ROUTINE OUTPUTS THE CHARACTER IN [A] USING PRTFLG (LPT OR TTY)
14280   ; CNTWFL (SUPRESS OUTPUT OR NOT), TTYPOS (PRINT HEAD POSITION),
14300   ; TIMING ETC.. NO REGISTERS OR CONDITION CODES ARE CHANGED.
14320   ;
14340   RELOC 24
14360   OUTDO:  PUSH    PSW
14380   IFN     CONTRW,<
14400           LDA     CNTWFL          ;GET SUPPRESS FLAG
14420           ORA     A>              ;SEE IF IT IS SET
14440   IFE     LENGTH!CONTRW!LPTSW,<
14460           LDA     TTYPOS>         ;USE RST BYTES, [A]=TTYPOS
14480           JMP     OUTCON
14500   ;
14520   ; COMPAR COMPARES [H,L] WITH [D,E] UNSIGNED
14540   ;
14560   ;               [H,L] LESS THAN [D,E] SET CARRY
14580   ;               [H,L] = [D,E] SET ZERO
14600   ;
14620   ; [A] IS THE ONLY REGISTER USED
14640   ;
14660   RELOC 32
14680           MOV     A,H
14700           SUB     D
14720           RNZ
14740           MOV     A,L
14760           SUB     E
14780           RET
14800   NULCNT: 1                       ;STORE HERE THE NUMBER OF NULLS
14820                                   ;TO PRINT AFTER CRLF
14860   TTYPOS: BLOCK   1               ;STORE TERMINAL POSITION HERE
14880   ;
14900   ;THE FSIGN  RST RETURNS A=-1 IF FAC IS LESS THAN 0
14920   ;       A=0 IF FAC=0
14940   ;       A=1 IF FAC GREATER THAN ZERO
14960   ; THE CONDITION CODES REFLECT THE VALUE OF [A]
14980   ; AND NO OTHER REGISTERS ARE MODIFIED.
15000   ; THIS WORKS ONLY WHEN THE FAC IS A SINGLE OR DOUBLE PRECISION NUMBER
15020   ; THE 'VSIGN' ROUTINE IS MORE GENERAL SINCE
15040   ; IT WILL TAKE THE SIGN OF THE INTEGERS AS WELL
15050   ; AND GIVES "TMERR" ON STRINGS.
15060   ;
15080   RELOC   40
15100   SIGN:   LDA     FAC
15120           ORA     A
15140           JNZ     SIGNC
15160           RET
15180   ;
15200   ; THIS IS THE PUSHM RST
15220   ; EFFECT IS:
15240   ;       MOVE    C,M
15260   ;       INX     H
15280   ;       MOV     B,M
15300   ;       INX     H
15320   ;       PUSH    B
15340   ; DIFFICULTY COMES IN BECAUSE OF THE
15360   ; RETURN ADDRESS.
15380   ;
15400   RELOC   48
15420           XHTL                    ;SWITCH [H,L] AND RETURN ADDRESS
15440           SHLD    PUSHMA+1        ;FIXUP JUMP PLACE TO GO
15460           POP     H               ;REGAIN [H,L]
15480   IFN     LENGTH,<
15500           JMP     $CODE+59        ;IN 8K ALLOW USER TO HAVE RST 7
15520                                   ;FOR INTERRUPT TRAPPING
15540   RELOC   56
15560           RET                     ;INITIALLY NO INTERRUPT
15580                                   ;ROUTINE
15600           NOP
15620           NOP>
15640           MOV     C,M             ;GRAB FROM MEMORY
15660           INX     H
15680           MOV     B,M
15700           INX     H
15720           PUSH    B               ;PUSH [B,C] ONTO THE STACK
15740                                   ;SINCE IT CONTAINS [M]
15760   PUSHMA: JMP     PUSHMA          ;RETURN  ADDRESS STORED HERE
15800   PAGE
15820   SUBTTL DISPATCH TABLES,RESERVED WORDS, ERROR TEXT... ALL CONSTANT
15860   FUNDSP: ADR(SGN)
15880   IFN     LENGTH-2,<
15900           ADR(INT)>
15920   IFE     LENGTH-2,<
15940           ADR(VINT)>
15960           ADR(ABS)
15980   USRLOC: ADR(ILLFUN)             ;INITIALLY NO USER ROUTINE
16000   IFN     LENGTH,<ADR(FRE)
16020           ADR(FNINP)
16040   IFN     LPTSW,<ADR(LPOS)>
16060           ADR(POS)>
16080   SQRFIX: ADR(SQR)
16100   RNDFIX: ADR(RND)
16120   IFN     EXTFNC,<
16140           ADR(LOG)
16160           ADR(EXP)
16180   COSFIX: ADR(COS)>
16200   SINFIX: ADR(SIN)
16220   IFN     EXTFNC,<
16240   TANFIX: ADR(TAN)
16260   ATNFIX: ADR(ATN)>
16280   IFN     LENGTH,<
16300           ADR(PEEK)>
16320   IFN     DSKFUN,<ADR(DSKI$)>
16340   IFN     STRING,<
16360           ADR(LEN)
16380           ADR(STR$)
16400           ADR(VAL)
16420           ADR(ASC)
16440           ADR(CHR$)
16460           ADR(LEFT$)
16480           ADR(RIGHT$)
16500           ADR(MIDS$)>
16540   DEFINE ADRP(X),<ADR(X)>
16560   IFE     LENGTH-2,<
16580   DEFINE ADRP(X),<>>
16600   OPTAB: 121                      ;OPERATOR TABLE CONTAINS
16620                                   ;PRECEDENCE FOLLOWED BY
16640                                   ;THE ROUTINE ADDRESS
16660           ADRP(FADDT)
16680           121
16700           ADRP(FSUBT)
16720           123
16740           ADRP(FMULTT)
16760           123
16780           ADRP(FDIVT)
16800   IFN     EXTFNC,<127
16820           ADRP(FPWRT)>
16840   IFN     LENGTH,<
16860           80
16880           ADRP(AND)
16900           70
16920           ADRP(OR)>
16960   ;
16980   ; TOKEN FOR RESERVED WORDS ALWAYS HAVE THE MOST
17000   ; SIGNIFICANT BIT ON
17020   ; THE LIST OF RESERVED WORDS
17040   ;
17060   Q=128-1
17080   DEFINE  DCI(A),<Q=Q+1
17090           XLIST
17100           DC(A)
17110           LIST>
17140           ENDTK==Q
17180           FORTK==Q
17240           DATATK==Q
17360           GOTOTK==Q
17420           IFTK==Q
17480           GOSUTK==Q
17540           REMTK==Q
17660   IFE     LENGTH-1,<
17700           ELSETK==Q
17780   IFN     DSKFUN,<DCI"DSKO$">
17800   IFN     LPTSW,<DCI"LPRINT">
17820   IFN     LENGTH,<
17880           PRINTK==Q
17940   IFE     REALIO,<
17960           DCI"DDT">
18000   IFN     LPTSW,<DCI"LLIST>
18060   IFN     CASSW,<DCI"CLOAD"
18080           DCI"CSAVE">
18100   IFN     CONSW,<DCI"CONSOLE">
18140           SCRATK=Q
18160   ; END OF COMMAND LIST
18180           "T"
18200           "A"
18220           "B"
18240           "("+128
18260           Q=Q+1
18280           TABTK=Q
18320           TOTK==Q
18340   IFN     LENGTH,<
18360           "S"
18380           "P"
18400           "C"
18420           "("+128                 ;MACRO DOESNT LIKE ('S IN ARGUMENTS
18440           Q=Q+1
18460           SPCTK==Q>
18500           FNTK==Q>
18540           USINTK==Q>
18580           THENTK=Q
18600   IFN     LENGTH,<
18640           NOTTK==Q>
18680           STEPTK=Q
18720           PLUSTK=Q
18760           MINUTK=Q
18880           LSTOPK==Q+1-PLUSTK      ; CRUNCH # OF HIGHEST OP+1-PLUSTK
18900           190                     ;A GREATER THAN SIGN
18920           Q=Q+1
18940           GREATK=Q
18980           EQUALK=Q
19000           188
19020           Q=Q+1
19040           LESSTK=Q                ;A LESS THAN SIGN
19060   ;
19080   ; NOTE DANGER OF ONE RESERVED WORD BEING A PART
19100   ; OF ANOTHER
19120   ; IE . . IF 2 GREATER THAN F OR T=5 THEN...
19140   ; WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
19160   ; IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
19180   ; SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
19190   ; ANOTHER EXAMPLE: IF T OR Q THEN ... "TO" IS CRUNCHED
19200   ;
19240           ONEFUN=Q
19360   IFN     LPTSW,<DCI"LPOS">
19420           SQRTK==Q
19460   IFN     EXTFNC,<
19600           ATNTK==Q>
19620   IFN     LENGTH,<
19660   IFN     DSKFUN,<DCI"DSKI$">
19680   IFN     STRING,<
19800   LASNUM==Q                       ;NUMBER OF LAST FUNCTION
19820                                   ;THAT TAKES ONE ARG
19900           0                       ;MARKS END OF RESERVED WORD LIST
19940   STMDSP: ADR(END)
19960           ADR(FOR)
19980           ADR(NEXT)
20000           ADR(DATA)
20020           ADR(INPUT)
20040           ADR(DIM)
20060           ADR(READ)
20080           ADR(LET)
20100           ADR(GOTO)
20120           ADR(RUN)
20140           ADR(IF)
20160           ADR(RESTORE)
20180           ADR(GOSUB)
20200           ADR(RETURN)
20220           ADR(REM)
20240           ADR(STOP)
20260   IFE     LENGTH-2,<
20280           ADR(ELSE)
20300           ADR(TON)
20320           ADR(TOFF)
20340           ADR(EDIT)>
20360   IFN     LENGTH,<ADR(FNOUT)
20380           ADR(ONGOTO)
20400           ADR(NULL)
20420           ADR(FNWAIT)>
20440   IFN     DSKFUN,<ADR(DSKO$)>
20460   IFN     LPTSW,<ADR(LPRINT)>
20480   IFN     LENGTH,<
20500           ADR(POKE)
20520           ADR(PRINT)
20540   IFN     FUNCTS,<ADR(DEF)>
20580   IFN     LENGTH,<ADR(CONT)>
20600   IFE     REALIO, <ADR(OUT)>
20620           ADR(LIST)
20640   IFN     LPTSW,<ADR(LLIST)>
20660   IFE     LENGTH-2,<ADR(DELETE)>
20680           ADR(CLEAR)
20700   IFN     CASSW,<ADR(CLOAD)
20720           ADR(CSAVE)>
20740   IFN     CONSSW,<ADR(CONSOLE)>
20760           ADR(SCRATH)
20800   IFE     LENGTH-2,<
20820   FRCTBL: ADR(FRCDBL)
20840           ADR(FRCINT)
20860           ADR(FRCSNG)
20880   ;
20900   ; THESE TABLES ARE USED AFTER THE DECISION HAS BEEN MADE
20920   ; TO APPLY AN OPERATOR AND ALL THE NECESSARY CONVERSION HAS
20940   ; BEEN DONE TO MATCH THE TWO ARGUMENT TYPES (APPLOP)
20960   ;
20980   DBLDSP: ADR(DADD)               ;DOUBLE PRECISION ROUTINES
21000           ADR(DSUB)
21020           ADR(DMULT)
21040           ADR(DDIV)
21060           ADR(DCOMP)
21080   SNGDSP: ADR(FADD)               ;SINGLE PRECISION ROUTINES
21100           ADR(FSUB)
21120           ADR(FMULT)
21140           ADR(FDIV)
21160           ADR(FCOMP)
21180   INTDSP: ADR(IADD)               ;INTEGER ROUTINES
21200           ADR(ISUB)
21220           ADR(IMULT)
21240           ADR(IDIV)
21260           ADR(ICOMP)
21320   Q=-2
21340   DEFINE  DCL(X),<>
21360   DEFINE  DCE(X),<Q=Q+2
21370           XLIST
21380           DC(X)
21390           LIST>
21420   ERRTAB:
21440   IFE     LENGTH-2,<
21460           0
21480           Q=0
21500           DEFINE  DCE(X),<>
21520           DEFINE  DCL(X),<
21540           Q=Q+1
21560           DC(X)
21580           0>>
21600           DCE"NF"
21620           DCL"NEXT WITHOUT FOR"
21640           ERRNF==Q
21660           DCE"SN"
21680           DCL"SYNTAX ERROR"
21700           ERRSN==Q
21720           DCE"RG"
21740           DCL"RETURN WITHOUT GOSUB"
21760           ERRRG==Q
21780           DCE"OD"
21800           DCL"OUT OF DATA"
21820           ERROD==Q"
21840           DCE"FC"
21860           "DCL"ILLEGAL FUNCTION CALL"
21880           ERRFC==Q
21900           DCE"OV"
21920           DCL"OVERFLOW"
21940           ERROV==Q
21960           DCE"OM"
21980           DCL"OUT OF MEMORY"
22000           ERROM==Q
22020           DCE"US"
22040           DCL"UNDEFINED STATEMENT"
22060           ERRUS==Q
22080           DCE"BS"
22100           DCL"SUBSCRIPT OUT OF RANGE"
23120           ERRBS==Q
23140           DCE"DD"
22160           DCL"REDIMENSIONED ARRAY"
22180           ERRDD==Q
22200           DCE"/0"
22220           DCL"DIVISION BY ZER0"
22240           ERRDV0==Q
22260           DCE"ID"
22280           DCL"ILLEGAL DIRECT"
22300           ERRID==Q
22320   IFN     STRING,<
22340           DCE"TM"
22360           DCL"TYPE MISMATCH"
22380           ERRTM==Q
22400           DCE"OS"
22420           DCL"OUT OF STRING SPACE"
23440           ERRSO==Q
23460           DCE"LS"
23480           DCL"STRING TOO LONG"
22500           ERRLS==Q
22520           DCE"ST"
22540           DCL"STRING FORMULA TOO COMPLEX"
22560           ERRST==Q>
22580   IFN     LENGTH,<
22600           DCE"CN"
22620           DCL"CAN'T CONTINUE"
22640           ERRCN==Q>
22660   IFN     FUNCTS,<
22680           DCE"UF"
22700           DCL"UNDEFINED USER FUNCTIONS"
23720           ERRUF==Q>
23760   PAGE
22780   SUBTTL  LOW SEGMENT -- RAM -- IE THIS STUFF IS NOT CONSTANT
22800   ;
22820   ; THIS IS THE "VOLATILE" STORAGE AREA AND NONE OF IT
22840   ; CAN BE KEPT IN ROM, ANY CONSTANTS IN THIS AREA CANNOT
22860   ; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE
22880   ; PROGRAM INSTRUCTION IN ROM.
22900   ;
22940   BUFMIN: 44                      ;A COMMA (PRELOAD OR ROM)
22960                                   ;USED BY INPUT STATEMENT SINCE THE
22980                                   ;DATA POINTER ALWAYS STARTS ON A
23000                                   ;COMMA OR TERMINATIOR
23020                                   ;TYPE IN STORED HERE
23040                                   ;DIRECT STATEMENTS EXECUTE OUT OF
23060                                   ;HERE, REMEMBER INPUT SMASHES BUF.
23080                                   ;MUST BE AT A LOWER ADDRESS
23100                                   ;THAN DSCTMP OR ASSIGNMENT OF STRING
23120                                   ;VALUES IN DIRECT STATEMENTS WON'T COPY
23140                                   ;INTO STRING SPACE -- WHICH IT MUST
23160   IFN     LPTSW,<
23180   LPTPOS: BLOCK   1               ;POSITION OF LPT PRINT HEAD
23200   PRTFLG: BLOCK   1>              ;WHETHER OUTPUT GOES TO LPT
23220                                   ;NON-ZERO MEANS SEND OUTPUT TO LPT
23240   IFN     CONTR,<
23260   CNTWFL: BLOCK   1>              ;SUPRESS OUTPUT FLAG
23280   DIMFLG: BLOCK   1               ;IN GETTING A POINTER TO A VARIABLE
23300                                   ;IT IS IMPORTANT TO REMEMBER WHETHER IT
23320                                   ;IS BEING DONE FOR "DIM" OR NOT
23340                                   ;DIMFLG AND VALTYP MUST BE
23360                                   ;CONSECUTIVE LOCATIONS
23380   IFN     STRING,<
23400   VALTYP: BLOCK   1               ;THE TYPE INDICATOR
23420                                   ;IN THE 8K 0=NUMERIC 1=STRING
23435   OPRTYP:                         ;USED TO STORE OPERATOR NUMBER
23436                                   ;IN THE EXTENDED MOMENTARILY BEFORE
23437                                   ;OPERATOR APPLICATION
23440   DORES:  BLOCK   1               ;WHETHER CAN OR CAN'T CRUNCH RES'D WORDS
23460                                   ;TURNED ON IN THE 8K WHEN "DATA"
23480                                   ;BEING SCANNED BY CRUNCH SO UNQUOTED
23500                                   ;STRINGS WON'T BE CRUNCHED.
23520   MEMSIZ: BLOCK   2               ;HIGHEST LOCATION IN MEMORY
23540   TEMPPT: BLOCK   2               ;POINTER AT FIRST FREE TEMP DESCRIPTOR
23560                                   ;INITIALIZED TO POINT TO TEMPST
23580   TEMPST: BLOCK   STRSIZ*NUMTMP   ;STORAGE FOR NUMTMP DESCRIPTORS
23600   DSCTMP: BLOCK   STRSIZ          ;STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE
23620   FRETOP: BLOCK   2>              ;TOP OF STRING FREE SPACE
23640   IFN     LENGTHISTRING,<
23660   TEMP3:  BLOCK   2>              ;USED TO HOLD VARB # OF HIGH LOC FOUND
23680                                   ;IN GARBAGE COLLECTION
23700                                   ;AND USED MOMENTARILY BY FRMEVL
23720                                   ;USED IN EXTENDED BY FOUT
23740                                   ;ARRAY VARIABLE HANDLING TEMPORARY
23760   IFN     LENGTH,<
23780   DATLIN: BLOCK   2               ;DATA LINE # -- REMEMBER FOR ERRORS
23800   SUBFLG: BLOCK   1>              ;FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED
23820                                   ;"FOR" AND USER-DEFINED FUNCTION
23840                                   ;POINTER FETCHING TURN
23860                                   ;THIS ON BEFORE CALLING PTRGET
23880                                   ;SO ARRAYS WON'T BE DETECTED.
23900                                   ;STKINI AND PTRGET CLEAR IT.
23920   FLGINP: BLOCK   1               ;FLAGS WHETHER WE ARE DOING INPUT
23940                                   ;OR A READ
23960   TEMP:   BLOCK   2               ;TEMPORARY FOR STATEMENT CODE
23980                                   ;NEWSTT SAVES [H,L] HERE FOR INPUT AND ^C
24000                                   ;"LET" SAVED NUMBERIC VARIABLE
24020                                   ;POINTERS HERE FOR "FOR"
24040                                   ;"NEXT" SAVES ITS TEXT POINTER HERE
24060                                   ;CLEARC SAVE [H,L] HERE
24080   TEMP2:  BLOCK   2               ;FORMULA EVALUATOR TEMP
24100                                   ;MUST BE PRESERVED BY OPERATORS
24120                                   ;USED IN EXTENDED BY FOUT
24140                                   ;ARRAY VARIABLE HANDLER TEMPORARY
24160   CURLIN: BLOCK   2               ;CURRENT LINE #
24180                                   ;SET TO 65535 WHEN DIRECT STATEMENTS EXECUTE
24200   IFN     LENGTH,<
24220   OLDLIN: BLOCK   2               ;OLD LINE NUMBER
24240   OLDTXT: BLOCK   2               ;OLD TEXT POINTER
24260                                   ;POINTS AT STATEMENT TO BE EXECUTED NEXT
24280   STKTOP: BLOCK   2               ;TOP LOCATION TO USE FOR THE STACK
24300                                   ;INITIALLY SET UP BY INIT
24320                                   ;ACCORDING TO MEMORY SIZE
24340                                   ;TO ALLOW FOR 50 BYTES OF STRING SPACE.
24360                                   ;CHANGED BY A CLEAR COMMAND WITH
24380                                   ;AN ARGUMENT.
24400   TXTTAB: BLOCK   2               ;POINTER TO BEGINNING OF TEXT
24420                                   ;DOESN'T CHANGE AFTER BEING
24440                                   ;SETUP BY INIT.
24460   VARTAB: BLOCK   2               ;POINTER TO START OF SIMPLE
24480                                   ;VARIABLE SPACE
24500                                   ;UPDATED WHENEVER THE SIZE OF THE
24520                                   ;PROGRAM CHANGES, SET TO [TXTTAB]
24540                                   ;BY SCRATCH ("NEW").
24560   ARYTAB: BLOCK   2               ;POINTER TO BEGINNING OF ARRAY
24580                                   ;TABLE
24600                                   ;INCREMENTED BY 6 WHENEVER
24620                                   ;A NEW SIMPLE VARIABLE IS FOUND, AND
24640                                   ;SET TO [VARTAB] BY CLEARC.
24660   STREND: BLOCK   2               ;END OF STORAGE IN USE
24680                                   ;INCREASED WHENEVER A NEW ARRAY
24700                                   ;OR SIMPLE VARIABLE IS ENCOUNTERED
24720                                   ;SET TO [VARTAB] BY CLEARC.
24740   DATPTR: BLOCK   2               ;POINTER TO DATA. INITIALIZED TO POINT
24760                                   ;AT THE ZERO IN FRONT OF [TXTTAB]
24780   IFE     LENGTH-2,<
24800   TRCFLG: BLOCK   1>              ;0 MEANS NO TRACE IN PROGRESS
24840   ;THE FLOATING ACCUMULATOR
24860   IFE     LENGTH-2,<
24880           BLOCK   1               ;[TEMPORARY LEAST SIGNIFICANT BYTE]
24900   DFACLO: BLOCK   4>              ;[FOUR LOWEST ORDERS FOR DOUBLE PRECISION]
24920   FACLO:  BLOCK   3               ;[LOW ORDER OF MANTISSA]
24940                                   ;[MIDDLE ORDER OF MANTISSA]
24960                                   ;[HIGH ORDER OF MANTISSA]
24980   FAC:    BLOCK   2               ;[EXPONENT]
25000                                   ;[TEMPORARY COMPLEMENT OF SIGN IN MSB]
25020   IFE     LENGTH-2,<
25030           BLOCK   1               ;[TEMPORARY LEAST SIGNIFICANT BYTE]
25040   ARGLO:  BLOCK   7               ;[LOCATION OF SECOND ARGUMENT FOR DOUBLE
25060   ARG:    BLOCK   1>              ; PRECISION]
25080   FBUFFR  BLOCK   13              ;BUFFER FOR FOUT
25100   IFE     LENGTH-2,<BLOCK 35-13>
25120   PAGE
25140   SUBTTL  TEXT CONSTANTS FOR PRINT OUT
25160   ;
25180   ; NEEDED FOR MESSAGES IN ALL VERSIONS
25200   ; MUST BE STORED ABOVE DSCTMP OR ELSE STRLIT
25220   ; WILL COPY THEM BEFORE STRPRT PRINTS THEM. THIS IS BAD, SINCE IF THE
25240   ; USER IS OUT OF STRING SPACE BASIC WILL LOOP GETTING "OUT OF STRING SPACE"
25260   ; ERRORS.
25280   ;
25300   IFN     LENGTH-2,<
25320   ERR:    DC" ERROR"
25340           0>
25360   INTXT:  DC" IN "
25380           0
25400   REDDY:  ACRLF
25420           DC"OK"
25440           ACRLF
25460           0
25480   IFN     LENGTH,<
25500   BRKTXT: ACRLF
25520           DC"BREAK"
25540           0>
25580   PAGE
25600   SUBTTL  GENERAL STORAGE MANAGEMENT ROUTINES
25620   ;
25640   ; FIND A FOR ENTRY ON THE STACK WITH THE VARIABLE POINTER
25660   ; PASSED IN [D,E].
25680   ;
25700   FNDFOR: LXI     H,4+$CODE       ;IGNORING EVERYONES "NEWSTT"
25720                                   ;AND THE RETURN ADDRESS OF THIS
25740           DAD     SP              ;SUBROUTINE, SET [H,L]=SP
25760   LOOPER: MOV     A,M             ;SEE WHAT TYPE OF THING IS ON THE STACK
25780           INX     H
25800           CPI     FORTK           ;IS THIS STACK ENTRY A FOR?
25820   RNZ                             ;NO SO OK
25840   IFE     LENGTH,<
25860           PUSHM                   ;GET VARIABLE NAME
25880           XTHL>
25900   IFN     LENGTH,<
25920           MOV     C,M
25940           INX     H               ;DO EQUIVALENT OF PUSHM / XTHL
25960           MOV     B,M
25980           INX     H
26000           PUSH    H               ;PUT H  ON
26020           MOV     L,C             ;PUSH B / XTHL IS SLOWER
26040           MOV     H,B
26060           MOV     A,D             ;FOR THE "NEXT" STATEMENT WITHOUT AN ARGUMENT
26080           ORA     E               ;WE MATCH ON ANYTHING
26100           XCHG                    ;MAKE SURE WE RETURN (D,E)
26120           JZ      POPGOF          ;POINTING TO THE VARIABLE
26140           XCHG>
26160           COMPAR
26180   POPGOF: LXI     B,$CODE+13      ;TO WIPE OUT A FOR ENTRY
26200           POP     H
26220           RZ                      ;IF FOR MATCHES GOOD
26240           DAD     H
26260           JMP     LOOPER          ;TRY THE NEXT ONE
26280   ;
26300   ; THIS IS THE BLOCK TRANSFER ROUTINE
26320   ; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD
26340   ;
26360   ; [H,L] = DESTINATION OF HIGH ADDRESS
26380   ; [D,E] = LOW ADDRESS TO BE TRANSFERRED
26400   ; [B,C] = HIGH ADDRESS TO BE TRANSFERRED
26420   ;
26440   ; A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT
26460   ; OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND THE HIGHEST LOCATION
26480   ; TRANSFERRED INTO
26500   ;
26520   ; ON EXIT [H,L]=[D,E]=LOW [B,C]=LOCATION LOW WAS MOVED INTO
26540   ;
26580   BLTU:   CALL    REASON          ;CHECK DESINTATION TO MAKE
26600                                   ;SURE THE STACK WON'T BE OVERRUN
26620   BLTUC:  PUSH    B               ;EXCHANGE [B,C] AND [H,L]
26640           XTHL
26660           POP     B
26680   BLTLOP: COMPAR                  ;SEE IF WE ARE DONE
26700           MOV     A,M             ;GET THE WORD TO TRANSFER
26720           STAX    B               ;TRANSFER IT
26740           RZ
26760           DCX     B
26780           DCX     H               ;BACKUP FOR NEXT GUY
26800           JMP     BLTLOP
26820   ;
26840   ; THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER
26860   ; OF LOCATIONS REMAIN AVAILABLE FOR THE
26880   ; STACK. THE CALL IS :
26900   ;       CALL    GETSTK
26920   ;       NUMBER OF 2 BYTE ENTRIES NECESSARY
26940   ;
26960   ; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
26980   ; AN ARBITRARY AMOUNT OF STUFF ON THE STACK
27000   ; (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)
27020   ; IT IS ALSO CALLED BY ROUTINES SUCH AS GOSUB AND FOR
27040   ; WHICH MAKE PERMANENT ENTRIES ON THE STACK
27060   ;
27080   ;
27100   ; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
27120   ; NUMLEV STACK LOCATIONS NEED NOT CALL THIS
27140   ;
27160   GETSTK: XTHL
27180           MOV     C,M             ;GET ARUGMENT INTO [C]
27220           INX     H
27240           XTHL                    ;PUT BACK RETURN ADDRESS
27260           PUSH    H               ;SAVE [H,L]
27280           LHLD    STREND
27300           MVI     B,0
27320           DAD     B
27340           DAD     B               ;SEE IF WE CAN HAVE THIS MANY
27360           CALL    REASON
27380           POP     H               ;RESTORE [H,L]
27400           RET
27440   ;
27460   ; [H,L]= SOME ADDRESS
27480   ; [H,L] IS EXAMINED TO MAKE SURE AT LEAST NUMLEV
27500   ; LOCATIONS REMAIN BETWEEN IT AND THE TOP OF THE STACK
27520   ;
27560   REASON: PUSH    D               ;SAVE [D,E]
27580           XCHG                    ;PUT [H,L] IN [D,E]
27600           LXI     H,$CODE+65536-2*NUMLEV  ;SETUP OFFSET OF GUARANTEED
27620                                   ;LOCATIONS
27640           DAD     SP              ;[H,L]=STACK POINTER + OFFSET
27660           COMPAR                  ;SEE IF THIS IS .GT. ETNERING [H,L]
27680           XCHG                    ;RESTORE [H,L] FROM [D,E]
27700           POP     D               ;GET [D,E] BACK
27720           RNC                     ;WAS OK?
27740   OMERR:  MVI     E,EEPROM        ;"OUT OF MEMORY"
27760   IFE     LENGTH,<
27780           XWD     ^O1000,1>       ;"LXI B," OVER THE NEXT 2
27800   IFN     LENGTH,<
27820           JMP     ERROR>
27840   PAGE
27860   SUBTTL ERROR HANDLER, READY, COMPACTIFICATION, NEW, CLEAR, MAIN
27880   IFN      LENGTH,<
27900   DATSNE: LHLD    DATLIN          ;GET DATA LINE
27920           SMLD    CURLIN>         ;MAKE IT CURRENT LINE
27940   SNERR:  MVI     E,ERRSN         ;"SYNTAX ERROR"
27960           XWD     ^O1000,1        ;"LXI B," OVER THE NEXT 2
27980   DV0ERR: MVI     E,ERRDV0        ;DIVISION BY ZERO
28000   IFN     LENGTH,<
28020           XWD     ^O1000,1        ;SKIP NEXT TWO
28040   NFERR:  MVI     E,ERRNF>        ;"NEXT WITHOUT FOR" ERROR
28060   ERROR:  CALL    STKINI          ;RESET THE STACK AND FLAGS
28080   IFN     CONTRW,<
28100           XRA     A
28120           STA     CNTWFL>         ;FORCE OUTPUT
28140           CALL    CRDO            ;CRLF
28220           LXI     H,ERRTAB        ;GET START OF ERROR TABLE
28240   IFE     LENGTH-2,<
28260   LEPSKP: CALL    REM             ;SKIP AN ERROR MESSAGE
28280           DCR     E               ;DECREMENT ERROR COUNT
28282           INX     H               ;SKIP OVER THIS ERROR MESSAGE
28300           JNZ     LEPSKP>         ;SKIP SOME MORE
28320   IFN     LENGTH-2<
28322           MOV     D,A             ;GET ZERO INTO D
28324           MVI     A,"7"           ;START OF ERROR MESSAGE
28326           OUTCHR                  ;TYPE IT
28340           DAD     D               ;ADD IN ERROR CODE
28360           MOV     A,M             ;GET FIRST ERROR CHARACTER
28380           OUTCHR                  ;TYPE IT
28400           CHRGET                  ;GET 2ND CHARACTER OF ERROR CODE
28420           OUTCHR                  ;TYPE IT
28440           LXI     H,ERR>          ;GET POINTER TO " ERROR"
28460   ERRFIN: CALL    STROUT          ;TYPE IT
28480           LHLD    CURLIN          ;CURRENT LINE #
28500           MOV     A,H             ;SEE IF IN DIRECT MODE
28520           ANA     L
28530           INR     A               ;ZERO SAYS DIRECT MODE
28560           CNZ     INPUT           ;PRINT LINE NUMBER IN [H,L]
28580   IFE     LENGTH,<
28600           XWD     ^O1000,1        ;"LXI B," OVER THE NEXT 2
28620   END:
28640   STOP:   RNZ                     ;MAKE SURE HE TERMINATED IT
28660   STPEND: POP     B               ;GET RID OF "NEWSTT" RETURN ADDRESS
28680   ENDCON:>
28682   IFE     LENGTH-2,<
28684   ;
28686   ; FOR "LIST" COMMAND STOPPING
28688   ;
28890           XWD     ^O1000,^O76             ;SKIP THE NEXT BYTE
28892   STPRDY: POP     B>
28700   READY:  IFN     LPTSW,<
28720           CALL    FINLPT>         ;PRINT ANY LEFT OVERS
28740   IFN     CONTRW,<
28760           XRA     A
28780           STA     CNTWFL>         ;FORCE OUTPUT
28800           LXI     H,$CODE+65535
28820           SHLD    CURLIN          ;SETUP CURLIN FOR DIRECT MODE
28840           LXI     H,REDDY         ;"READY" CRLF CRLF
28860   REPINI: CALL    INIT            ;PRINT IT. REPLACED BY CALL STROUT
28880                                   ;BY THE INIT CODE. THIS IS HERE SO AFTER
28900                                   ;ERRORS DURING INIT. INIT IS RESTARTED
28920   MAIN:   CALL    INLIN           ;GET A LINE FROM TTY
28940           CHRGET                  ;GET THE FIRST
28960           INR     A               ;SEE IF 0 SAVING THE CARRY FLAG
28980           DCR     A
29000           JZ      MAIN            ;IF SO, A BLANK LINE WAS INPUT
29020           PUSH    PSW             ;SAVE STATUS INDICATOR FOR 1ST CHARACTER
29040           CALL    LINGET          ;READ IN A LINE #
29060           PUSH    D               ;SAVE LINE #
29080           CALL    CRUNCH          ;CRUNCH THE LINE DOWN
29100           MOV     B,A             ;A=0 AFTER CRUNCH, [B,C]=CHAR COUNT FOR NODEL
29120           POP     D               ;RESTORE LINE #
29140           POP     PSW             ;WAS THERE A LINE #?
29160           JNC     GONE            ;IF NOT ITS A DIRECT STATEMENT
29180           PUSH    D
29200           PUSH    B               ;SAVE LINE # AND CHARACTER COUNT
29220           CHRGET                  ;REMEMBER IF THIS LINE IS
29240           PUSH    PSW             ;BLANK SO WE DON'T INSERT IT
29260           CALL    FNDLIN          ;GET A POINTER TO THE LINE
29280           PUSH    B               ;SAVE THE POINTER
29300   IFE     LENGTH-2,<
29320           CC      DEL>            ;DELETE THE LINE
29340   IFN     LENGTH-2,<
29360           JNC     NODEL           ;NO MATCH SO DON'T DELETE
29380           XCHG                    ;[D,E] NOW HAS THE POINTER TO THE LINE
29400                                   ;BEYOND THIS ONE
29420           LHLD    VARTAB          ;COMPACTIFYING TO VARTAB
29440   MLOOP:  LDAX    D
29460           STAX    B               ;SHOVING DOWN TO ELIMINATE A LINE
29480           INX     B
29500           INX     D
29520           COMPAR
29540           JNC     MLOOP           ;DONE COMPACTIFYING?
29560           MOV     H,B
29580           MOV     L,C
29600           INX     H               ;NEW VARTAB
29620           SHLD    VARTAB>
29640   NODEL:  POP     D               ;POP POINTER AT PLACE TO INSERT
29660           POP     PSW             ;SEE IF THIS LINE HAD
29680                                   ;ANYTHING ON IT
29700           JZ      FINI            ;IF NOT DON'T INSERT
29720           LHLD    VARTAB          ;CURRENT END
29740           XTHL                    ;[H,L]=CHARACTER COUNT, VARTAB
29760                                   ;ONTO THE STACK
29780           POP     B               ;[B,C]=OLD VARTAB
29800           DAD     B
29820           PUSH    H               ;SAVE NEW VARTAB
29840           CALL    BLTU
29860           POP     H               ;POP OFF VARTAB
29880           SHLD    VARTAB          ;UPDATE VARTAB
29900           XCHG
29920           MOV     M,H             ;FOOL CHEAD WITH NON-ZERO LINK
29940           INX     H               ;SO IT DOESN'T THINK
29960                                   ;THIS LINK IS THE
29980                                   ;END OF THE PROGRAM
30000           INX     H
30020           POP     D               ;GET LINE # OFF STACK
30040           MOV     M,E
30060           INX     H               ;PUT DOWN LINE #
30080           MOV     M,D
30100           INX     H
30140           LXI     D,BUF           ;MOVE LINE FROM BUF TO PROGRAM AREA
30160   MLOOPR: LDAX    D               ;NOW TRANSFERING LINE
30180                                   ;IN FROM BUF
30200           MOV     M,A
30220           INX     H
30240           INX     D
30260           ORA     A               ;ZERO MARKS THE END
30280           JNZ     MLOOPR
30300   FINI:   CALL    RUNC            ;DD CLEAR & SET UP STACK
30320                                   ;ALSO SETS [H,L] TO [TXTTAB]-1
30340           INX     H
30360   ;
30380   ; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
30400   ; UP ALL THE LINKS. THE END OF EACH
30420   ; LINE IS FOUND BY SEARCHING FOR THE ZERO AT THE END.
30440   ; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM
30460   ;
30480   CHEAD:  MOV     D,H             ;[D,E]=[H,L]
30500           MOV     E,L
30520           MOV     A,M             ;SEE IF END OF CHAIN
30540           INX     H               ;BUMP POINTER
30560           ORA     M               ;2ND BYTE
30580           JZ      MAIN            ;DONE
30600           INX     H               ;FIX H TO START OF TEXT
30620           INX     H
30640           INX     H
30660           XRA     A               ;SEARCHING FOR A ZERO IN MEMORY
30680   CZLOOP: CMP     M               ;TO MARK THE END OF THIS LINK
30700           INX     H               ;BUMP POINTER
30720           JNZ     CZLOOP          ;END OF LINE
30770           XCHG                    ;SWITCH TEMP
30760           MOV     M,E             ;DO FIRST BYTE OF FIXUP
30780           INX     H               ;ADVANCE POINTER
30800           MOV     M,D             ;2ND BYTE OF FIXUP
30820           XCHG                    ;AND BACK AGAIN
30840           JMP     CHEAD           ;KEEP CHAINING TIL DONE
30860   IFE     LENGTH-2,<
30880   ;
30900   ; SCNLIN SCANS A LINE RANGE OF
30920   ; THE FORM #-# OR # OR #- OR -# OR BLANK
31940   ; AND THEN FINDS THE FIRST LINE IN THE RANGE
31960   ;
31980   SCNLIN: LXI     D,$CODE         ;ASSUME START OF LIST AT ZERO
31000           PUSH    D               ;SAVE INITIAL ASSUMPTION
31020           JZ      ALLLST          ;IF FINISHED, LIST IT ALL
31040           POP     D               ;WE ARE GOING TO GRAB A #
31060           CALL    LINGET          ;GET A LINE #, IF NONE, RETURNS ZERO
31080           PUSH    D               ;SAVE FIRST
31100           JZ      ONELIN          ;IF ONLY # THEN DONE.
31120           SYNCHK  MINUTK          ;MUST BE A DASH.
31140   ALLLST: LXI     D,$CODE+^D65529 ;ASSUME MAX END OF RANGE
31160           CNZ     LINGET          ;GET THE END OF RANGE
31180           JNZ     SNERR           ;MUST BE TERMINATOR
31200   ONELIN: XCHG                    ;[H,L] = FINAL
31220           POP     D               ;GET INITIAL IN [D,E]
31240           XTHL                    ;PUT MAX ON STACK, RETURN ADDR TO [H,L]
31260           PUSH    H>              ;SAVE RETURN ADDRESS BACK
31280   ;
31300   ; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
31320   ; WHOSE LINE # IS PASSED IN [D,E]. [D,E] IS PRESERVED.
31340   ; THERE ARE THREE POSSIBLE RETURNS:
31360   ;
31380   ;       1) ZERO FLAG SET. CARRY NOT SET. LINE NOT FOUND.
31400   ;          NO LINE IN PROGRAM GREATER THAN ONE SOUGHT.
31420   ;          [B,C] POINTS TO TWO ZERO BYTES AT END OF PROGRAM.
31440   ;          [H,L]=[B,C]
31460   ;
31480   ;       2) ZERO, CARRY SET.
31500   ;          [B,C] POINTS TO THE LINK FIELD IN THE LINK
31520   ;          WHICH IS THE LINE SEARCHED FOR.
31540   ;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
31560   ;
31580   ;       3) NON-ZERO, CARRY NOT SET.
31600   ;          LINE NOT FOUND. [B,C]  POINTS TO LINE IN PROGRAM
31620   ;          GREATER THAN ONE SEARCHED FOR.
31640   ;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
31660   ;
31680   FNDLIN: LHLD    TXTTAB          ;GET POINTER TO START OF TEXT
31700   LOOP:   MOV     B,H             ;IF EXITING BECAUSE OF END OF PROGRAM,
31720                                   ;SET [B,C] TO POINT TO DOUBLE ZEROES.
31740           MOV     C,L
31760           MOD     A,M             ;GET WORD POINTER TO
31780           INX     H               ;BUMP POINTER
31800           ORA     M               ;GET 2ND BYTE
31820           DCX     H               ;GO BACK
31840           RZ                      ;IF ZERO THEN DONE
31860           PUSH    B
31880           PUSHM                   ;PUSH LINK
31900           PUSHM                   ;PUSH BINARY LINE #
31920           POP     H               ;POP HERE
31940           COMPAR                  ;COMPARE [D,E] TO [H,L]
31960           POP     H               ;GET LINK
31980           POP     B               ;GET POINTER TO THIS LINE IN [B,C]
32000           CMC                     ;TURN CARRY ON
32020           RZ                      ;EQUAL RETURN
32040           CMC                     ;MAKE CARRY ZERO
32060           RNC                     ;NO MATCH RETURN (GREATER)
32080           JMP     LOOP            ;KEEP LOOKING
32100   ;
32120   ; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
32140   ; AS VARIABLE SPACE
32160   ;
32180   SCRATH: RNZ                     ;MAKE SURE THERE IS A TERMINATOR
32200   SCRTCH: LHLD    TXTTAB
32220   IFN     LENGTH-2,<
32240           XHA     A>
32260   IFE     LENGTH-2,<
32280           CALL    TOFF>           ;TURN OFF TRACE. SET [A]=0
32300           MOV     M,A             ;SAVE AT END OFF TEXT
32320           INX     H               ;BUMP POINTER
32340           MOV     M,A             ;SAVE ZERO
32360           INX     H               ;BUMP POINTER
32380           SHLD    VARTAB          ;NEW START OF VARIABLE
32400   IFE     LENGTH,<
32420   RUN:    RNZ>                    ;CHECK FOR A TERMINATOR
32440   RUNC:   LHLD    TXTTAB          ;POINT AT THE START OF TEXT
32460           DCX     H
32480   ;
32500   ; CLEARC IS A SUBROUTINE WHICH INITIALIZES THE VARIABLE AND
32520   ; ARRAY SPACE BY RESETING ARYTAB (THE END OF SIMPLE VARIABLE SPACE)
32540   ; AND STREND (THE END OF ARRAY STORAGE). IT FALLS INTO STKINI
32560   ; WHICH RESETS THE STACK. [H,L] IS PRESERVED.
32580   ;
32600   IFE     STRING,<CLEAR:>
32620   CLEARC: SHLD    TEMP            ;SAVE [H,L] IN TEMP
32640   IFN     STRING,<
32660           LHLD    MEMSIZ
32680           SHLD    FRETOP>         ;FREE UP STRING SPACE
32700           CALL    RESTORE         ;RESTORE DATA
32720           LHLD    VARTAB          ;GET START OF VARIABLE SPACE
32740           SHLD    ARYTAB          ;SAVE IN START OF ARRAY SPACE
32760           SHLD    STREND          ;AND END OF VARIABLE STORAGE
32780   ;
32800   ; STKINI RESETS THE STACK POINTER ELIMINATING
32820   ; GOSUB & FOR CONTEXT.  STRING TEMPORARIES ARE FREED
32840   ; UP, SUBFLG IS RESET, CONTINUING IS DISALLOWED,
32860   ; AND A DUMMY ENTRY IS PUT ON THE STACK. THIS IS SO
32880   ; FNDFOR WILL ALWAYS FIND A NON-"FOR" ENTRY AT THE BOTTOM
32900   ; OF THE STACK. [A]=0 AND [D,E] IS PRESERVED
32920   ;
32940   STKINI: POP     B               ;GET RETURN ADDRESS HERE
32960           LHLD    STKTOP          ;[H,L] POINTER TO END OF MEMORY
32980           SPHL                    ;INITIALIZE STACK
33000   IFN     STRING,<
33020           LXI     H,TEMPST
33040           SHLD    TEMPPT>         ;INITIALIZE STRING TEMPORARIES
33060           LXI     H,$CODE         ;PUT ZERO (NON NEXT, FOR GOSUB TOKEN)
33080           PUSH    H               ;ON STACK
33100   IFN     LENGTH,<SHLD    OLDTXT> ;MAKE CONTINUING ILLEGAL
33120   IFN     LPTSW,<
33140           CALL    FINLPT>
33160           LHLD    TEMP            ;GET SAVED [H,L]
33180   IFN     LENGTH,<
33200   IFE     CONTRW,<XRA     A>
33220           STA     SUBFLG>         ;ALLOW SUBSCRIPTS
33240           PUSH    B               ;PUT RETURN ADDRESS BACK ON
33260           RET                     ;GO BACK
33300   QINLIN: MVI     A,"?"           ;GET A QMARK
33320           OUTCHR                  ;TYPE IT
33340           MVI     A," "           ;SPACE
33360           OUTCHR                  ;TYPE IT TOO
33380   IFE     STRING,<CALL    INLIN   ;IN THE NON-STRING VERSION ALL
33400                                   ;INPUT IS CRUNCHED
33420           INX     H>              ;GET A LINE OF INPUT FROM TTY
33440   IFN     STRING,<JMP     INLIN>  ;NO CRUNCHING IN THIS CASE
33460   ;
33520   ; ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
33540   ; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME
33560   ; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
33580   ; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
33600   ; RESERVED WORD LIST IN THE SAME
33620   ; ORDER THEY APPEAR IN IN STMDSP.
33640   ;
33700   CRUNCH: IFN     STRING,<
33720           XRA     A
33740           STA     DORES>          ;ALLOW CRUNCHING
33760           MVI     C,5             ;COUNT OF CHARS AT LEAST 5
33780           LXI     D,BUF           ;SETUP DESTINATION POINTER
33800   KLOOP:  MOV     A,M             ;GET CHARACTER FROM BUF
33820           CPI     " "             ;IS IT A SPACE WE WANT TO SAVE
33840           JZ      STUFFH          ;YES, STUFF IN DESTINATION LINE.
33860           MOV     B,A             ;GET A CHARACTER FROM THE LINE
33880                                   ;SETUP B WITH A QUOTE IF IT IS A STRING
33900           CPI     34              ;QUOTE SIGN?
33920           JZ      STRNG           YES, GO TO SPECIAL STRING HANDLING
33940           ORA     A               ;END OF LINE?
33960           JZ      CRDONE          ;YES, DONE CRUNCHING
33980   IFN     STRING,<
34000           LDA     DORES           ;IN DATA STATEMENT AND NO CRUNCH?
34020           ORA     A
34040           MOV     B,A             ;INITIALIZE RESERVED WORD COUNT
34060           MOV     A,M             ;GET THE CHARACTER AGAIN
34080           JNZ     STUFFH>         ;IF NO CRUNCHING JUST STORE
34100                                   ;THE CHARACTER
34120   IFN     LENGTH,<                ;NOT FOR 4K VERSION
34140           CPI     "?"             ;A QMARK?
34160           MVI     A,PRINTK
34180           JZ      STUFFH          ;THEN USE A "PRINT" TOKEN
34200           MOV     A,M
34220           CPI     "0"             ;SKIP NUMERICS
34240           JC      MUSTCR          ;SINCE CRUNCHING IS SLOW
34260           CPI     60              ;":" ALSO PUT IN QUICKLY
34280           JC      STUFFH
34300   MUSTCR: >
34320           PUSH    D               ;SAVE STORE POINTER
34340   IFE     STRING,<
34460           MVI     B,0>            ;INIT RESERVED WORD COUNT
34480           LXI     D,RESLST-1      ;INIT TO RESERVED WORD LIST
34400           PUSH    H               ;SAVE IN BUF POINTER
34420           XWD     ^O1000,^O76     ;"MVI" AROUND CHRGET
34440   NEXRES: CHRGET                  ;GET CHAR FROM LINE
34460           INX     D               ;BUMP DEPOSIT POINTER
34480   RESER:  LDAX    D               ;GET A BYTE FROM RESERVED WORD LIST
34500           ANI     127             ;GET RID OF SIGN BIT
34520           JZ      TABEND          ;END OF RESERVED WORD TABLE
34540           CMP     M               ;TWO CHARS THE SAME?
34560           JNZ     NTHIS           ;NO, DIFFERENT
34580           LDAX    D               ;GET RESERVED WORD BYTE
34600           ORA     A               ;SET CONDITION CODES
34620           JP      NXTRES          ;IF SIGN SET, RESERVED WORD FOUND
34640   FOUND:  POP     PSW             ;TAKE OFF GARBAGE ORIG POINTER
34660           MOV     A,8             ;GET RESERVED WORD #
34680           ORI     128             ;SET MSB TO FLAG AS RESERVED WORD
34700           XWD     ^O1000,^O362    ;"JP" AROUND THE POP H AND MOV A,M
34720   TABEND: POP     H               ;GET BACK ORIG POINTER
34740           MOV     A,M             ;GET BACK ORIG CHAR
34760           POP     D               ;GET STUFF POINTER BACK
34780   IFE     LENGTH-2,<
34800           XCHG                    ;[H,L]=STUFF POINTER
34820           CPI     ELSETK          ;HAVE TO PUT A HIDDEN
34840                                   ;COLON IN FRONT OF "ELSE"S
34860           MVI     M,":"           ;STORE IT
34880           CZ      INXHRT##        ;ADVANCE POINTER ON "ELSE"
34900                                   ;SO ONLY ON "ELSE" THE COLON IS NOT OVERWRITTEN
34920           XCHG>                   ;[D,E]=STUFF POINTER
34940   STUFFH: INX     H               ;ENTRY TO BUMP [H,L]
34960           STAX    D               ;SAVE CHARACTER IN CRUNCHED LINE
34980           INX     D               ;BUMP SAVE POINTER
35000           INT     C               ;BUMP CRUNCHED CHARACTER COUNT
35020   IFN     STRING,<
35040           SUI     ":"             ;SEE IF IT IS A COLON
35060           JZ      COLIS           ;IF SO ALLOW CRUNCHING AGAIN
35080           CPI     DATATK-":"
35100           JNZ     NODATT          ;SEE IF IT IS A DATA TOKEN
35120   COLIS:  STA     DORES           ;SETUP FLAG
35140   NODATT: SUI     REMTK-":">
35160   IFE     STRING,<SUI     REMRK>  ;WAS IT A REM STATEMENT
35180           JNZ     KLOOP           ;KEEP LOOPING
35200           MOV     B,A             ;REM DOESN'T STOP ON ":", ONLY ON A ZERO
35220   STR1:   MOV     A,M             ;GET A CHAR
35240           ORA     A               ;SET CONDITION CODES
35260           JZ      CRDONE          ;IF END OF LINE THEN DONE
35280           CMP     B               ;END OF GOBBLE
35300           JZ      STUFFH          ;IF YES, DONE WITH STRING
35320   STRNG:  INX     H               ;INCREMENT TEXT POINTER
35340           STAX    D               ;STORE CHAR
35360           INR     C               ;BUMP COUNT
35380           INX     D               ;AND POINTER
35400           JMP     STR1            ;KEEP LOOPING
35440   NTHIS:  POP     H               ;RESTORE TEXT STRING
35460           PUSH    H               ;AND SAVE IT BACK
35480           INR     B               ;INCREMENT RESERVED WORD #
35500           XCHG                    ;RESLST POINTER INTO [H,L]
35520   NTHIS1: ORA     H               ;TEST BITS IN THE RESERVED WORD LIST
35540           INX     H
35560           JP      NTHIS1          ;SKIP MORE
35580           XCHG                    ;RESLST POINTER INTO [H,L]
35600                                   ;TEXT POINTER INTO [H,L]
35620           JMP     RESER
35640   CRDONE: LXI     H,BUFMIN        ;LEAVE WITH [H,L] POINTER TO START OF LINE
35660           STAX    D               ;NEED THREE 0'S ON THE END
35680           INX     D               ;ONE FOR END-OF-LINE
35700           STAX    D               ;AND 2 FOR A ZERO LINK
35720           INX     D               ;SINCE IF THIS IS A DIRECT STATEMENT
35740           STAX    D               ;ITS END MUST LOOK LIKE THE END OF A PROGRAM
35760           RET                     ;END OF CRUNCHING
35780   ;
35800   ; THIS IS THE LINE INPUT ROUTINE
35820   ; IT READS CHARACTERS INTO BUF USING _ AS THE
35840   ; CHARACTER DELETE CHARACTER AND # AS THE LINE DELETE CHARACTER
35860   ; IF MORE THAN BUFLEN CHARACTER ARE TYPED, NO ECHOING
35880   ; IS DONE UNTIL A  _ # OR CARRIAGE-RETURN IS TYPED.
35900   ; CONTROL-G WILL BE TYPED FOR EACH EXCTRA CHARACTER.
35920   ; THE ROUTINE IS ENTERED AT INLIN
35940   ;
35960   LINLIN: DCR     B               ;BACK ARROW SO DECREMENT COUNT
35980           DCX     H               ;BACK UP POINTER
36000   IFN     REALIO,<
36020           OUTCHR>
36040           JNZ     INLINC          ;NOT TOO MANY SO CONTINUE
36060   INLINN: IFN     REALIO,<
36080           OUTCHR>                 ;PRINT THE #, OR A SECOND _ IF THERE
36100                                   ;WERE TOO MANY
36120           CALL    CRDO            ;TYPE A CRLF
36140   INLIN:  LXI     H,BUF
36160           MVI     B,1             ;CHARACTER COUNT
36180   INLINC: CALL    INCHR           ;GET A CHARACTER
36182   IFN     LENGTH,<
36184           CPI     7               ;IS IT BOB ALBRECHT RINGING THE BELL
36186           JZ      GOODCH>         ;FOR SCHOOL KIDS?
36200           CPI     13              ;IS IT A CARRAGE RETURN?
36220           JZ      FININL          ;IF SO FINISH UP
36240           CPI     32              ;CHECK FOR FUNNY CHARACTERS
36260           JC      INLINC
                CPI     125
36300           JNC     INLINC          ;BIG ONES BAD TOO
36320           CPI     "#"             ;LINE DELETE?
36340           JZ      INLINN
36360           CPI     "_"             ;CHARACTER DELETE
36380           JZ      LINLIN
36400   GOODCH: MOV     C,A
36420           MOV     A,B
36440           CPI     BUFLEN
36460           MVI     A,7             ;GET A BELL IN CASE LINE TOO LONG.
36480           JNC     OUTBEL          ;LINE TOO LONG, RING BELL.
36500           MOV     A,C
36520           MOV     M,C             STORE THIS CHARACTER
36540           INX     H
36560           INR     B
36580   OUTBEL:
36660   IFN     REALIO,<
36620           OUTCHR>
36640           JMP     INLINC
36660   OUTCON:
36680   IFN     CONTRW,<
36700           JNZ     PPSWRT>         ;NO, DO OUTPUT
36720   IFN     REALIO,<                ;MITS I/O
36740   IFN     LPTSW,<
36760           LDA     PRTFLG          ;SEE IF WE WANT TO TALK TO LPT
36780           ORA     A               ;TEST BITS
36800           JZ      TTYCHR          ;IF ZERO THEN NOT
36820           POP     PSW             ;GET CHARACTER WE WANT TO PRINT
36840           PUSH    PSW
36860           CPI     13              ;IS IT CARRIAGE RETURN?
37880           CZ      PRINTW          ;FORCE OUT A LINE
37900           JC      PPSWRT          ;IF FUNNY CONTROL CHARACTER (LF) DO NOTHING
37920           LDA     LPTPOS          ;WHERE ARE WE?
37940           CPI     LPTLEN          ;AT THE END?
36960           CNC     PRINTW          ;YES, START OVER
36980           INR     A
37000           STA     LPTPOS
37020   LPTWAT: IN      2
37040           ANI     2
37060           JZ      LPTWAT
37080           POP     PSW
37100           OUT     3               ;SEND OUT CHAR
37120           RET                     ;RETURN
37140   PATLPT: BLOCK   20
37160   FINLPT: XRA     A               ;RESET PRINT FLAG SO OUTPUT
37180           STA     PRTFLG          ;GOES TO THE TERMINAL
37200           LDA     LPTPOS          ;SEE IF ANY LEFTOVERS MUST BE
37220           ORA     A               ;FORCED OUT
37240           RZ                      ;BY LOOKING AT LPTPOS
37260   PRINTW: IN      2               ;MAKE SURE LAST PRINT
37280           ANI     2               ;FINISHED BY TESTING DONE
37300           JZ      PRINTW          ;BIT
37320   ;SEE IF BUFFER MUST BE EMPTIED
37340           LDA     LPTPOS
37360           ORA     A               ;CHARACTERS IN THE BUFFER?
37380           JNZ     PRINTR          ;IF SO DON'T CLEAR THE BUFFER
37400           MVI     A,4             ;OTHERWISE BUFFER MUST BE EMPIT
37420           OUT     2               ;CLEAR THE BUFFER
37440                                   ;TO PRINT A BLANK LINE
37460   PRINTR: MVI     A,1             ;TELL LPT TO PRINT
37480           OUT     2               ;STATUS REG
37500           DCR     A               ;[A]=0
37520           STA     LPTPOS          ;RESET LINE PRINT POSITION
37540           RET>
37560   TTYCHAR:>
37580   IFN     STRING,<
37600           POP     PSW             ;GET THE CHARACTER
37620           PUSH    PSW             ;AND SAVE IT AGAIN
37640           CPI     32              ;IS THIS A MEANINGFUL CHARACTER?
37660           JC      TRYOUT>         ;IF IT'S A NON-PRINTING CHARACTER
37680                                   ;DON'T INCLUDE IT IN TTYPOS
37700   IFN     LENGTH!CONTRW!LPTSW,<
37720           LDA     TTYPOS>         ;SEE IF PRINT READ IS AT THE END OF THE LINE
37740           CPI     LINLEN          ;MODIFIED BY "TERMINAL WIDTH?" QUESTION IN INIT
37760   LINPT1==:.-1
37780           CZ      CRDO            ;TYPE CRLF AND SET TTYPOS AND [A]=O IF SO
37800           INR     A               ;INCREMENT TTYPOS SINCE WE'RE
38820                                   ;GOING TO PRINT A CHARACTER.
37840           STA     TTYPOS          ;STORE NEW PRINT HEAD POSITION
37860   TRYOUT:
37880   IFN     REALIO,<
37900   NOPRIN: IN      0               ;GET STATUS
37920   CNLCA1==.-1                     ;CONSOLE COMMAND CHANGE LOC
37940           ANI     ODONE           ;OK TO SEND CHAR
37960           JNZ     NOPRIN>         ;KEEP LOOKING
37980           POP     PSW             ;GET CHARACTER BACK
38000           OUT     TTOCHN          ;SEND OUT THE CHAR
38020   CNLCB1==.-1                     ;CONSOLE COMMAND CHANGE LOC
38040           RET                     ;RETURN FROM OUTCHR
38100   INCHR:  IFN     REALIO,<
38120   TRYIN:  IN      0               ;GET STATUS
38140   CNLCA2==.-1                     ;CONSOLE COMMAND CHANGE LOC
38160           ANI     IDONE           ;TEST BIT
38180           JNZ     TRYIN>          ;GO BACK & DO IT AGAIN
38200           IN      TTICHN          ;GET A CHAR
38220   CNLCB2==.-1                     ;CONSOLE COMMAND CHANGE LOC
38240           ANI     127             ;GET RID OF PARITY BIT
38260   IFN     CONTRW,<
38280           CPI     CONTW           ;IS IT SUPRESS OUTPUT?
38300           RNZ
38320           LDA     CNTWFL
38340           CMA                     ;COMPLEMENT ITS STATE
38360           STA     CNTWFL>         ;SAVE BACK
38380           RET
38400   PAGE
38420   SUBTTL  THE "LIST" COMMAND
38460   IFN     LENGTH-2,<
38480   IFN     LPTSW,<
38500   LLIST:  MVI     A,1             ;GET NON ZERO VALUE
38520           STA     PRTFLG>         ;ASVE IN I/O FLAG
38540   LIST:   CALL    LINGET          ;GET LINE NUMBER INTO [D,E]
38560           RNZ                     ;MUST BE A TERMINATOR OR ERROR
38580           POP     B               ;GET RID OF NEWSTT RETURN ADDT
38600           CALL    FNDLIN          ;FIND LINE GREATER THAN OR EQUAL TO [D,E]
38620           PUSH    B               ;SAVE START POINTER
38640   LIST4:  POP     H               ;GET POINTER TO LINE
38660           PUSHM                   ;PUSH LINK
38680           POP     B               ;TAKE OFF FOR A SECOND
38700           MOV     A,B             ;SEE IF END OF CHAIN
38720           ORA     C
38740           JZ      READY
38760   IFN     LISTEN,<
38780           CALL    ISCNTC>         ;CHECK FOR CONTROL-C
38800           PUSH    B               ;PUT BACK ON
38820           CALL    CRDO            ;DO CRLF TO START OUT
38840           PUSHM                   ;PUSH LINE #
38860           XTHL                    ;GET LINE # INTO [H,L]
38880                                   ;AND WE WANT [H,L] ON THE STACK
38900           CALL    LINPRT          ;PRINT AS INT WITOUT LEADING SPACE
38920           MVI     A," "
38940   PRIT4:  POP     H               ;RESTORE POINTER TO START OF TEXT
38960   PLOOP:  OUTCHR                  ;ALWAYS A SPACE AFTER THE LINE #
38980           MOV     A,M             ;GET A CHARACTER FROM LINE.
39000           ORA     A               ;IS IT A RESERVED WORD
39020           INX     H               ;INCREMENT POINTER INTO TEXT
39040           JZ      LIST4           ;ZERO, END OF LINE, GET NEXT LINE
39060           JP      PLOOP           ;REGULAR CHAR, JUST PRINT IT
39080           SUI     127             ;GET RID OF SIGN BIT AND ADD ONE
39100           MOV     C,A             ;GET RESERVED WORD # IN C
39120           PUSH    H               ;SAVE CURRENT POSIT
39140           LXI     D,RESLST        ;GET RESLST POINTER.
39160   RESRCH: PUSH    D               ;SAVE
39180
39200   RESCR1: LDAX    D               ;GET CHARACTER FROM RESLST
39220           INX     D               ;BUMP RESLST POINTER
39240           ORA     A               ;TEST BITS
39260           JP      RESCR1          ;NOT AT END OF RESERVED WORD YET
39280           DCR     C               ;DECREMENT CHAR
39300           POP     H               ;POP START POINTER HERE
39320           JNZ     RESRCH          ;NOT AT END OF RESLST YET.
39340   ;HERE WHEN FOUND RIGHT RESERVED WORD
39360   PRIT3:  MOV     A,M             ;GET A CHARACTER FROM RESERVED WORD
39380           ORA     A               ;SET CONDITION CODES
39400           JM      PRIT4
39420           OUTCHR
39440           INX     H               ;BUMP RESLST POINTER
39460           JMP     PRIT3>          ;PRINT THE REST
39520   PAGE
39540   SUBTTL  "FOR" STATEMENT
39560   ;
39580   ; NOTE:
39600   ;
39620   ; A FOR ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
39640   ;
39680   ;
39700   ; LOW ADDRESS
39720   ;       TOKEN (FORTK IN HIGH BYTE)  1 BYTE
39740   ;       A POINTER TO THE LOOP VARIABLE  2 BYTES
39760   ;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
39780   ;       THE STEP 4 BYTES
39800   ;       THE UPPER VALUE 4 BYTES
39820   ;       THE LINE # OF THE "FOR" STATEMENT 2 BYTES
39840   ;       A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
39860   ; HIGH ADDRESS
39880   ;
39900   ; TOTAL 16 BYTES
39920   ;
39960   FOR:    IFN     LENGTH,<
39980           MVI     A,100
40000           STA     SUBFLG>         ;DONT RECOGNIZE SUBSCRIPTED VARIABLES
40020           CALL    LET             ;EAD THE VARIABLE AND ASSIGN IT
40040                                   ;THE CORRECT INTIAL VALUE
40060                                   ;AND STORE A POINTER
40080                                   ;TO THE VARIABLE IN [TEMP]
40100           XTHL                    ;SAVE TEXT PTR ON THE STACK
40120           CALL    FNDFOR          ;MUST HAVE VARIABLE POINTER IN [D,E]
40140           POP     D               ;[D,E]=TEXT POINTER
40160           JNZ     NOTOL           ;IF NO MATCHING ENTRY, DON'T
40180                                   ;ELIMINATE ANYTHING
40200           DAD     B               ;IN THE CASE OF "FOR"
40220                                   ;WE ELIMINATE THE MATCHING ENTRY
40240                                   ;AS WELL AS EVERYTHING AFTER IT
40260           SPHL                    ;DO THE ELIMINATION
40280                                   ;SINCE A MATCHING ENTRY WAS FOUND
40300   NOTOL:  XCHG                    ;[H,L]=TEXT POINTER
40320           CALL    GETSTK
40340           8                       ;MAKE SURE 16 BYTES ARE AVAILABLE
40360                                   ;OFF OF THE STACK
40380           PUSH    H               ;REALLY SAVE THE TEXT POINTER
40400           CALL    DATA            ;GET AN [H,L] THAT POINTS
40420                                   ;JUST BEYOND THE TERMINATOR
40440           XTHL                    ;PUT [H,L] POINTER TO TERMINATOR ON THE STACK
40460                                   ;AND RESTORE [H,L] AS TEXT POINTER AT
40480                                   ;VARIABLE NAME
40500           PUSH    H               ;PUSH THE TEXT POINTER ONTO THE STACK
40520           LHLD    CURLIN          ;[H,L] GET THE CURRENT LINE #
40540           XTHL                    ;NOW THE CURRENT LINE # IS ON THE STACK AND
40560                                   ;[H,L] IS THE TEXT POINTER
40580   IFN     LENGTH-2,<
40600   IFN     STRING,<CALL    CHKNUM>>
40620           SYNCHK  TOTK            ;"TO" IS NECESSARY
40640   IFN     LENGTH-2,<              ;READ FINAL VALUE
40660           CALL    FRMNUM>
40680   IFE     LENGTH-2,<
40700           CALL    FRCSNG>
40720           PUSH    H               ;SAVE THE TEXT POINTER
40740   IFE     LENGTH-2,<
40760           CALL    FRCSNG>
40780           CALL    MOVRF           ;GET THE STUFF
40800           POP     H               ;REGAIN TEXT POINTER
40820           PUSH    B               ;OPPOSITE OF PUSHR
40840           PUSH    D               ;SAVE THE SIGN OF THE INCREMENT
40860           LXI     B,$CODE+^O201*256
40880           MOV     D,C
40900           MOV     E,D             ;GET 1.0 IN THE REGISTERS
40920           MOV     A,M             ;GET TERMINATING CHARACTER
40940           CPI     STEPTK          ;DO WE HAVE "STEP" ?
40960           MVI     A,1             ;SETUP DEFAULT SIGN
40980           JNZ     ONEON           ;PUSH SOME CONSTANTS ON IF NOT
41000   IFN     LENGTH-2,<
41020   IFN     STRING,<
41040           CHRGET
41060           CALL    FRMNUM>>        ;READ THE STEP
41080   IFE     <LENGTH-2>&STRING,<
41100           CALL    FRMCHK>         ;DON'T NEED TO CHECK THE TYPE
41120           PUSH    H
41140   IFE     LENGTH-2,<
41160           CALL    FRCSNG>
41180           CALL    MOVRF           ;SET UP THE REGISTERS
41200           POP     H
41220           FSIGN                   ;GET THE SIGN OF THE INCREMENT
41240   ONEON:  PUSH    B               ;PUT VALUE ON BACKWARDS
41260           PUSH    D               ;OPPOSITE OF PUSHR
41280   IFORDN: PUSH    PSW             ;SAVE THE SIGN OF THE INCREMENT
41300           INX     SP              ;A ONE BYTE ENTRY ONLY
41320           PUSH    H
41340           LHLD    TEMP            ;GET THE POINTER TO THE VARIABLE BACK
41360           XTHL                    ;PUT THE POINTER TO THE VARIABLE
41380                                   ;ONTO THE STACK AND RESTORE THE TEXT POINTER
41400   NXTCON: MVI     B,FORTK         ;PUT A "FOR" TOKEN ONTO THE STACK
41420           PUSH    B
41440           INX     SP              ;THE "TOKEN" ONLY TAKES ONE BYTE OF
41460                                   ;STACK SPACE
41480   ;       JMP     NEWSTT          ;ALL DONE
41500   PAGE
41520   SUBTTL NEW STATEMENT FETCHER
41540   ;
41560   ;
41580   ;
41600   ;
41620   ;
41640   ;
41660   NEWSTT:
41680   IFN     LISTEN,<
41700   IFN     LENGTH,<
41720           IN      0               ;CHECK FOR A CHARACTER WITHOUT
41740                                   ;DOING A "CALL" FOR SPEED
41760   CNLCA4==:.-1
41780           ANI     IDONE           ;CHARACTER THERE?
41800           CZ      CNTCCN>         ;SEE IF IT'S A CONTROL-C
41820   IFE     LENGTH,<
41840           CALL    ISCNTC>>
41860   IFN     LENGTH,<
41880           SHLD    TEMP>           ;USED BY CONTINUE AND INPUT AND CLEAR
41900                                   ;TO REMEMBER HOW TO RESTART THIS
41920                                   ;STATEMENT
41940   IFN     LPTSW,<XRA      A       ;FOR PRINT TO GO TO TTY AFTER LPRINT
41960           STA     PRTFLG>
41980           MOV     A,M             ;GET CURRENT CHARACTER
42000                                   ;WHICH TERMINATED THE LAST STATEMENT
42020           CPI     ":"             ;IS IT A COLON
42040           JZ      GONE
42060           ORA     A
42080           JNZ     SNERR           ;MUST BE ZERO
42100           INX     H
42120           MOV     A,M             ;CHECK POINTER TO SEE IF
42140                                   ;IT IS ZERO, IF SO WE ARE AT THE
42160                                   ;END OF THE PROGRAM
42180           INX     H
42200           ORA     M               ;OR IN HIGH PART
42220           INX     H
42240           JZ      ENDCON          ;RAN OFF THE END -- OK
42260           MOVE    E,M
42280           INX     H
42300           MOV     D,M             ;GET LINE # IN [D,E]
42320           XCHG                    ;[H,L]=LINE #
42340           SHLD    CURLIN          ;SETUP CURLIN WITH THE CURRENT LINE #
42360   IFE     LENGTH-2,<              ;TRACE FEATURE
42380           LDA     TRCFLG          ;SEE IF TRACE IT ON
42400           ORA     A               ;NON-ZERO MEANS YES
42420           JZ      NOTTRC          ;SKIP THIS PRINTING
42440           PUSH    D               ;SAVE THE TEXT POINTER
42460           MVI     A,"["           ;FORMAT THE LINE NUMBER
42480           OUTCHR                  ;OUTPUT IT
42500           CALL    LINPRT          ;PRINT THE LINE # IN [H,L]
42520           MVI     A,"]"           ;SOME MORE FORMATING
42540           OUTCHR
42560           POP     D               ;[D,E]=TEXT POINTER
42580   NOTTRC:>
42600           XCHG                    ;RESTORE THE TEXT POINTER
42620   GONE:   CHRGET                  ;GET THE STATEMENT TYPE
42640           LXI     D,NEWSTT        ;PUSH ON A RETURN ADDRESS OF NEWSTT
42660           PUSH    D               ;STATEMENT
42680   GONE3:  RZ                      ;IF A TERMINATOR TRY AGAIN
42700                                   ;"IF" COMES HERE
42720   GONE2:  SUI     ENDTK           ;"ON ... GOTO" AND "ON ... GOSUB"
42740           JC      LET             ;MUST BE A LET
42760   NUMCMD=SCRATK-ENDTK+1
42780           CPI     NUMCMD
42800           JNC     SNERR           ;SOME RESERVED WORD,BUT NOT
42820                                   ;A STATEMENT RESERVED WORD
42840           RLC                     ;MULTIPLY BY 2
42860           MOV     C,A
42880           MVI     B,0
42900           XCHG
42920           LXI     H,STMDSP        ;STATEMENT DISPATCH TABLE
42940           DAD     B               ;ADD ON OFFSET
42960           MOV     C,M             ;PUSH THE ADDRESS TO GO TO ONTO
42980           INX     H               ;THE STACK
43000           MOV     B,M             ;PUSHM SAVES BYTES BUT NOT SPEED
43020           PUSH    B
43040           XCHG                    ;RESTORE THE TEXT POINTER
43060   IFE     LENGTH,<
43080           CHRGET                  ;EAT THE FIRST CHARACTER
43100           RET>                    ;GO DO THE STATEMENT
43120   IFN     LENGTH,<
43140   CHRGTR: INX     H               ;DUPLICATION OF CHRGET RST FOR SPEED
43160           MOV     A,M             ;SEE CHRGET RST FOR EXPLANATION
43180           CPI     ":"
43200           RNC>
43220   ;
43240   ; CHRCON IS THE CONTINUATION OF THE CHRGET RST
43260   ;
43280   CHRCON: CPI     " "             ;MUST SKIP SPACES
43300           JZ      CHRGTR          ;GET ANOTHER CHARACTER
43320           CPI     "0"             ;ALL CHARACTERS GREATER THAN
43340                                   ;"9" HAVE RETURNED, SO SEE IF NUMERIC
43360           CMC                     ;MAKE NUMERICS HAVE CARRY ON
43380           INR     A               ;SET ZERO IF [A]=0
43400           DCR     A
43420           RET
43440   PAGE
43460   SUBTTL RESTORE,STOP,END,LINGET,CHRCON
43500   RESTOR: XCHG                    ;SAVE [H,L] IN [D,E]
43520           LHLD    TXTTAB
43540           DCX     H               ;INITIALIZE DATPTR TO [TXTTAB]-1
43560   RESFIN: SHLD    DATPTR          ;READ FINISHES COME TO RESFIN
43580           XCHG                    ;GET THE TEXT POINTER BACK
43600           RET
43640   IFN     LISTEN,<
43660   ISCNTC: IN      0
43680   CNLCA3==.-1                     ;CONSOLE COMMAND CHANGE LOC
43700           ANI     IDONE
43720           RNZ                     ;IF NO CHARACTERS THAN NO ^C
43740   CNTCCN: CALL    INCHR
43760           CPI     3               ;STOP CHARACTER IS ^C
43780   IFE     LENGTH,<
43800           JMP     STOP>>
43820   IFN     LENGTH,<
43840   STOP:   RNZ                     ;RETURN IF NOT CONTROL-C AND MAKE
43860                                   ;SURE "STOP" STATEMENTS HAVE A TERMINATOR
43880           XWD     ^O1000,^O366    ;SETUP [A] AS A FLAG WHETHER
43900                                   ;TO TYPE THE BREAK MESSAGE
43920   END:    RNZ                     ;MAKE SURE "END" STATEMENTS HAVE A TERMINATOR
43940           SHLD    TEMP            ;SAVE FOR "CONTINUE"
43960   STPEND: POP     B               ;POP OFF NEWSTT ADDRESS
43980   ENDCON: PUSH    PSW             ;SAVE THE MESSAGE FLAG
44000                                   ;ZERO MEANS DON'T PRINT "BREAK"
44020           LHLD    CURLIN          ;SAVE CURLIN
44040           MOV     A,L
44060           ANA     H               ;SEE IF IT WAS DIRECT
44080           INR     A
44100           JZ      DIRIS           ;IF NOT SET UP FOR CONTINUE
44120           SHLD    DLDLIN          ;SAVE OLD LINE #
44140           LHLD    TEMP            ;GET POINTER TO START OF STATEMENT
44160           OLDTXT                  ;SAVE IT
44180   DIRIS:
44200   IFN     CONTRW,<
44220           XRA     A
44240           STA     CNTWFL>         ;FORCE OUTPUT
44280           POP     PSW             ;GET BACK ^C FLAG
44300           LXI     H,BRKTXT        ;"BREAK"
44320           JNZ     ERRFIN          ;CALL STROUT AND FALL INTO READY
44340           JMP     READY>          ;TYPE "READY"
44360   IFE     REALIO,<
44380   DDT:    POP     B
44400           HRRZ    14,JOBOOT##
44420           JRST    0(14)>
44460   IFN     LENFTH,<
44480   CONT:   RNZ                     ;MAKE SURE THERE IS A TERMINATOR
44500           MVI     E,ERRCN
44520           LHLD    OLDTXT          ;A STORED TEXT POINTER OF
44540                                   ;ZERO IS SETUP BY STKINI
44560                                   ;AND INDICATES THERE IS NOTHING
44580                                   ;TO CONTINUE
44600           MOV     A,H             ;"STOP","END",TYPING CRLF
44620           ORA     L               ;TO "INPUT" AND ^C SETUP OLDTXT
44640           JNZ     ERROR
44660           XCHG                    ;SAVE [H,L]
44680           LHLD    OLDLIN
44700           SHLD    CURLIN          ;SET UP OLD LINE # AS CURRENT LINE #
44720           XCHG                    ;RESTORE [H,L]
44740           RET>
44760   IFN     LENGTH,<
44780   NULL:   CALL    GETBYT
44800           RNZ                     ;MAKE SURE THERE IS A TERMINATOR
44820           INR     A
44840           CPI     LINLEN          ;MAKE SURE THE NUMBER IS REASONABLE
44860                                   ;CRDO WON'T WORK IF IT ISN'T
44880   LINPT2==:.-1                    ;TERMINAL WIDTH CHANGE LOCATION
44900           JNC     FCERR           ;"FUNCTION CALL" ERROR
44920           STA     NULCNT          ;CHANGE NUMBER OF NULLS
44940           RET>
45960   IFE     LENGTH-2,<
45980   TON:    XWD     ^O1000,^O76     ;"MVI A," NON-ZERO QUANTITY
45500   TOFF:   XRA     A               ;MAKE [A]=0 FOR NO TRACE
45020           STA     TRCFLG          ;UPDATE THE TRACE FLAG
45040           RET>
45060   ;
45080   ;TEST FOR A LETTER / CARRY ON=NOT A LETTER
45100   ;                    CARRY OFF=A LETTER
45120   ;
45140   ISLET:  MOV     A,M
45160           CPI     "A"
45180           RC                      ;IF LESS THAN "A", RETURN EARLY
45200           CPI     91              ;91="Z"+1
45220           CMC
45240           RET
45260   ;
45280   ; INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
45300   ; TURNS IT INTO A POSITIVE INTEGER
45320   ; LEAVING THE RESULT IN [D,E].  NEGATIVE ARGUMENTS
45340   ; ARE NOT ALLOWED. [H,L] POINTS TO THE TERMINATING
45360   ; CHARACTER OF THE FORMULA ON RETURN.
45380   ;
45400   IFN     LENGTH-2,<
45420   INTIDX: CHRGET
45440   INTID2: CALL    FRMNUM
45460   POSINT: FSIGN
45480           JM      FCERR           ;IF NEGATIVE BLOW HIM OUT
45500   DEINT:  LDA     FAC             ;SEE IF ARG GREATER THAN 32767
45520           CPI     144
45540           JC      QINT
45560   IFN     LENGTH,<
45580           MOVRI   144,128,0,0     ;REGISTERS = FLOATING -32768
45600           CALL    FCOMP           ;SEE IF FAC=REGISTERS
45620           MOV     D,C             ;SETUP D=200 E=0 FOR -32768
45640           RZ>                     ;WAS -32768. [D,E] IS SET UP
45660   ILLFUN:
45680   FCERR:  MVI     E,ERRFC         ;TOO BIG. FUNCTION CALL ERROR
45700           JMP     ERROR>
45720   IFE     LENGTH-2,<
45740   INTIDX: CHRGET
45760   INTID2: CALL    FRMEVL          ;EVALULATE A FORMULA
45780           PUSH    H               ;SAVE THE TEXT POINTER
45800           CALL    FRCINT          ;CONVERT THE FAC TO AN INTEGER
45820           MOV     A,H             ;SEE IF THE RESULT IS NEGATIVE
45840           ORA     A               ;BY LOOKING AT [H]'S MSB
45860           JM      FCERR           ;DON'T ALLOW NEGATIVE NUMBERS
45880           XCHG                    ;RETURN THE INTEGER IN [D,E]
45900           POP     H               ;RESTORE THE TEXT POINTER
45920           RET>
45960   ;
45980   ; LINGET READS A LINE # FROM THE CURRENT TEXT POSITION
46000   ;
46020   ; LINE NUMBERS RANGE FROM 0 TO 65529
46040   ;
46060   ; [D,E] IS SMASHED.
46080   ;
46100   ; ANSWER RETURNED IN [D,E].
46120   ; [H,L] IS UPDATED TO POINT TO THE TERMINATING CHARACTER
46140   ; AND [A] CONTAINS THE TERMINATING CHARCATER WITH CONDITION
46160   ; CODES SET UP TO REFLECT ITS VALUE.
46180   ;
46200   LINGET: DCX     H
46220   LINGT2: LXI     D,$CODE         ;ZERO ACCUMULATED LINE #
46240   MORLIN: CHRGET
46260           RNC                     ;WAS IT A DIGIT
46280           PUSH    H
46300           PUSH    PSW
46320           LXI     H,$CODE+6552    ;SEE IF THE LINE # IS TOO BIG
46340           COMPAR
46360           JC      SNERR           ;YES, SYNTAX ERROR
46380           MOV     H,D             ;SAVE [D,E]
46400           MOV     L,E
46420           DAD     D
46440           DAD     H
46460           DAD     D
46480           DAD     H               ;PUTTING [D,E]*10 INTO [H,L]
46500           POP     PSW
46520           SUI     "O"
46540           MOV     E,A
46560           MVI     D,0
46580           DAD     D               ;ADD THE NEW DIGIT
46600           XCHG
46620           POP     H               ;GET BACK TEXT POINTER
46640           JMP     MORLIN
46660   IFN     LENGTH,<
46680   CLEAR:  JZ      CLEARC          ;IF NO FORMULA JUST CLEAR
46700           CALL    INTID2          ;GET AN INTEGER INTO [D,E]
46720           DCX     H
46740           CHRGET                  ;SEE IF ITS THE END
46760           RNZ                     ;SHOULD FINISH THERE
46780           PUSH    H               ;SAVE TXTPTR
47800           LHLD    MEMSIZ          ;GET HIGHEST ADDRESS
47820           MOV     A,L             ;SUBTRACT [H,L]-[D,E] INTO [D,E]
47840           SUB     E
47860           MOV     E,A
47880           MOV     A,H
47900           SBB     D
47920           MOV     D,A
47940           JC      SNERR           ;WANTED MORE THAN TOTAL!
47960           LHLD    VARTAB          ;TOP LOCATION IN USE
47980           LXI     B,$CODE+40      ;LEAVE BREATHING ROOM
47000           DAD     B
47020           COMPAR                  ;ROOM?
47040           JNC     OMERR           ;NO, DON'T EVEN CLEAR
47060           XCHG                    ;NEW STACK LOCATION [H,L]
47080           SHLD    STKTOP          ;SET UP NEW STACK LOCATION
47100           POP     H               ;REGAIN THE TEXT POINTER
47120           JMP     CLEARC>         ;GO CLEAR
47140   PAGE
47160   SUBTTL  RUN,GOTO,GOSUB,RETURN
47180   IFN     LENGTH,<
47200   RUN:    JZ      RUNC            ;NO LINE # ARGUMENT
47220                                   ;CLEAN UP,SET [H,L]=[TXTTAB]-1 AND
47240                                   ;RETURN TO NEWSTT
47260           CALL    CLEARC          ;CLEAN UP -- RESET THE STACK
47280                                   ;DATAPTR,VARIABLES ...
47300                                   ;[H,L] IS THE ONLY THING PRESERVED
47320           LXI     B,NEWSTT
47340           JMP     RUNC2>          ;PUT "NEWSTT" ON AND FALL INTO "GOTO"
47360   ;
47380   ; A GOSUB ENTRY ON THE STACK HAS THE FOLLOWING FORMAT
47400   ;
47420   ; LOW ADDRESS
47440   ;
47460   ;       A TOKEN EQUAL TO GOSUTK 1 BYTE
47480   ;       THE LONE # OF THE THE GOSUB STATEMENT 2 BYTES
47500   ;       A POINTER INTO THE TEXT OF THE GOSUB 2 BYTES
47520   ;
47540   ; HIGH ADDRESS
47560   ;
47580   ; TOTAL 5 BYTES
47600   ;
47620   GOSUB:  CALL    GETSTK          ;MAKE SURE THERE IS ROOM
47640           3
47660           POP     B               ;POP OFF RETURN ADDRESS "NEWSTT"
47680           PUSH    H               ;REALLY PUSH THE TEXT POINTER
47700           PUSH    H               ;SAVE TEXT POINTER
47720           LHLD    CURLIN          ;GET THE CURRENT LINE #
47740           XTHL                    ;PUT CUTLIN ON THE STACK AND [H,L]=TEXT PTR
48760           MVI     D,GOSUTK        ;LEAVE A GOSUB TOKEN
47780                                   ;ON THE STACK
47800           PUSH    D
47820           INX     SP              ;THE GOSUB TOKEN TAKES ONLY ONE BYTE
47840   RUNC2:  PUSH    B               ;RESTORE RETURN ADDRESS
48860                                   ;OF "NEWSTT"
48880   ;
48900   ; IN THE 4K VERSION WE START AT THE BEGINNING
48920   ; AND SEARCH. IN THE 8K WE START WHERE WE
48940   ; ARE IF WE ARE  GOING TO A FORWARD LOCATION.
47960   ;
47980   GOTO:   CALL    LINGET          ;PICK UP THE LINE #
48000                                   ;AND PUT IT IN [D,E]
48020   IFE     LENGTH,<RNZ             ;SHOULD END WITH A LINE
48040                                   ;TERMINATOR -- BLOW HIM UP
48060                                   ;IF IT DOESN'T
48080                                   ;(ON GOTO MAKES THIS WRONG
48100                                   ;IN OTHER VERSONS)
48120           CALL    FNDLIN>
48140   IFN     LENGTH,<
48160           CALL    REM             ;SKIP TO THE END OF THIS LINE
48180           PUSH    H               ;SAVE THE POINTER
48200           LHLD    CURLIN          ;GET THE CURRENT LINE #
48220           COMPAR                  ;[D,E] CONTAINS WHERE WE ARE GOING
48240                                   ;[H,L] CONTAINS THE CURRENT LINE#
48260                                   ;SO COMPARING THEM TELL US WHETHER TO
48280                                   ;START SEARCHING FROM WHERE WE ARE OR
48300                                   ;TO START SEARCHING FROM THE BEGINNING
48320                                   ;OF TXTTAB
48340           POP     H               ;[H,L]=CURRENT POINTER
48360           INX     H               ;POINT AT THE LINK BEYOND IT
48380           CC      LOOP            ;SEARCH FROM THIS POINT
48400           CNC     FNDLIN>         ;SEARCH FROM THE BEGINNING -- ACTUALLY
48420                                   ;SEARCH AGAIN IF ABOVE SEARCH FAILED
48440           MOV     H,B
48460           MOV     L,C
48480           DCX     H
48500           RC                      ;IF A MATCH WE ARE DONE
48520   USERR:  MVI     E,ERRUS
48540           JMP     ERROR           ;C=MATCH,SO IF NO MATCH WE
48560                                   ;GIVE A "US" ERROR
48580   ;
48600   ; SEE "GOSUB" FOR THE FORMAT OF THE STACK ENTRY
48620   ; "RETURN" RESTORES THE LINE NUMBER AND TEXT POINTER ON THE STACK
48640   ; AFTER ELIMINATING ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB"
48660   ; ENTRY
48680   ;
48700   RETURN: RNZ                     ;BLOW HIM UP IF THERE ISN'T A TERMINATOR
48720           MVI     D,255           ;MAKE SURE THIS VARIABLE POINTER
48740
48740                                   ;IF [D,E] NEVER GETS MATCHED
48760           CALL    FNDFOR          ;GO PAST ALL THE "FOR" ENTRIES
48780           SPHL                    ;UPDATE THE STACK
48800           CPI     GOSUTK
48820           MVI     E,ERRRG         ;ERROR ERRRG IS "RETURN WITHOUT GOSUB"
48840           JNZ     ERROR
48860           POP     H               ;GET LINE # "GOSUB" WAS FROM
48880           SHLD    CURLIN          ;PUT IT INTO CURLIN
48900           LXI     H,NEWSTT
48920           XTHL                    ;PUT RETURN ADDRESS OF "NEWSTT"
48940                                   ;BACK ONTO THE STACK. GET TEXT POINTER
48960                                   ;FROM "GOSUB"
48980                                   ;SKIP OVER SOME CHARACTERS
49000                                   ;SINCE WHEN "GOSUB" STUCK THE TEXT POINTER
49020                                   ;ONTO THE STACK THE LINE # ARGUMENT HADN'T
49040                                   ;BEEN READ IN YET.
49100   IFN     STRING,<
49120   DATA:   XWD     ^O1000,^O1      ;"LXI B," TO PICK UP ":" INTO C AND SKIP
49140           ":"                     ;"DATA" TERMINATES ON ":"
49160                                   ;AND 0. ":" ONLY APPLIES IF
49180                                   ;QUOTES HAVE MATCHED UP
49200   IFE     LENGTH-2,<ELSE:>        ;EXECUTED "ELSE"S ARE SKIPPED
49220   ;
49240   ; NOTE: REM MUST PRESERVE [D,E] BECAUSE OF "GO TO" AND ERROR
49260   ;
49280   REM:    XWD     ^O1000,^O16     ;MVI C,   THE ONLY TERMINATOR IS 0
49300           XWD     ^O1000,0        ;NO-OPERATION
49320                                   ;"DATA" ACTUALLY EXECUTES THIS 0
49340           MVI     B,0             ;INSIDE QUOTES THE ONLY TERMINATOR IS ZERO
49360   EXCHQT: MOV     A,C             ;WHEN A QUOTE IS SEEN THE SECOND
49380           MOV     C,B             ;TERMINATOR IS TRADED, SO IN "DATA"
49400           MOV     B,A             ;COLONS INSIDE QUOTATIONS WILL HAVE NO EFFECT
49420   REMER:  MOV     A,M             ;GET THE CHARACTER
49440           ORA     A               ;ZERO IS ALWAYS A TERMINATOR
49460           RZ
49480           CMP     B               ;TEST FOR THE OTHER TERMINATOR
49500           RZ
49520           INZ     H
49540           CPI     34              ;IS IT A QUOTE?
49560           JZ      EXCHQT          ;IF SO TIME TO TRADE
49580   IFE     LENGTH-2,<
49600   ;
49620   ; WHEN AN "IF" TAKES A FALSE BRANCH IT MUST FIND THE APPROPRIATE "ELSE"
49640   ; TO START EXECUTION AT. "DATA" COUNTS THE NUMBER OF "IF"S
49660   ; IT SEES SO THAT THE "ELSE" CODE CAN MATCH "ELSE"S WITH
49680   ; "IF"S. THE COUNT IS KEPT IN [D]
49700   ;
49720           SUI     IFTK            ;IS IT AN "IF"
49740           JNZ     REMER           ;IF NOT, CONTINUE ON
49760           CMP     B               ;SINCE "REM" CAN'T SMASH
49780                                   ;[D,E] WE HAVE TO BE CAREFUL
49800                                   ;SO ONLY IF B DOESN'T EQUAL
49820                                   ;ZERO WE CAN INCREMENT D. (THE "IF" COUNT)
49840           ADC     D               ;CARRY ON IF [B] NOT ZERO
49860           MOV     D,A>            ;UPDATE [D]
49880           JMP     REMER>
49900   ;
49902   ; WITHOUT STRINGS THERE IS NO NEED TO WATCH QUOTATIONS
49904   ; SO [B] IS SET UP AS THE SECONDARY TERMINATOR
49906   ; AND A SCAN IS MADE FOR [B] OR ZERO
49908   ;
49920   IFE     STRING,<
49940   DATA:   XWD     ^O01000,1       ;MAKE [C]=":" AND SKIP
49960           ":"
49980   REM:    XWD     ^O1000,16       ;MAKE [C]=0
50000           XWD     ^O1000,0        ;ZERO AND NO-OPERATION
50020   LOOPDR: MOV     A,M
50040           ORA     A               ;ALWAYS STOP ON ZERO
50060           RZ
50080           CMP     C               ;CHECK FOR ":" IN DATA
50100           RZ
50120           INX     H               ;LOOK AT NEXT CHARACTER
50140           JMP     LOOPDR>
50160   PAGE
50180   SUBTTL "LET"
50200   LET:    CALL    PTRGET          ;GET THE POINTER TO THE VARIABLE
50220                                   ;NAMED IN TEXT AND PUT
50240                                   ;IT ON THE STACK. [H,L] REMAINS
50260                                   ;THE TEXT POINTER AND A,PSW ARE SETUP
50280                                   ;AS THE TERMINATING CHARACTER.
50300           SYNCHK  EQULTK          ;CHECK FOR "="
50320   REDINP:
50340   IFN     STRING,<
50360           LDA     VALTYP
50380           PUSH    PSW>
50400           PUSH    D
50420           CALL    FRMEVL          ;GET THE VALUE OF THE FORMULA
50440                                   ;INTO FAC
50460           XTHL                    ;[H,L]=POINTER TO VARIABLE
50480                                   ;TEXT POINTER TO ON TOP OF STACK
50500           SHLD    TEMP            ;SAVE VARIABLE POINTER ON "FOR"
50520   IFN     STRING,<
50540           POP     D               ;GET TEXT POINTER OFF
50560           POP     PSW             ;GET THE VALTYP OF THE
50580                                   ;VARIABLE INTO [A]
50581           PUSH    D               ;RESAVE THE TEXT-POINTER
50582   IFE     LENGTH-2,<
50584           CPI     3               ;SEE IF ITS A STRING
50586   INPCOM: PUSH    H               ;SAVE THE POINTER AT THE VALUE POSITION
50588           JNZ     COPNUM          ;NUMERIC, SO FORCE IT AND COPY
50590           CALL    CHKSTR>         ;MAKE SURE THE FORMULA WAS A STRING
50600   IFN     LENGTH-2,<
50620           RAR                     ;CARRY SET FOR STRING OFF
50640                                   ;FOR NUMERIC
50660           CALL    CHKVAL          ;MAKE SURE VALTYP MATCHES CARRY
50680                                   ;AND SET THE ZERO FLAG
50700                                   ;ON A NUMERIC VALTYP
50860           JZ      COPNUM          ;IF A NUMBER COPY
50880   INPCOM: PUSH    H>              ;SAVE POINTER AT VARIABLE
50900           LHLD    FACLO           ;GET POINTER TO THE DESCRIPTOR OF THE RESULT
50920           PUSH    H               ;SAVE THE POINTER AT THE DESCRIPTOR
50940           INX     H
50960           INX     H
50980           PUSHM
51000           POP     D
51020           LHLD    STKTOP          ;SEE IF IT POINTS INTO STRING SPACE
51040           COMPAR                  ;IF NOT DON'T COPY
51060           POP     D               ;GET BACK THE POINTER AT THE DESCRIPTOR
51080           JNC     DNTCPY          ;DON'T COPY LITERALS
51100           LHLD    VARTAB          ;NOW, SEE IF ITS A VARIABLE
51120           COMPAR                  ;BY SEEING IF THE  DESCRIPTOR
51140           MOV     L,E
51160           MOV     H,D
51180           CC      STRCPY          ;IS BEYOND [VARTAB], IF SO COPY
51200   DNTCPY: LDAX    D               ;GET THE LENGTH AND SAVE IT
51220           PUSH    PSW             ;SINCE WE ARE GOING TO SET IT TO
51240                                   ;0 SO FRETMP DOESN'T UPDATE FRETOP
51260           XRA     A               ;SET IT TO 0 -- ELIMINATING NNULL
51280                                   ;STRING IN FRETMP IS HARMLESS
51300           STAX    D               ;PUT 0 IN THE LENGTH FIELD
51320           CALL    FRETMP          ;FREE IT UP
51340           POP     PSW             ;GET LENGTH BACK
51360           MOV     M,A             ;REPLACE IT [ FRETMP RETURNS [D,E] IN [H,L] ]
51380           XCHG                    ;PUT THE DESCRIPTOR POINTER BACK IN [D,E]
51400           POP     H               ;GET THE PLACE OF THE NEW VARIABLE
51420   IFN     LENGTH-2,<
51440           CALL    MOVE>           ;COPY THE DESCRIPTOR
51460   IFE     LENGTH-2,<
51480           CALL    VMOVE>
51500           POP     H               ;GET THE TEXT POINTER BACK
51520           RET>
51540   COPNUM:
51560   IFE     LENGTH-2,<
51580           ANI     6               ;SETUP DISPATCH TO FORCE
51600                                   ;FORMULA TYPE TO CONFORM
51620                                   ;TO THE VARIABLE ITS BEING ASSIGNED TO
51640           LXI     H,FRCTBL        ;TABLE OF FORCE ROUTINES
51660           MOV     C,A             ;[B,C]=TWO BYTE OFFSET
51680           MVI     B,0
51700           DAD     B
51720           MOV     A,M             ;[H,L]=ADDRESS TO GO TO
51740           INX     H
51760           MOV     H,M
51780           MOV     L,A
51800           LXI     B,PUTVAL        ;RETURN TO PUTVAL
51820           PUSH    B
51840           PCHL                    ;DISPATCH TO FORCE
51860   PUTVAL: POP     H               ;GET THE POINTER OF WHERE TO STORE
51880                                   ;THE VALUE
51900           PUSH    H               ;SAVE IT BACK
51920           CALL    VMOVMF>         ;MOVE THE VALUE IN
51940   IFN     LENGTH-2,<
51960           PUSH    H               ;SAVE THE VARIABLE POINTER FOR "FOR"
51980           CALL    MOVMF>          ;TRANSFER THE VALUE
52000           POP     D               ;"FOR" WANTS VARIABLE POINTER IN
52020                                   ;[D,E] FOR FNDFOR
52040           POP     H               ;GET THE TEXT POINTER
52060           RET
52080   PAGE
52100   SUBTTL ON GOTO CODE
52120   IFN     LENGTH,<
52160   ONGOTO: CALL    GETBYT          ;GET VALUE INTO [E]
52180           MOV     A,M             ;GET THE TERMINATOR BACK
52200           MOV     B,A             ;SAVE THIS CHARACTER FOR LATER
52220           CPI     GOSUTK          ;AN "ON ... GOSUB" PERHAPS?
52240           JZ      ISGOSU          ;YES, SOME FEATURE USE
52260           SYNCHK  GOTOTK          ;OTHERWISE MUST BE "GOTO"
52280           DCX     H               ;BACK UP CHARACTER POINTER
52300   ISGOSU: MOV     C,E             ;GET COUNT INTO  [C]
52320   LOOPON: DCR     C               ;SEE IF ENOUGH SKIPS
52340           MOV     A,B             ;PUT DISPATCH CHARACTER IN PLACE
52360           JZ      GONE2           ;IF DONE, GO OFF
52380           CALL    LINGT2          ;SKIP OVER A LINE #
52400           CPI     44              ;A COMMA
52420           RNZ                     ;IF A COMMA DOESN'T DELIMIT THE END OF
52440                                   ;THE LAST LINE # MUST BE THE END OF THE LINE
52460           JMP     LOOPON>         ;CONTINUE GOBBLING LINE #S
52500   PAGE
52520   SUBTTL IF ... THEN CODE
52540   IF:     CALL    FRMEVL          ;EVALUATE A FORMULA
52560   IFE     LENGTH,<
52580   IFN     STRING,<
52600           LDA     VALTYP          ;GET VALUE TYPE INTO [A]
52620           PUSH    PSW>>           ;SAVE THE VALUE TYPE ON THE STACK
52640           MOV     A,M             ;GET TERMINATING CHARACTER OF FORMULA
52660   IFE     LENGTH,<
52680           CALL    PUSHF           ;ONTO THE STACK
52700           MVI     D,0             ;KEEPS RELATIONAL OPERATOR MEMORIES
52720                                   ;LESS THAN #4
52740                                   ;EQUAL     #2
52760                                   ;GREATER THAN #1
52780   LOOPIF: SUI     GREATK          ;CHECK FOR A RELATIONAL OPERATOR
52800           JC      ENDREL          ;NOPE
52820   NUMREL=LESSTK-GREATK+1          ;NUMBER OF RELATIONAL OPERATORS
52840           CPI     NUMREL          ;IS THIS ONE OF THEM?
52860           JNC     ENDREL          ;NO SEE WHAT WE HAVE
52880           CPI     1               ;SETUP BITS BY MAPPING
52900           RAL                     ;0 TO 1, 1 TO 2, AND 2 TO 4
52920           ORA     D               ;OR WITH EARLIER BITS
52940           MOV     D,A             ;STORE NEW BITS
52960           CHRGET                  ;GET NEW CHARACTER
52980           JMP     LOOPIF          ;SEE IF RELATIONAL
53000   ENDREL: MOV     A,D             ;GET RELATIONAL MEMORIES
53020           ORA     A               ;SEE IF THERE ARE ANY
53040           JZ      SNERR           ;NO RELATIONAL OPERATORS!
53060           PUSH    PSW             ;SAVE RELATIONAL MEMORIES
53080           CALL    FRMEVL>         ;PICK UP FIRST NON-RELATIONAL
53100                                   ;CHARACTER AGAIN AND INTERPRET FORMULA
53110                                   ;ANSWER LEFT IN FAC
53140   IFE     LENGTH-2,<CPI   44      ;A COMMA?
53160           CZ      CHRGTR>         ;IF SO SKIP IT
53180   IFN     LENGTH,<
53200           CPI     GOTOTK          ;ALLOW "GOTO" AS WELL
53220           JZ      OKGOTO>
53240           SYNCHK  THENTK          ;MUST HAVE A THEN
53260           DCX     H
53280   OKGOTO:
53300   IFE:    LENGTH,<
53320           POP     PSW
53340           POPR                    ;POP OFF NUMBER
53360   IFN     STRING,<
53380           XTHL>                   ;COMPARE FORMULA TYPES
53400   IFE     STRING,<PUSH    H>      ;SAVE THE TEXT POINTER
53420           PUSH    PSW             ;RESAVE RELATIONAL MEMORIES
53440   IFN     STRING,<
53460           LDA     VALTYP          ;GET VALUE TPYE
53480           CMP     H               ;[H] HAS OLD VALTYP ARE THEY =?
53500           JNZ     TMERR           ;IF NOT ITS A TYPE ERROR
53520           ORA     A               ;SEE WHAT TYPE IT WAS
53540           JZ      NUMCMP          ;ZERO MEANS IT WAS NUMERIC
53560           CALL    STRCMP          ;MUST BE A STRING SO STRING COMPARE
53580           JMP     SKPNCM>         ;SKIP OVER NUMERIC COMPARE
53600   NUMCMP: CALL    FCOMP           ;COMPARE THE 2 SIDE OF THE RELATION STATMENT
53620   SKPNCM: INT     A               ;BUILD RELATIONAL BITS
53640           RAL                     ;LESS=4 EQUAL=2 GREATER=1
53660                                   ;SINCE CARRY IS ON ONLY IN
53680                                   ;377  CASE (FCOMP & STRCMP)
53700           POP     B               ;POP OFF WHAT RELATIONAL OPERATOR HAS
53720           ANA     B>              ;SEE IF WE MATCHED
53740   IFN     LENGTH,<
53742   IFE     LENGTH-2,<
53744           CALL    VSIGN##>
53746   IFN     LENGTH-2,<
53760           FSIGN>>                 ;0=FALSE ALL OTHERS=TRUE
53780   IFE     LENGTH,<
53800           POP     H>              ;POP OFF TEXT POINTER
53820   IFE     LENGTH-2,<
53840           JZ      FALSIF>         ;HANDLE POSSIBLE "ELSE"
53860   IFN     LENGTH-2,<
53880           JZ      REM>            ;IF TEST FAILED -- JUST SKIP REST OF THE LINE
53900   DOCOND: CHRGET                  ;PICK UP THE FIRST LINE # CHARACTER
53920           JC      GOTO            ;LINE NUMBER MEANS "GOTO"
53940           JMP     GONE3           ;INTERPRET NEW STATEMENT
53960   IFE     LENGTH-2,<
53980   ;
54000   ; "ELSE" HANDLER. HERE ON FALSE "IF" CONDITION
54020   ;
54040   FALSIF: MVI     D,1             ;NUMBER OF "ELSE"S THAT MUST
54060                                   ;BE SEEN. "DATA" INCREMENTS THIS
54080                                   ;COUNT EVERY TIME AN "IF" IS SEEN
54100   SKPMRF: CALL    DATA            ;SKIP A STATEMENT
54120                                   ;":" IS STUCK IN FRONT OF "ELSE"S
54140                                   ;SO THAT "DATA" WILL STOP BEFORE "ELSE" CLAUSES
54160           ORA     A               ;END OF LINE?
54180           RZ                      ;IF SO, NO "ELSE" CLAUSE
54200           CHRGET                  ;SEE IF WE HIT AN "ELSE"
54220           CPI     ELSETK
54240           JNZ     SKPMRF          ;NO, STILL IN THE "THEN" CLAUSE
54260           DCR     D               ;DECREMENT THE NUMBER OF "ELSE"S THAT
54280                                   ;MUST BE SEEN
54300           JNZ     SKPMRF          ;SKIP MORE IF HAVEN'T SEEN
54320                                   ;ENOUGH
54340           JMP     DOCONO>         ;FOUND THE RIGHT "ELSE" -- GO EXECUTE
54380   PAGE
54400   SUBTTL PRINT CODE
54440   IFN     LPTSW,<
54460   LPRINT: MVI     A,1             ;SAY NON ZERO
54480           STA     PRTFLG>         ;SAVE AWAY
54500   NEWCHR: DCX     H
54520   MORPR:  CHRGET                  ;GET ANOTHER CHARACTER
54540   PRINT:  JZ      CRDO            ;IF WE SEE A TERMINATOR
54560                                   ;GO TYPE A CRLF
54580   PRINTC: RZ                      ;HERE AFTER SEEING TAB(X) OR , OR ;
54600                                   ;IN WHICH CASE A TERMINATOR DOES NOT
54620                                   ;MEAN WE SHOULD TYPE A CRLF
54640                                   ;BUT JUST RETURN
54660   IFE     STRING,<
54680           CPI     34              ;A TERMINATING QUOTE?
54700           CZ      STROUI
54720           JZ      NEWCHR>         ;A QUOTATION -- JUST PRINT IT
54740           CPI     TABTK
54760           JZ      TABER           ;THE TAB FUNCTION?
54780   IFN     LENGTH,<
54800           CPI     SPCTK
54820           JZ      TABER>          ;THE SPC FUNCTION?
54840           PUSH    H               ;SAVE THE TEXT POINTER
54860           CPI     44
54880           JZ      COMPRT          ;IS IT A COMMA?
54900           CPI     59              ;IS IT A ";"
54920           JZ      NOTABR
54940           POP     B               ;GET RID OF OLD TEXT POINTER
54960           CALL    FRMEVL          ;BACK UP ONE CHARACTER AND READ THAT ONE
55980                                   ;AGAIN SO THE CONDITION CODES ARE RIGHT
55000                                   ;EVALUATE THE FORMULA
55020           DCX     H               ;BACKUP FROM TERMINATOR
55040           PUSH    H               ;SAVE TEXT POINTER
55060   IFN     STRING,<
55062   IFE     LENGTH-2,<
55064           CALL    GETYPE          ;SEE IF WE HAVE A STRING
55066           JZ      STRDON>         ;IF SO, PRINT SPECIALY
55068   IFN     LENGTH-2,<
55080           LDA     VALTYP
55100           ORA     A
55120           JNZ     STRDON>>        ;WAS IT A STRING FORMULA?
55140           CALL    FOUT            ;MAKE A NUMBER INTO A STRING
55160   IFE     STRING,<CALL    STROUT> ;IF STRINGS OFF JUST OUTPUT IT
55180   IFN     STRING,<
55200           CALL    STRLIT          ;MAKE IT  A STRING
55220           LHLD    FACLO           ;GET THE POINTER
55240   IFN     LPTSW,<
55260           LDA     PRTFLG
55280           ORA     A
55300           JZ      ISTTY           ;LPT OR TTY?
55320           LDA     LPTPOS
55340           ADD     M
55360           CPI     LPTLEN          ;WILL THIS NUMBER OVERLAP?
55380           JMP     LINCHK
55400   ISTTY:>
55420           LDA     TTYPOS          ;SEE WHERE WE ARE
55440           ADD     M               ;ADD THIS LENGTH
55460           CPI     LINLEN          ;SEE IF GREATER THAN THE LINE LENGTH
55480   LINPT3==:.-1
55500   LINCHK: CNC     CRDO            ;IF SO CRLF
55520           CALL    STRPRT>         ;PRINT THE NUMBER
55540           MVI     A," "           ;ALWAYS END WITH A SPACE
55560           OUTCHR
55580   IFN     STRING,<
55590   IFE     LENGTH-2,<
55595           ORA     A               ;TURN OFF THE ZERO FLAG
55597   STRDON: CZ      STRPRT>
55598   IFN     LENGTH-2,<
55599           XRA     A
55600   STRDON: CNZ     STRPRT>>        ;JUST PRINT STRINGS
55620           POP     H
55640           JMP     MORPR           ;PRINT SOME MORE
55660   FININL: MVI     M,0             ;PUT A ZERO AT THE END OF BUF
55680           LXI     H,BUFMIN        ;SETUP POINTER
55700   CRDO:   IFN      LPTSW, <
55720           LDA     PRTFLG
55740           ORA     A
55760           JNZ     PRINTW>
55780           MVI     A,13
55800           STA     TTYPOS          ;MAKE TTYPOS LESS THAN LINE LENGTH
55820                                   ;SO CRDO DOESN'T GET CALLED AGAIN
55840           OUTCHR
55860           MVI     A,10
55880           OUTCHR
55900   CRFIN:  LDA     NULCNT          ;GET NUMBER OF NULLS
55920   PRTNUL: DCR     A
55940           STA     TTYPOS          ;EVENTUALLY SETUP TTYPOS=0
55960           RZ                      ;ALL NULLS DONE [A]=0
55980                                   ;SOME ROUTINES DEPEND ON CRDO
56000                                   ;AND CRFINS RETURN [A]=0 AND Z  TRUE
56020           PUSH    PSW             ;SAVE THE COUNT
56040           XRA     A               ;[A]= A NULL
56060           OUTCHR                  ;SEND IT OUT
56080           POP     PSW             ;RESTORE THE COUNT
56100           JMP     PRTNUL          ;LOOP PRINTING NULLS
56120   IFE     STRING,<
56140   STROUI: INX     H
56160   STROUT: MOV     A,M
56180           ORA     A               ;CHECK FOR END OF LINE
56200           RZ                      ;LET IT END THAT WAY
56220           INX     H
56240           CPI     34              ;A TERMINATING QUOTE?
56260           RZ                      ;DONE IF SO
56280           OUTCHR                  ;PRINT THE CHARACTER IN [A]
56300           CPI     CR              ;IF IT'S A CARRIAGE RETURN
56320           CZ      CRDO            ;TYPE LINE-FEED AND SET [TTYPOS]=0
56340           JMP     STROUT>         ;PRINT MORE CHARACTERS
56380   COMPRT: IFN     LPTSW,<
56400           LDA     PRTFLG          ;OUTPUT TO THE LINE PRINTER?
56420           ORA     A               ;NON-ZERO MEANS YES
56440           JZ      ISCTTY          ;NO, DO TELETYPE COMMA
56460           LDA     LPTPOS          ;GET LINE PRINTER POSITION
56480   NLPPOS==<<<LPTLEN/CLMWID>-1>*CLMWID>;POSITION BEYOND WHICH THERE ARE
56500                                   ;NO MORE COMMA FIELDS, SO
56520           CPI     NLPPOS          ;COMMA JUST DOES A "CRDO"
56540           JMP     CHKCOM          ;USE TELETYPE CHECK
56560   ISCTTY:>
56580           LDA     TTYPOS          ;GET TELETYPE POSITION
56600   NUTPOS==<<<LINLEN/CLMWID>-1>*CLMWID>;POSITION BEYOND WHICH THERE ARE
56620                                   ;NO MORE COMMA FIELDS
56640           CPI     NUTPOS          ;SO ALL COMMA DOES IS A "CRDO"
56660   LINPT4==:.-1                    ;FIXED UP BY "TERMINAL WIDTH" QUESTION
56680   CHKCOM: CNC     CRDO            ;TYPE CRLF
56700           JNC     NOTABR          ;AND QUIT IF BEYOND THE LAST COMMA FIELD
56720   MORCOM: SUI     CLMWID          ;GET [A] MODULUS CLMWID
56740           JNC     MORCOM
56760           CMA                     ;WE WANT TO  FILL
56780                                   ;THE PRINT POSITION OUT
56800                                   ;TO AN EVEN CLMWID, SO
56820                                   ;WE PRINT CLMWID=[A] MOD CLMWID SPACES
56840           JMP     ASPA2           ;GO PRINT [A]+1 SPACES
56880   TABER:
56900   IFN     LENGTH,<PUSH    PSW>    ;REMEMBER IF [A]=SPCTK OR TABTK
56920   IFE     LENGTH,<
56940           CALL    INTIDX>         ;INTEGERIZE A FORMULA INTO [D,E]
56960   IFN     LENGTH,<
56980           CALL    GTBYTC>         ;GET VALUE INTO [E]
57000           SYNCHK  ")"
57020           DCX     H
57040   IFN     LENGTH,<
57060           POP     PSW             ;GET BACK SPCTK OR TABTK
57080           CPI     SPCTK>          ;WAS IT SPCTK?
57100           PUSH    H               ;SAVE THE TEXT POINTER
57120   IFN     LENGTH,<
57140           MOV     A,E             ;FOR "SPC" PUT THE FORMULA
57160           JZ      ASPAC>          ;VALUE IN [A]
57180   IFN     LPTSW,<
57200           LDA     PRTFLG          ;LINE PRINTER OR TTY?
57220           ORA     A               ;NON-ZERO MEANS LPT
57240           JZ      TTYIST
57260           LDA     LPTPOS          ;GET LINE PRINTER POSITION
57280           JMP     DOSIZT>
57300   TTYIST: LDA     TTYPOS          ;GET TELETYPE PRINT POSITION
57320   DOSIZT: CMA                     ;PRINT [E]-[A] SPACES
57340           ADD     E
57360           JNC     NOTABR          ;IF NEGATIVE, DON'T PRINT ANY
57380                                   ;SPACES
57400   ASPA2:  INR     A
57420   ASPAC:  MOV     B,A             ;[B]=NUMBER OF SPACES TO PRINT
57440           MVI     A," "           ;[A]=SPACE
57460   REPOUT: OUTCHR                  ;PRINT [A]
57480           DCR     B               ;DECREMENT THE COUNT
57500           JNZ     REPOUT
57520   NOTABR: POP     H               ;PICK UP TEXT POINTER
57540           CHRGET                  ;AND THE NEXT CHARACTER
57560           JMP     PRINTC          ;AND SINCE WE JUST PRINTED
57580                                   ;SPACES, DON'T CALL CRDO
57600                                   ;IF IT'S THE END OF THE LINE
57620   PAGE
57640   SUBTTL INPUT AND READ CODE
57660   IFN     LENGTH,<
57680   TRYAGN: DC"?REDO FROM START"
57700           ACRLF
57720           0
57740   ;
57760   ; HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
57780   ; IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
57800   ; FOR "DATA" WE GIVE A SYNTAX ERROR AT THE DATA LINE
57820   ;
57840   TRMNOK: LDA     FLGINP          ;WAS IT READ OR INPUT?
57860           ORA     A               ;ZERO=INPUT
57880           JNZ     DATSNE          ;GIVE ERROR AT DATA LINE
57900           POP     B               ;GET RID OF THE POINTER INTO THE VARIABLE LIST
57920           LXI     H,TRYAGN
57940           CALL    STROUT          ;PRINT "?REDO FROM START"
57960           LHLD    TEMP            ;START ALL OVER BY GOING BACK
57980           RET>                    ;TO NEWSTT POINTING AT THE START OF
57982                                   ;OF THE "INPUT" STATEMENT
58000   INPUT:
58020   IFN     LENGTH,<
58040           CPI     34              ;IS IT A QUOTE?
58060   IFN     CONTRW,<
58080           MVI     A,0             ;BE TALKATIVE
58100           STA     CNTWFL>         ;FORCE OUTPUT
58120           JNZ     NOTQTI          ;IF NOT NO MESSAGE
58140   IFN     STRING,<
58160           CALL    STRLTI          ;MAKE THE MESSAGE A STRING
58180           SYNCHK  59              ;MUST END WITH SEMI-COLON
58200           PUSH    H               ;REMEMBER WHERE IT ENDED
58220           CALL    STRPRT          ;PRINT IT OUT
58240           POP     H>
58260   IFE     STRING,<
58280           CALL    STROUI
58300           SYNCHK  59>>            ;ENDS WITH SEMI-COLON
58320   NOTQTI: PUSH    H
58340   IFE     FUNCTS,<
58360           LHLD    CURLIN          ;IS IT DIRECT?
58380           MVI     E,ERRID         ;IF SO "ILLEGAL DIRECT" ERROR
58400           INX     H               ;DIRECT MEANS THAT
58420           MOV     A,L             ;CURLIN=65535
58440           ORA     H               ;ADDED ONE AND GOT 0?
58460           JZ      ERROR>          ;IF SO,GO COMPLAIN
58480   IFN     FUNCTS,<
58500           CALL    ERRDIR>         ;USE COMMON ROUTINE SINCE DEF
58520                                   ;DIRECT IS ALSO ILLEGAL
58540   GETAGN: CALL    QINLIN          ;TYPE '?' AND INPUT A LINE OF TEXT
58560   IFN     LENGTH,<INX     H       ;IF NO INPUT WE QUIT
58580           MOV     A,M
58600           ORA     A
58620           DCX     H
58640           POP     B               ;TAKE OFF SINCE MAYBE LEAVING
58660           JZ      STPEND          ;IF EMPTY LEAVE
58680           PUSH    B>              ;PUT BACK SINCE DIDN'T LEAVE
58700           JMP     INPCON
58720   READ:   PUSH    H               ;SAVE THE TEXT POINTER
58740           LHLD    DATPTH          ;GET LAST DATA LOCATION
58760           XWD     ^O1000,^O366    ;"ORI" TO SET [A] NON-ZERO
58780   INPCON: XRA     A               ;SET FLAG THAT THIS IS AN INPUT
58800           STA     FLGINP          ;STORE THE FLAG
58820   ;
58840   ; IN THE PROCESSING OF DATA AND READ STATEMENTS:
58860   ; ONE POINTER POINTS TO THE DATA (IE THE NUMBERS BEING FETCHED)
58880   ; AND ANOTHER POINTS TO THE LIST OF VARIABLES
58900   ;
58920   ; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
58940   ; TERMINATOR -- A, :, OR END-OF-LINE
58960   ;
58980           XTHL                    ;[H,L]=VARIALBE LIST POINTER
58982                                   ;DATA POINTER GOES ON THE STACK
59000           XWD     ^O1000,1        ;"LXI B," OVER THIS CHECK
59020   LOPDT2: SYNCHK  44              ;MAKE SURE THERE IS A ","
59040           CALL    PTRGET          ;READ THE VARIABLE LIST
59060                                   ;AND GET THE POINTER TO A VARIABLE INTO [D,E]
59080           XTHL                    ;PUT THE VARIABLE LIST POINTER ONTO THE
59100                                   ;STACK AND TAKE THE
59120                                   ;DATA LIST POINTER OFF
59140   ;
59160   ; NOTE AT THIS POINT WE HAVE A VARIABLE WHICH WANTS DATA
59180   ; AND SO WE MUST GET DATA OR COMPLAIN
59200   ;
59220           PUSH    D               ;SAVE THE POINTER TO THE VARIABLE WE
59240                                   ;ARE ABOUT TO SET UP WITH A VALUE
59260           MOV     A,H             ;SINCE THE DATA LIST POINTER ALWAYS POINTS
59280                                   ;AT A TERMINATOR LETS READ THE
59300                                   ;TERMINATOR INTO [A] AND SEE WHAT
59320                                   ;IT IS
59340           CPI     44
59360           JZ      DATBK           ;A COMMA SO A VALUE MUST FOLLOW
59380   IFE     LENGTH,<
59400           ORA     A               ;IN THE 4K VERSION
59420           JNZ     SNERR>          ;DATA MUST BE ALONE ON A LINE
59440           LDA     FLGINP          ;SEE WHAT TYPE OF STATEMENT THIS WAS
59460           ORA     A
59480   IFE     LENGTH,<
59500           INX     H               ;POINT AT POINTER TO THE NEXT LINE
59520           JNZ     DATFND>         ;IF IT IS A READ GO
59540                                   ;SEARCH FOR ANOTHER DATA STATEMENT
59560   IFN     LENGTH,<JNZ     DATLOP>
59580           MVI     A,"?"
59600           OUTCHR                  ;DOUBLE PROMPT WHEN WE NEED MORE INPUT
59620           CALL    QINLIN          ;GET A WHOLE LINE AFTER TYPING "?"
59640                                   ;THE DATA NOW STARTS AT THE BEGINNING
59660                                   ;OF THE BUFFER
59680                                   ;AND QINLIN LEAVES [H,L]=BUF
59700   DATBK:
59720   IFE     LENGTH,<POP     D       ;POP OFF POINTER TO THE VARIABLE
59740           INX     H               ;FUDGE CHARACTER POINTER
59760           CALL    REDINP>         ;READ A VALUE USING "LET" CODE
59780   IFN     LENGTH,<
59800   IFN     STRING,<
59820           LDA     VALTYP          ;SEE IF ITS NUMERIC OR STRING
59840   IFE     LENGTH-2,<
59860           CPI     3               ;IS IT A STRING ?
59880           PUSH    PSW             ;SAVE THE TYPE INFORMATION
59900           JNZ     NUMINS>         ;IF NUMERIC,USE FIN TO GET IT
59920   IFN     LENGTH-2,<
59940           ORA     A
59960           JZ      NUMINS>         ;INPUT A NUMBER IF NUMERIC
59980                                   ;ONLY THE VARIABLE TYPE IS
60000                                   ;CHECKED SO AN UNQUOTED STRING
60020                                   ;CAN BE ALL DIGITS
60040           CHRGET
60060           MOV     D,A             ;ASSUME QUOTED STRING
60080           MOV     B,A             ;SETUP TERMINATORS
60100           CPI     34              ;QUOTE ?
60120           JZ      NOWGET          ;TERMINATORS OK
60140           MVI     D,":"           ;UNQUOTED STRING TERINATORS
60160           MVI     B,44            ;ARE COLON AND COMMA
60180           DCX     H               ;BACKUP SINCE START CHARACTER MUST BE INCLUDED
60200                                   ;IN THE QUOTES STRING CASE WE SON'T WANT TO
60220                                   ;INCLUDE THE STARTING OR ENDING QUOTE
60240   NOWGET: CALL    STRLT2          ;MAKE A STRING DESCRIPTOR FOR THE VALUE
60242                                   ;AND COPY IF NECESSARY
60260   IFE     LENGTH-2,<
60280   DDASIG: POP     PSW>            ;POP OFF THE TYPE INFORMATION
60320           XCHG                    ;[D,E]=TEXT POINTER
60340           LXI     H,STRDN2        ;RETURN LOC
60360           XTHL                    ;[H,L]=PLACE TO STORE VARIABLE VALUE
60380           PUSH    D               ;TEXT POINTER GOES ON
60400           JMP     INPCON>         ;DO ASSIGNMENT
60420   NUMINS: CHRGET
60440           CALL    FIN
60460   IFE     LENGTH-2,<
60480           JMP     DDASIG>         ;ASSIGNMENT IS COMPLCATD
60500                                   ;EVEN FOR NUMERICS SO USE THE "LET" CODE
60520   IFN     LENGTH-2,<
60540           XTHL                    ;[H,L] GET POINTER AT BARIABLE
60560           CALL    MOVMF           ;DO THE ASSIGNMENT
60580           POP     H>>             ;GET BACK THE TEXT POINTER
60600   STRDN2:
60620   IFN     LENGTH,<
60640           DCX     H
60660           CHRGET
60680           JZ      TRMOK
60700           CPI     44
60720           JNZ     TRMNOK          ;ENDED PROPERLY?
60740   TRMOK:  XTHL
60760           DCX     H               ;LOOK AT TERMINATOR
60780           CHRGET                  ;AND SET UP CONDITION CODES
60800           JNZ     LOPDT2          ;NOT ENDING, CHECK FOR COMMA
60820                                   ;AND GET ANOTHER VARIABLE
60840                                   ;TO FILL WITH DATA
60880           POP     D               ;POP OFF THE POINTER INTO DATA
60900           LDA     FLGINP          ;FETCH THE STATEMENT TYPE FLAG
60920           ORA     A
60940   IFE     LENGTH,<RZ>             ;DON'T UPDATE DATPTR IF IT WAS AN
60960                                   ;INPUT STATEMENT
60980           XCHG
61000           JNZ     RESFIN          ;UPDATE DATPTR
61020   IFN     LENGTH,<
61040           ORA     M               ;COULD HAVE ENDED WITH COMMA OR
61060                                   ;COLON, BUT SHOULD BE A ZERO
61080           LXI     H,EXIGNT        ;TEXT FOR "EXTRA"
61100           PUSH    D               ;SAVE THE TEXT POINTER
61120           CNZ     STROUT          ;IF WASN'T REAL END SAY SOMETHING
61140           POP     H               ;GET BACK THE TEXT POINTER
61160           RET
61180   EXIGNT: DC"?EXTRA IGNORED"
61200           ACRLF
61220           O>
61240   ;
61260   ; SUBROUTINE TO FIND DATA
61280   ; IN THE 4K "DATA" MUST BE AT THE START OF THE LINE
61300   ; SO THE SEARCH IS MADE USING THE LINKS AT THE START OF EACH LINE.
61320   ;
61340   ; IN THE 8K AND EXTENDED THE SEARCH IS MADE BY USING THE EXECUTION CODE
61360   ; FOR DATA TO SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
61380   ; IS COMPARED WITH DATATK. EACH NEW LINE NUMBER
61400   ; IS STORED IN DATLIN SO THAT IF AN ERROR OCCURS WHILE READING
61420   ; DATA THE ERROR MESSAGE WILL GIVE THE LINE NUMBER OF THE
61440   ; ILL-FORMATTED DATA
61460   ;
61480   DATLOP: IFN     LENGTH,<CALL    DATA>
61500           IFE     LENGTH,<POP     H>
61520   DATFND: IFN     LENGTH,<
61540           ORA     A
61560           JNZ     NOWLIN>
61580   IFN     LENGTH,<
61600           INX     H>
61620           PUSHM                   ;SAVE POINTER TO THE NEXT STATEMENT
61640           MOV     A,C             ;SEE IF WE ARE AT THE END
61660           ORA     B
61680           MVI     E,ERROD         ;NO DATA IS ERROR ERROD
61700           JNZ     ERROR           ;IF SO COMPLAIN
61720   IFE     LENGTH,<INX     H>      ;SKIP PAST LINE #
61740   IFN     LENGTH,<POP     B>
61760           MOV     E,M             ;GET DATA LINE #
61780           INX     H
61800           MOV     D,M
61820           XCHG
61840           SHLD    DATLIN
61860           XCHG>                   ;RESTORE TEXT POINTER
61880   NOWLIN: CHRGET                  ;GET THE STATEMENT TYPE
61900           CPI     DATATK          ;IS IS "DATA"?
61920           JNZ     DATLOP          ;NOT DATA SO LOOK SOME MORE
61940   IFE     LENGTH,<POP     B>
61960           JMP     DATBK           ;CONTINUE READING
62040   PAGE
62060   SUBTTL NEXT CODE
62080   ;
62100   ; NOTE:
62120   ;
62140   ;
62160   ; A FOR ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
62180   ;
62200   ;
62220   ; LOW ADDRESS
62240   ;       TOKEN (FORTK IN HIGH BYTE)  1 BYTES
62260   ;       A POINTER TO THE LOOP VARIABLE  2 BYTES
62280   ;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
62300   ;       THE STEP 4 BYTES
62320   ;       THE UPPER VALUE 4 BYTES
62340   ;       THE LINE # OF THE "FOR" STATEMENT 2 BYTES
62360   ;       A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
62380   ; HIGH ADDRESS
62400   ;
62420   ; TOTAL 16 BYTES
62440   ;
62460   NEXT:
62480   IFN     LENGTH,<LXI     0,$CODE>;FOR THE "NEXT"
62500                                   ;STATEMENT WITHOUT ANY ARGS
62520                                   ;WE CALL FNDFOR WITH [D,E]=0
62540   NEXTC:
62560   IFE     LENGTH,<
62580           CALL    PTRGET>         ;MUST HAVE A VARIABLE
62600   IFN     LENGTH,<
62620           CNZ     PTRGET>         ;GET A POINTER TO THE
62640                                   ;LOOP VARIABLE INTO [D,E]
62660           SHLD    TEMP            ;PUT THE TEXT POINTER
62680                                   ;IN A TEMP LOCATION
62700                                   ;IN CASE THE LOOP TERMINATES
62720           CALL    FNDFOR          ;TRY TO FIND A FOR ENTRY
62740                                   ;ON THE STACK WHOSE VARIABLE NAME
62760                                   ;MATCHES THIS ONES
62780   IFN     LENGTH,<
62800           JNZ     NFERR>          ;"NEXT WITHOUT FOR"
62820           SPHL                    ;SETUP STACK POINTER BY CHOPPING
62840                                   ;AT THIS POINT
62860           PUSH    D               ;PUT THE VARIABLE PTR BACK ON
62880           MOV     A,M             ;STEP ONTO THE STACK
62900           INX     H
62920           PUSH    PSW
62940           PUSH    D               ;PUT THE POINTER TO THE LOOP
62960                                   ;VARIABLE ONTO THE STACK
62980   IFE     LENGTH,<
63000           MVI     E,ERRNF
63020           JNZ     ERROR>
63040           CALL    MOVFM           ;STEP VALUE INTO THE FAC
63060           XTHL                    ;PUT THE POINTER INTO THE
63080                                   ;FOR ENTRY ONTO THE STACK
63100           PUSH    H               ;PUT THE POINTER TO THE LOOP
63120                                   ;VARIABLE BACK ONTO THE STACK
63140           CALL    FADDS           ;ADD THE STEP AND LOOP VARIABLE
63160           POP     H               ;POP OFF THE POINTER TO
63180                                   ;THE LOOP VARIABLE
63200           CALL    MOVMF           ;MOV FAC INTO LOOP VARIABLE
63220           POP     H               ;GET THE ENTRY POINTER
63240           CALL    MOVRM           ;GET THE FINAL INTO THE REGISTERS
63260           PUSH    H               ;SAVE THE ENTRY POINTER
63280           CALL    FCOMP           ;COMPARE THE NUMBERS
63300           POP     H               ;STILL POINTING TO THE FINAL VALUE
63320           POP     B               ;GET THE SIGN  OF THE INCREMENT
63340           SUB     B               ;SUBTRACT THE INCREMENTS SIGN FROM THAT
63360                                   ;OF (CURRENT VALUE-FINAL VALUE)
63380           CALL    MOVRM           ;GET LINE # OF "FOR" INTO [D,E]
63400                                   ;GET TEXT POINTER OF "FOR" INTO [B,C]
63420           JZ      LOOPON          ;IF SIGN(FINAL-CURRENT)+SIGN(STEP)=0
63440                                   ;THEN THE LOOP IS FINISHED
63460           XCHG
63480           SHLD    CURLIN          ;STORE THE LINE #
63500           MOV     L,C             ;SETUP THE TEXT POINTER
63520           MOV     H,B
63540           JMP     NXTCON
63580   LOOPON: SPHL                    ;ELIMINATE THE FOR ENTRY
63600                                   ;SINCE [H,L] MOVED ALL
63620                                   ;THE WAY DOWN THE ENTRY
63640           LHLD    TEMP            ;RESTORE THE TEXT POINTER
63660   IFE     LENGTH,<JMP     NEWSTT>
63680   IFN     LENGTH,<
63700           MOV     A,M             ;IS THERE A COMMA AT THE END
63720           CPI     44              ;IF SO LOOK AT ANOTHER
63740           JNZ     NEWSTT          ;VARIABLE NAME TO "NEXT"
63760           CHRGET                  ;READ FIRST CHARACTER
63780           CALL    NEXTC>          ;DO NEXT, BUT DON'T ALLOW
63800                                   ;BLANK VARIABLE NAME [D,E]=STK PTR
63820                                   ;AND WILL NEVER MATCH ANY VARPTR
63840                                   ;USE CALL TO PUT DUMMY "NEWSTT" ENTRY ON
63880   PAGE
00020   SUBTTL FORMULA EVALUATION CODE
00060   IFN     LENGTH-2,<
00080   IFN     STRING,<
00100   ;
00120   ; THESE ROUTINES CHECK FOR A CERTAIN VALTYP
00140   ; [A] IS NOT PRESERVED
00160   ;
00180   FRMNUM: CALL    FRMEVL          ;EVALUATE A FORMULA
00200   CHKNUM: XWD     ^O1000,^O366    ;TURN CARRY OFF WITH ORI
00220   CHKSTR: STC                     ;SET CARRY
00240   CHKVAL: LDA     VALTYP          ;0 MEANS NUMERIC 1 MEANS STRING
00260           ADC     A               ;RESULT SHOULD BE 0 OR 3
00280                                   ;BAD RESULTS ARE 2 AND 1
00300           RPE                     ;RETURN IF CORRECT RESULT
00320   TMERR:  MVI     E,ERRTM         ;"TYPE MISMATCH ERROR"
00340           JMP     ERROR>>
00360   ;
00380   ; THE FORMULA EVALUATOR STARTS WITH
00400   ; [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
00420   ; AT THE END [H,L] POINTS TO THE TERMINATOR.
00440   ; THE RESULT IS LEFT IN THE FAC.
00460   ;
00480   ; THE FORMULA EVALUATOR USES THE OPERATOR TABLE (OPTAB)
00500   ; TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
00520   ; EACH OPERATOR.
00540   ; A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT
00560   ;
00580   ; THE ADDRESS OF "RETAOP" -- THE PLACE TO RETURN ON COMPLETION
00600   ; OF OPERATOR APPLICATION
00620   ;
00640   ; THE FLOATING POINT TEMPORARY RESULT
00660   ;
00680   ; THE ADDRESS OF THE OPERATOR ROUTINE
00700   ;
00720   ; THE PRECEDENCE OF THE OPERATOR
00740   ;
00760   ; TOTAL 10 BYTES
00780   ;
00800   IFE     STRING,<FRMNUM:>
00820   FRMEVL: DCX     H               ;BACK UP CHARACTER POINTER
00840   FRMCHK: MVI     D,0             ;INITIAL DUMMY PRECEDENCE IS 0
00860   LPOPER: PUSH    D               ;SAVE PRECEDENCE
00880           CALL    GETSTK          ;MAKE SURE THERE IS ROOM FOR RECURSIVE CALLS
00900           1
00920           CALL    EVAL            ;EVALUATE SOMETHING
00940           SHLD    TEMP2           ;SAVE TEXT POINTER
00960   RETAOP: LHLD    TEMP2           ;RESTORE TEXT PTR
00980   TSTOP:  POP     B               ;POP OFF THE PRECEDENCE
01000   IFN     LENGTH-2,<
01020   IFN     STRING,<
01040           MOV     A,B             ;LOOK AT PRECEDENCE
01060           CPI     120             ;IF ITS SOME ARITHMETIC
01080                                   ;TYPE THING WE SHOULDN'T
01100                                   ;SEE STRINGS
01120           CNC     CHKNUM>>        ;TYPE MISMATCH ERROR IF NOT NUMERIC
01140   NOTSTV: MOV     A,M             ;GET NEXT CHARACTER
01160   IFN     LENGTH,<
01180           MVI     D,0             ;ASSUME NO RELATION OPS
01200   LOPREL: SUI     GREATK          ;IS THIS ONE RELATION?
01220           JC      ENDREL          ;RELATIONS ALL THROUGH
01240   NMREL==LESSTK-GREATK+
01260           CPI     NMREL           ;IS IT REALLY RELATIONAL?
01280           JNC     ENDREL          ;NO JUST BIG
01300           CPI     1               ;SET UP BITS BY MAPPING
01320           RAL                     ;0 TO 1 1 TO 2 AND 2 TO 4
01340           XRA     D               ;BRING IN THE OLD BITS
01360           CMP     D               ;MAKE SURE RESULT IS BIGGER
01380           MOV     D,A             ;SAVE THE MASK
01400           JC      SNERR           ;DON'T ALLOW TWO OF THE SAME
01420           SHLD    TEMP3           ;SAVE CHARACTER POINTER
01440           CHRGET                  LGET THE NEXT CANDIDATE
01460           JMP     LOPREL
01480   ENDREL: MOV     A,D             ;GET THE MASK
01500           ORA     A               ;WERE THERE ANY?
01520           JNZ     FINREL          ;IF SO, HANDLE AS A SPECIAL OP
01540           MOV     A,M             ;GET THE CHARACTER AGAIN
01560           SHLD    TEMP3>          ;SAVE UPDATED CHARACTER POINTER
01580           SUI     PLUSTK          ;AN OPERATOR?
01600           RC                      ;RETURN IF NOT
01620                                   ;THIS CAN RESULT IN OPERATOR
01640                                   ;APPLICATION OR ACTUAL RETURN
01660           CPI     LSTOPK          ;HIGHER THAN THE LAST OP?
01680           RNC
01700           MOV     E,A             ;MUST MUTIPLY BY 3 SINCE
01720                                   ;OPTAB ENTRIES ARE 3 LONG
01740   IFN     STRING,<
01760           LDA     VALTYP          ;SEE IF LEFT PART IS STRING
01780   IFE     LENGTH-2,<
01800           CPI     3>              ;SEE IF ITS A STRING
01820   IFN     LENGTH-2,<
01840           DCR     A>
01860           ORA     E               ;SET CONDITION CODES
01880   IFN     LENGTH-2,<
01900           MOV     A,E>            ;REFETCH OP-VALUE
01920           JZ      CAT>            ;MUST BE CAT
01940   IFN     LENGTH-2,<
01960           RLC                     ;A=ORIGINAL A*2
01980           ADD     E               ;ADD IN ORIGINAL A
02000           MOV     E,A>            ;CREATE TWO BYTE VALUE
02020   IFE     LENGTH,<
02040           MVI     D,0>            ;HIGH ORDER #0
02060           LXI     H,OPTAB         ;CREATE INDEX INTO OPTAB
02080           DAD     D               ;ADD IN CALCULATED OFFSET
02100           MOV     A,B             ;[A] GETS OLD PRECEDENCE
02120           MOV     D,M             ;REMEMBER NEW PRECEDENCE
02140           CMP     D               ;OLD-NEW
02160           RNC                     ;MUST APPLY OLD OP
02180                                   ;IF HAS GREATER OR = PRECEDENCE
02200   IFN     LENGTH-2,<
02220           INX     H               ;NOW POINTING AT ROUTINE ADDRESS
02240   IFN     STRING,<CALL    CHKNUM> ;CAN'T BE STRING HERE
02260                                   ;SINCE THE ONLY STRING OPERATOR
02280                                   ;IS PLUS AND RELATIONALS
02300                                   ;DON'T COME THROUGH HERE
02320   DOPREC: PUSH    B               ;SAVE OLD PRECEDENCE
02340           LXI     B,RETAOP        ;OPERATOR RETURN ADDRESS
02360           PUSH    B               ;FIRST PART OF "TEMP" ENTRY
02380   IFN     LENGTH,<
02400           MOV     B,E>            ;SAVE SECOND BYTE OF PRECEDENCE
02420                                   ;SINCE FOR RELATIONAL OPERATORS
02440                                   ;IT GIVES THE VALUE TYPE OF
02460                                   ;THE LEFT SIDE AND IT TELLS
02480                                   ;WHICH RELATIONAL-OPERATOR
02500                                   ;IT WAS
02520           MOV     C,D
02540           CALL    PUSHF
02560   IFN     LENGTH,<
02580           MOV     E,B>            ;GET SECOND BYTE OF PRECEDENCE AGAIN
02600           MOV     D,C             ;[D] GETS PRECEDENCE
02620           PUSHM                   ;PUT ROUTINE ADDRESS ON THE STACK
02640   IFN     LENGTH,<
02660           LHLD    TEMP3>
02680   IFE     LENGTH,<
02700           LHLD    TEMP2>          ;IF WE DON'T HAVE "LENGTH"
02720                                   ;ON OPERATORS CAN ONLY
02740                                   ;BE ONE CHARACTER SO TO "REREAD"
02760                                   ;AN OPERATOR THAT WE LOOKED
02780                                   ;AT BEFORE AND DECIDED NOT TO
02800                                   ;APPLY WE JUST "DCX H"
02820                                   ;IF LENGTH IS ON WE HAVE TO
02840                                   ;REMEMBER THE TEXT POINTER BEFORE
02860                                   ;THE OPERATOR AND AFTER SO WE CAN
02880                                   ;EITHER RESCAN THE OPERATOR
02900                                   ;LATER IF IT DOESN'T GET APPLIED
02920                                   ;OR GO BEYOND IT WHEN IT DOES
02940           JMP     LPOPER>         ;PUT ON PRECEDENCE AND LOOK AT A
02960                                   ;NEW OPERATOR
03000   IFE     LENGTH-2,<
03020           PUSH    B               LSAVE THE OLD PRECEDENCE
03040           LXI     B,RETAOP        ;PUT ON THE ADDRESS OF THE
03060           PUSH    B               ;PLACE TO RETURN TO AFTER OPERATOR APPLICATION
03080           MOV     A,D             ;SEE IF THE OPERATOR IS EXPONENTIATION
03100           CPI     127             ;WHICH AHS PRECEDENCE 127
03120           JZ      EXPSTK          ;IF SO, "FRCSNG" AND MAKE A SECPIAL STACK ENTRY
03140           CPI     81              ;SEE IF THE OPERATOR IS "AND" OR "OR"
03160           JC      ANDORD          ;AND IF SO "FRCINT" AND
03162                                   ;MAKE A SPECIAL STACK ENTRY
03200   ;
03220   ; THIS CODE PUSHES THE CURRENT VALUE IN THE FAC
03240   ; ONTO THE STACK, EXCEPT IN THE CASE OF STRINGS IN WHICH IT CALLS
03260   ; TYPE MISMATCH ERROR. [D] AND [E] ARE PRESERVED.
03280   ;
03300   NUMREL: LDA     VALTYP          ;GET THE VALUE TYPE
03302           CPI     3               ;AND SET THE CONDITION CODES BASED ON IT
03320           JZ      TMERR           ;BLOW UP ON STRINGS
03340           LXI     H,FACLO         ;GET POINTER TO LO IN FAC
03342           MOV     C,M
03344           INX     H
03346           MOV     B,M
03348           INX     H
03360           PUSH    B               ;PUSH FACLO+0,1 ON THE STACK
03380           JM      VPUSHD          ;ALL DONE IF THE DATA WAS AN INTEGER
03382           MOV     C,M
03384           INX     H
03386           MOV     B,M
03388           INX     H
03400           PUSH    B               ;PUSH FAC-1,0 ON THE STACK
03420           JPO     VPUSHD          ;ALL DONE IF WE HAD A SNG
03440           LXI     H,DFACLO        ;WE HAVE A DOUBLE PRECISON NUMBER
03460           PUSHM                   ;PUSH ITS 4 LO BYTES ON THE STACK
03480           PUSHM
03520   VPUSHD: MOV     C,E             ;[C]=OPERATOR NUMBER
03560           MOV     B,A             ;[B]TYPE OF VALUE ON THE STACK
03580           PUSH    B               ;SAVE THESE THINGS FOR APPLOP
03600           LXI     B,APPLOP        ;GENERAL OPERATOR APPLICATION
03620                                   ;ROUTINE -- DOES TYPE CONVERSIONS
03640   FINTMP: PUSH    B               ;SAVE PLACE TO GO
03660           LHLD    TEMP3           ;REGET THE TEXT POINTER
03680           JMP     LPOPER          ;PUSH ON THE PRECEDENCE AND READ MORE
03700                                   ;FORMULA
03720   ;
03740   ; FOR EXPONENTIATION WE WANT TO FORCE THE CURRENT VALUE IN THE FAC
03760   ; TO BE SINGLE PRECISION. WHEN APPLICATION TIME COMES WE FORCE
03780   ; THE RIGHT HAND OPERAND TO SINGLE PRECISION AS WELL
03800   ;
03820   EXPSTK: CALL    FRCSNG          ;COERCE LEFT HAND OPERAND
03840           CALL    PUSHF           ;PUT IT ON THE STACK
03860           LXI     B,FPWRQ##       ;PLACE TO COERCE RIGHT HAND
03880                                   ;OPERAND AND DO EXPONENTIATION
03900           MVI     D,127           ;RESTORE THE PRECEDENCE
03920           JMP     FINTMP          ;FINISH ENTRY AND EVALUATE MORE FORMULA
03940   ;
03960   ; FOR "AND" AND "OR" WE WANT TO FORCE THE CURRENT VALUE IN THE
03980   ; FAC TO BE AN INTEGER, AND AT APPLICATION TIME FORCE THE RIGHT
04000   ; HAND OPERAND TO BE AN INTEGER
04020   ;
04040   ANDORD: PUSH    D               ;SAVE THE PRECEDENCE (70 OR 80)
04060           CALL    FRCINT
04080           POP     D               ;[D]=PRECEDENCE
04100           PUSH    H               ;PUSH THE LEFT HAND OPERAND
04120           LXI     FINTMP          ;"AND" AND "OR" DOER
04140           JMP     FINTMP          ;PUSH ON THIS ADDRESS,PRECEDENCE
04160                                   ;AND CONTINUE EVALUATION
04180   ;
04200   ; HERE TO BUILD AN ENTRY FOR A RELATIONAL OPERATOR
04220   ; STRINGS ARE TREATED SPECIALLY. NUMERIC COMPARES ARE DIFFERENT
04240   ; FROM MOST OPERATOR ENTRIES ONLY IN THE FACT THAT AT THE
04260   ; BOTTOM INSTEAD OF HAVING RETAOP, DOCMP AND THE RELATIONAL
04280   ; BITS ARE STORED. STRINGS HAVE STRCMP,THE POINTER AT THE STRING DESCRIPTOR,
04300   ; DOCMP AND THE RELATIONAL BITS.
04320   ;
04340   FINREL: MOV     A,B             ;[A]=OLD PRECEDENCE
04360           CPI     100             ;RELATIONALS HAVE PREDENCE 100
04380           RNC                     ;APPLY EARLIER OPERATOR IF IT HAS
04400                                   ;HIGHER PRECEDENCE
04420           PUSH    B               ;SAVE THE OLD PRECEDENCE
04440           PUSH    D               ;SAVE [D]=RELATIONAL BITS
04460           LXI     D,$CODE+25604   ;[D]=PRECEDENCE=100
04480                                   ;[E]=DISPATCH OFFSET FOR
04500                                   ;COMPARES IN APPLOP=4
04520                                   ;IN CASE THIS IS A NUMERIC COMPARE
04540           LXI     H,DOCMP         ;ROUTINE TO TAKE COMPARE ROUTINE RESULT
04560                                   ;AND RELATIONAL BITS AND RETURN THE ANSWER
04580           PUSH    H               ;DOES A JMP TO RETAOP WHEN DONE
04600           CALL    GETYPE          ;SEE IF WE HAVE A NUMERIC COMPARE
04620           JNZ     NUMREL          ;YES, BUILD AN APPLOP ENTRY
04640           LHLD    FACLO           ;GET THE POINTER AT THE STRING DESCRIPTOR
04660           PUSH    H               ;SAVE IT FOR STRCMP
04680           LXI     B,STRCMP        ;STRING COMPARE ROUTINE
04700           JMP     FINTMP          ;PUSH THE ADDRESS, REGET THE TEXT POINTER
04720                                   ;SAVE THE PRECEDENCE AND SCAN
04722                                   ;MORE OF THE FORMULA
04740   ;
04760   ; APPLOP IS RETURNED TO WHEN IT IS TIME TO APPLY AN ARITHMETIC
04762   ; OR NUMERIC COMPARISON OPERATION.
04764   ; THE STACK HAS A DOUBLE BYTE ENTRY WITH THE OPERATOR
04766   ; NUMBER AND THE VALTYP OF THE VALUE ON THE STACK.
04768   ; APPLOP DECIDES WHAT VALUE LEVEL THE OPERATION
04770   ; WILL OCCUR AT, AND CONVERTS THE ARGUMENTS. APPLOP
04772   ; USES DIFFERENT CALLING CONVENTIONS FOR EACH VALUE TYPE.
04776   ; INTEGERS: LEFT IN [D,E] RIGHT IN [H,L]
04778   ; SINGLES:  LEFT IN [B,C,D,E] RIGHT IN THE FAC
04780   ; DOUBLES:  LEFT IN FAC   RIGHT IN ARG
04798   ;
04800   APPLOP: POP     B               ;[B]=STACK OPERAND VALUE TYPE
04820                                   ;[C]=OPERATOR OFFSET
04840           MOV     A,C             ;SAVE IN MEMORY SINCE THE STACK WILL BE BUSY
04860           STA     OPRTYP          ;A RAM LOCATION
04880           MOV     A,B             ;CHECK FOR DOUBLE
04900           CPI     8               ;PRECISION ENTRY ON THE STACK
04920           JZ      STKDBL          ;FORCE FAC TO DOUBLE
04940           LDA     VALTYP          ;SEE IF THE FAC IS DOUBLE PRECISION
04960           CPI     B               ;AND IF SO, CONVERT THE STACK OPERAND
04980           JZ      FACDBL          ;TO DOUBLE PRECISION
05000           MOV     D,A             ;SAVE THE VALUE TYPE OF THE FAC
05020           MOV     A,B             ;SEE IF THE STACK ENTRY IS SINGLE
05040           CPI     4               ;PRECISION AND IF SO, CONVERT
05060           JZ      STKSNG          ;THE FAC TO SINGLE PRECISION
05080           MOV     A,D             ;SEE IF THE FACT IS SINGLE PRECISION
05100           CPI     3               ;AND IF SO CONVERT THE STACK TO SINGLE
05120           JNC     FACSNG          ;PRECISION
05140                                   ;NOTE: THE STACK MUST BE INTEGER AT THIS POINT
05160           JZ      TMERR           ;BLUE UP ON RIGHT HAND STRING OPERAND
05180           LXI     H,INTOSP        ;INTEGER INTEGER CASE
05200           MVI     B,0             ;SPECIAL DISPAYCH FOR SPEED
05220           DAD     B               ;[H,L] POINTS TO THE ADDRESS TO GO TO
05240           DAD     B
05260           MOV     C,M             ;[B,C]=ROUINE ADDRESS
05280           INX     H
05300           MOV     B,M
05320           POP     D               ;[D,E]=LEFT HAND OPERAND
05340           LHLD    FACLO           ;[H,L]=RIGHT HAND OPERAND
05360           PUSH    B               ;DISPATCH
05380           RET
05400   ;
05420   ; THE STACK OPERAND IS DOUBLE PRECISION, SO
05440   ; THE FAC MUST BE FORCED TO DOUBLE PRECISION, MOVED INTO ARG
05460   ; AND THE STACK VALUE POPED INTO THE FAC
05480   ;
05500   STKDBL: CALL    FRCDBL          ;MAKE THE FAC DOUBLE PRECISION
05520           CALL    VMOVAF          ;MOVE THE FAC INTO ARG
05540           POP     H               ;POP OFF THE STACK OPERAND INTO THE FAC
05560           SHLD    DFACLO+2
05580           POP     H
05600           SHLD    DFACLO          ;STORE LOW BYTES AWAY
05620   SNGDBL: POPR                    ;POP OFF A FOUR BYTE VALUE
05640           CALL    MOVFR           ;INFO THE FAC
05660   SETDBL: CALL    FRCDBL          ;MAKE SURE THE LEFT OPERAND IS
05680                                   ;DOUBLE PRECISION
05700           LXI     H,DBLDSP        ;DISPATCH TO A DOUBLE PRECISION ROUTINE
05720   DODSP:  LDA     OPRTYP          ;RECALL WHICH OPERAND IT WAS
05740           RLC                     ;CREATE A DISPATCH OFFSET, SINCE
05760                                   ;TABLE ADDRESSES ARE TWO BYTES
05780           PUSH    B               ;SAVE [B,C] FOR SINGLE PRECISION
05800           MOV     C,A             ;DOUBLE BYTE OFFSET
05820           MVI     B,0             ;INTO [B,C]
05840           DAD     B               ;CALCULATE LOCATION OF ROUTINE TO GO TO
05860           POP     B               ;GET BACK [B,C] FOR SINGLE PRECISION
05880           MOV     A,M             ;GET THE ADDRESS
05900           INX     H
05920           MOV     H,M
05940           MOV     L,A
05960           PCHL                    ;AND PERFORM THE OPERATION, RETURNING
05980                                   ;TO RETAOP, EXCEPT FOR COMPARES WHICH
06000                                   ;RETURN TO DOCMP
06020   ;
06040   ; THE FAC IS DOUBLE PRECISION AND THE STACK IS EITHER
06060   ; INTEGER OR SINGLE PRECISION AND MUST BE CONVERTED
06080   ;
06100   FACDBL: PUSH    B               ;SAVE THE STACK VALUE TYPE
06120           CALL    VMOVAF          ;MOVE THE FAC INTO ARG
06140           POP     PSW             ;POP THE STACK VALUE TYPE INTO [A]
06160           STA     VALTYP          PUT IT IN VALTYP FOR THE FORCE
06180                                   ;ROUTINE
06200           CPI     4               ;SEE IF ITS SINGLE, SO WE KNOW
06220                                   ;HOW TO POP THE VALUE OFF
06240           JZ      SNGDBL          ;IT'S SINGLE PRECISION
06260                                   ;SO DO A POPR / CALL MOVFR
06280           POP     H               ;POP OFF THE INTEGER VALUE
06300           SHLD    FACLO           ;SAVE IT FOR CONVERSION
06320           JMP     SETDBL          ;SET IT UP
06340   ;
06360   ; THIS IS THE CASE WHERE THE STACK IS SINGLE PRECISION
06380   ; AND THE FAC IS EITHER SINGLE PRECISION OR INTEGER
06400   ;
06420   STKSNG: CALL    FRCSNG          ;CONVERT THE FAC IF NECESSARY
06440           POPR                    ;PUT THE LEFT HAND OPERAND IN THE REGISTERS
06460   SNG00:  LXI     H,SNGDSP        ;SETUP THE DISPATCH ADDRESS
06480                                   ;FOR THE SINGLE PRECISION OPERATOR ROUTINES
06500           JMP     DODSP           ;DISPATCH
06520   ;
06540   ; THIS IS THE CASE WHERE THE FAC IS SINGLE PRECISION AND THE STACK
06560   ; IS AN INTEGER
06580   ;
06600   FACSNG: POP     H               ;POP OFF THE INTEGER ON THE STACK
06620           CALL    PUSHF           ;SAVE THE FAC ON THE STACK
06640           CALL    CONSIM          ;CONVERT [H,L] TO A SINGLE PRECISION
06660                                   ;NUMBER IN THE FAC
06680           CALL MOVRF              ;PUT THE LEFT HAND OPERAND IN THE REGISTERS
06700           POP     H               ;RESTORE THE FAC
06720           SHLD    FAC-1           ;FROM THE STACK
06740           POP     H
06760           SHLD    FACLO
06700           JMP     SNGDO>          ;ERFORM THE OPERATION
06820   EVAL:
06840   IFN     LENGTH-2,<
06860   IFN     STRING,<
06880           XRA     A
06900           STA     VALTYP>>        ;ASSUME THE VALUE WILL BE NUMERIC
06820           CHRGET
06840           JC      FIN             ;IF NUMERIC, INTERPRET CONSTANT
06960           CALL    ISLET           ;VARIABLE NAME?
06980           JNC     ISVAR           ;AN ALPHABETIC CHARACTER MEANS YES
07000           CPI     PLUSTK          ;IGNORE "+"
07020           JZ      EVAL
07040           CPI     "."             ;"." AS LEADING CHARACTER OF A
07060                                   ;CONSTANT?
07080           JZ      FIN
07100           CPI     MINUTK          ;NEGATION?
07120           JZ      DOMIN
07140   IFN     STRING,<
07160           CPI     34              ;STRING CONSTANT?
07180           JZ      STRLTI>         ;IF SO BUILD A DESCRIPTOR IN A TEMPORARY
07200                                   ;DESCRIPTOR LOCATION AND PUT A POINTER TO THE
07220                                   ;DESCRIPTOR IN FACLO
07240   IFN     LENGTH,<
07260           CPI     NOTTK           ;CHECK FOR "NOT" OPERATOR
07280           JZ      NOTER>
07300   IFN     FUNCTS,<
07320           CPI     FNTK            ;USER-DEFINED FUNCTION?
07340           JZ      FNDDER>
07360           SUI     ONEFUN          ;IS IT A FUNCTION NAME?
07380           JNC     ISFUN           ;FUNCTIONS ARE THE HIGHEST
07400                                   ;NUMBERED CHARACTERS ALLOWED
07420                                   ;SO THERE IS NO NEED TO CHECK
07440                                   ;THE UPPER BOUND
07460   PATCHK: SYNCHK  "("             ;ONLY POSSIBILITY LEFT
07480                                   ;IS A FORMULA IN PARENTHESES
07500           CALL    FRMEVL          ;RECURSIVELY EVALUATE THE FORMULA
07520           SYNCHK  ")"
07540           RET
07560   DOMIN:
07580   IFE     EXTFNC,<
07600           CALL    EVAL>           ;NO ^ OPERATOR IN THIS CASE
07620   IFN     EXTFNC,<
07640           MVI     D,125           ;A PRECEDENCE BELOW ^
07660                                   ;BUT ABOVE ALL ELSE
07680           CALL    LPOPER          ;SO ^ GREATER THAN UNARY MINUS
07700           LHLD    TEMP2>          ;GET TEXT POINTER
07720           PUSH    H
07740   IFE     LENGTH-2,<
07760           CALL    VNEG>
07780   IFN     LENGTH-2,<
07800           CALL    NEG>            ;NEGATE THE FAC.
07820   LABBCK:                         ;FUNCTIONS THAT DON'T RETURN
07840                                   ;STRING VALUES COME BACK HERE
07860   IFN     LENGTH-2,<
07880   IFN     STRING,<
07900           CALL    CHKNUM>>
07920           POP     H
07940           RET
07960   ISVAR:  CALL    PTRGET          ;GET A POINTER TO THE
07980                                   ;VARIABLE IN [D,E]
08000           PUSH    H               ;SAVE THE TEXT POINTER
08020   IFE     STRING,<
08040           XCHG                    ;TRANSFER THE POINTER AT THE VALUE
08060                                   ;INTO [H,L]
08080           CALL    MOVFM>          ;SETUP FAC WITH VARIABLE VALUE
08100   IFN     STRING,<
08120           XCHG                    ;PUT THE POINTER TO THE VARIABLE VALUE
08140                                   ;INTO [H,L]. IN THE CASE OF A STRING
08160                                   ;THIS IS A POINTER TO A DESCRIPTOR AND NOT
08180                                   ;AN ACTUAL VALUE
08200           SHLD    FACLO           ;IN CASE IT'S STRING STORE THE POINTER
08220                                   ;TO THE DESCRIPTOR IN FACLO
08240   IFE     LENGTH-2,<
08260           CALL    GETYPE          ;FOR STRINGS WE JUST LEAVE
08280           CNZ     VMOVFM>         ;A POINTER IN THE FAC
08300   IFN     LENGTH-2,<
08320           LDA     VALTYP
08340           ORA     A
08360           CZ      MOVFM>>         ;IF NOT,ACTUALLY TRANSFER THE VALUE INTO
08380                                   ;THE FAC USING [H,L] AS THE POINTER.
08400           POP     H               ;RESTORE THE TEXT POINTER
08420           RET
08440   ISFUN:  MVI     B,0
08460           RLC                     ;MULTIPLY BY 2
08480           MOV     C,A
08500           PUSH    B               ;SAVE THE FUNCTION # ON THE STACK
08520           CHRGET
08540   IFN     STRING,<
08560           MOV     A,C             ;LOOK AT FUNCTION #
08580   NUMGFN==2*LASNUM-2*ONEFUN+1
08600           CPI     NUMGFN          ;IS IT PAST LASNUM?
08620           JC      OKNORM          ;NO,MUST BE NORMAL FUNCTION
08640   ;
08660   ; MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
08680   ; THE RETURN ADDRESS OF THESE FUNCTIONS IS A SMALL ROUTINE
08700   ; THAT CHECKS TO MAKE SURE VALTYP IS 0 (NUMERIC) AND POPS OFF
08720   ; THE TEXT POINTER. SO NORMAL FUNCTIONS THAT RETURN STRING RESULTS (I.E. CHR$)
08740   ; MUST POP OFF THE RETURN ADDRESS OF LABBCK, AND POP OFF THE
08760   ; TEXT POINTER AND THEN RETURN TO FRMEVL.
08780   ;
08800   ; THE SO CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT.
08820   ; THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH
08840   ; MUST BE A NUMBER BETWEEN 0 AND 256. THE TEXT POINTER IS
08860   ; PASSED TO THESE FUNCTIONS SO ADDITIONAL ARGUMENTS
08880   ; CAN BE READ. THE TEXT POINTER IS PASSED IN [D,E].
08900   ; THE CLOSE PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
08920   ; TO FRMEVL WITH [H,L] SETUP AS THE TEXT POINTER POINTING BEYOND THE ")".
08940   ; THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
08960   ; IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE INTEGER
08980   ; ARGUMENT (2 BYTES)
09000   ;
09020           SYNCHK  "("             ;FIRST ARGUMENT ALWAYS
09040                                   ;STRING -- SECOND INTEGER
09060           CALL    FRMEVL          ;EAT OPEN PAREN AND FIRST ARG
09080           SYNCHK  44              ;TWO ARGS SO COMMA MUST DELIMIT
09100           CALL    CHKSTR          ;MAKE SURE THE FIRST ONE WAS STRING
09120           XCHG                    ;[D,E]=TXTPTR
09140           LHLD    FACLO           ;GET PTR AT STRING DESCRIPTOR
09160           XTML                    ;GET FUNCTION #
09180                                   ;SAVE THE STRING PTR
09200           PUSH    H               ;PUT THE FUNCTION # ON
09220           XCHG                    ;[H,L]=TXTPTR
09240           CALL    GETBYT          ;[E]=VALUE OF FORMULA
09260           XCHG                    ;TEXT POINTER INTO [D,E]
09280                                   ;[H,L]=INT VALUE OF SECOND ARGUMENT
09300           XTML                    ;SAVE INT VALUE OF SECOND ARG
09320                                   ;[H,L]=FUNCTION NUMBER
09340           JMP     FINGO>          ;DISPATCH TO FUNCTION
09360   OKNORM: CALL    PARCHK          ;MAKE SURE ITS THERE.
09380                                   ;READ THE FORMULA INSIDE
09400                                   ;AND MAKE SURE ITS FOLLOWED BY ")"
09420           XTHL                    ;[H,L]=FUNCTION # AND SAVE TEXT POINTER
09440   IFE     LENGTH-2,<
09460   ;
09480   ; CHECK IF SPECIAL COERCION MUST BE DONE FOR ONE OF THE TRANSCENDENTAL
09500   ; FUNCTIONS (RND, SQR, COS, SIN, TAN, ATN, LOG, AND EXP)
09520   ;
09540           MOV     A,L             ;[A]=FUNCTION NUMBER
09550   BOTCON==<SQRTK-ONEFUN>*2
09560           CPI     BOTCON          ;LESS THAN SQUARE ROOT?
09580           JC      NOTFRF          ;DON'T FORCE THE ARGUMENT
09590   TOPCON==<ATNTK-ONEFUN>*2+1
09600           CPI     TOPCON          ;BIGGER THAN ARC-TANGENT?
09620           PUSH    H               ;SAVE THE FUNCTION NUMBER
09640           CC      FRCSNG          ;IF NOT, FORCE FAC TO SINGLE-PRECISION
09660           POP     H               ;RESTORE THE FUNCTION NUMBER
09680   NOTFRF: >
09700           LXI     D,LABBCK        ;RETURN ADDRESS
09720           PUSH    D               ;MAKE THEM REALLY COME BACK
09740   FINGO:  LXI     B,FUNDSP        ;FUNCTION DISPATCH TABLE
09760           DAD     B               ;ADD ON THE OFFSET
09780   CIFE    LENGTH,<
09800           PUSHM
09820           RET>                    ;GO TO THE ADDRESS POINTED TO BY [H,L]
09840   IFN     LENGTH,<
09860           MOV     C,M             ;FASTER THAN PUSHM
09880           INX     H
09900           MOV     H,M
09920           MOV     L,C
09940           PCHL>                   ;GO PERFORM THE FUNCTION
09960   IFE     LENGTH-2,<
09980   ;
10000   ; GET THE VALTYP AND SET CONDITION CODES AS FOLLOWS:
10020   ; CONDITION CODE        TRUE SET        FALSE SET
10030   ;
10040   ; SIGN                  INT=2           STR,SNG,DBL
10060   ; ZERO                  STR=3           INT,SNG,DBL
10080   ; ODD PARITY            SNG=4           INT,STR,DBL
10100   ; NO CARRY              DBL=10          INT,STR,SNG
10120   ;
10140   GETYPE: LDA     VALTYP          ;GET THE VALTYP
10160           CPI     B               ;SET CARRY CORRECTLY
10180           DCR     A               ;SET THE OTHER CONDITION CODE CORRECTLY
10200           DCR     A               ; WITHOUT AFFECTING CARRY
10220           DCR     A
10240           RET>
10280   IFN     LENGTH-2,<
10300   IFN     LENGTH,<
10320   OR:     XWD     ^O1000,^O366    ;"ORI" , FLAG AS "OR"
10340                                   ;AND USE COMMON "AND" CODE
10360   AND:    XRA     A               ;FLAG AS "AND"
10380   ANDCON:
10400           PUSH    PSW
10420   IFN     STRING,<CALL    CHKNUM>
10440           CALL    DEINT           ;GET [D,E]=INT VALUE AND CHECK SIZE
10460           POP     PSW
10480           XCHG                    [H,L]=INT VALUE
10500           POP     0               ;GET HIGH ORDER OFF
10520           XTHL                    ;PUT INT VALUE ON
10540                                   ;GET LOW OF SECOND ARG OFF
10560           XCHG                    ;[D,E]=LOW OF SECOND ARG
10580           CALL    MOVFR
10600           PUSH    PSW
10620           CALL    DEINT           ;GET [D,E]=INT VALUE
10640           POP     PSW
10660                                   ;OF FIRST ARG AND CHECK SIZE
10680           POP     B               ;[B,C]=INT VALUE OF SECOND ARG
10700           MOV     A,C             ;[A]=LOW OF SECOND ARG
10720           LXI     H,GIVACF        ;SETUP JUMP ADDRESS
10740           JNZ     ORFIN           ;IT WAS "OR" SO FINISH UP
10760           ANA     E               ;AND TWO LOW ORDERS
10780           MOV     C,A             ;SAVE ANSWER IN [C]
10800           MOV     A,B             ;[A]=HIGH ORDER SECOND ARG
10820           ANA     D               ;[A]=HIGH ORDER OF ANSWER
10840           PCHL                    ;FLOAT [A,C] AS ANSWER
10860   ORFIN:  ORA     E               ;OR TWO LOW ORDERS
10880           MOV     C,A             ;SAVE ANSWER LOW ORDER IN [C]
10900           MOV     A,B             ;[A]=HIGH ORDER SECOND ARG
10920           ORA     D               ;OR TWO HIGH ORDERS
10940                                   ;[A]=HIGH ORDER OF ANSWER
10960           PCHL                    ;FLOAT [A,C] AS ANSWER
10980   FINREL: LXI     H,PTDORL        ;MAKE [H,L] POINT AT OPERATOR ADDRESS
11000   IFN     STRING,<
11020           LDA     VALTYP          ;STORE VALUE TYPE AS LOW
11040           RAR                     ;ORDER BIT OF [E]
11060           MOV     A,D             ;GET RELATIONAL MEMORIES IN [A]
11080           RAL                     ;MOVE CARRY BIT IN
11100           MOV     E,A>            ;KEEP THIS BYTE IN [E]
11120   IFE     STRING,<MOV    E,D>
11140           MVI     D,100           ;PRECEDENCE OF ALL RELATIONAL
11160                                   ;OPERATORS IS 100
11180           MOV     A,B             ;[A]=PRECEDENCE OF OLD OPERATOR
11200           CMP     D               ;SEE WHETHER TO APPLY OLD OPERATOR
11220           RNC                     ;IF OLD OPERATOR HAS EQUAL OR GREATER
11240                                   ;PRECEDENCE THAN IT MUST BE APPLIED
11260           JMP     DOPREC          ;SEE IF TIME TO APPLY
11280                                   ;AND IF NOT SAVE INFO ON THE STACK
11300
11320   PTDORL: ADR(DOREL)              ;ADDRESS OF RELATIONAL
11340                                   ;OPERATOR APPLICATION
11360                                   ;ROUTINE
11380   ;
11400   ; TIME TO PERFORM A RELATIONAL OPERATOR
11420   ; [C] CONTAINS THE BITS AS TO WHICH RELATIONAL
11440   ; OPERATOR IT WAS (IF STRINGS ON
11460   ; LOW ORDER BIT SAYS WHETHER IT WAS STRING OR NOT)
11480   ;
11500   DOREL:  MOV     A,C             ;GET MEMORIES INTO [A]
11520   IFN     STRING,<
11540           ORA     A
11560           RAR>                    ;CARRY=WHETHER WAS STRING OR NOT
11580           POPR                    ;POP OFF LEFT RESULT
11600           PUSH    PSW             ;SAVE WHICH OPERATOR IT WAS
11620   IFE     STRING,<
11640           CALL    FCOMP>          ;DO A NUMERIC COMPARE
11660   IFN     STRING,<
11680           CALL    CHKVAL          ;SEE IF VALTYP MATCHES
11700                                   ;CARRY AND SET ZERO IN THE
11720                                   ;NUMERIC CASE
11740           LXI     H,DOCMP         ;COME BACK TO COMPARE
11760           PUSH    H
11780           JZ      FCOMP           ;DO NUMERIC COMPARE
11800           XRA     A               ;SET VALUE TYPE AS NUMERIC
11820           STA     VALTYP>>>
11840   IFN     STRING,<
11860   ;
11880   ; THE FOLLOWING ROUTINE COMPARES TWO STRINGS
11900   ; ONE WITH DESC IN [D,E] OTHER WITH DESC. IN [FACLO, FACLO+1]
11920   ; A=0 IF STRINGS EQUAL
11940   ; A=377 IF B,C,D,E POINTER FACLO
11960   ; A=1 IF B,C,D,E .LT. FACLO
11980   ;
12000   IFN     LENGTH-2,<
12020   STRCMP: PUSH    D               ;SAVE DESC. POINTER TO FIRST STR.
12040           CALL    FREFAC          ;FREE THE FACLO STR
12060           POP     D               ;RESTORE 1ST DESC. POINTER
12080           PUSHM                   ;SAVE LENGTH
12100           PUSHM                   ;SAVE POINTER
12120           CALL    FRETMP          ;FREES 1ST DESC. POINTER
12140           CALL    MOVRM           ;[B,C] POINT AT FIRST CHAR
12160                                   ;[E] HAS THE LENGTH
12180           POP     H               ;GET 2ND CHARACTER POINTER IN H
12200           XTHL                    ;GET 2ND CHARACTER COUNTER IN L
12220           MOV     D,L>            ;SAVE IN D
12240   IFN     LENGTH-2,<
12260   STRCMP: CALL    FRESTR          ;FREE UP THE FAC STRING, AND GET THE
12280                                   ;POINTER TO THE FAC DESCRIPTOR IN [H,L]
12300           MOV     A,M             ;SAVE THE LENGTH OF THE FAC STRING IN [A]
12320           INX     H
12340           MOV     C,M             ;SAVE THE POINTER AT THE FAC STRING
12342                                   ;DATA IN [B,C]
12360           INX     H
12380           MOV     B,M
12400           POP     D               ;GET THE STACK STRING POINTER
12420           PUSH    B               ;SAVE THE POINTER AT THE FAC STRING DATA
12440           PUSH    PSW             ;SAVE THE FAC STRING LENGTH
12460           CALL    FRETMP          ;FREE UP THE STACK STRING AND RETURN
12480                                   ;THE POINTER TO THE STACK STRING DESCRIPTOR
12500                                   ;IN [H,L]
12520           POP     D               ;[D]=LENGTH OF FAC STRING
12540           MOV     E,M             ;[E]=LENGTH OF STACK STRING
12560           INX     H
12580           MOV     C,M             ;[B,C]=POINTER AT STACK STRING
12600           INX     H
12620           MOV     B,M>
12640           POP     H               ;GET BACK 2ND CHARACTER POINTER
12660   CSLOOP: MOV     A,E             ;BOTH STRINGS ENDED
12680           ORA     D               ;TEST BY OR'ING THE LENGTHS TOGETHER
12700           RZ                      ;IF SO, RETURN WITH A ZERO
12720           MOV     A,D             ;GET FACLO STRING LENGTH
12740           ORA     A               ;IF IT ENDED, OTHER MUST NOT HAVE
12760           CMA                     ;MAKE -1
12780           RZ                      ;TEST
12800           XRA     A               ;MUST NOT HAVE BEEN ZERO, TEST CASE
12820           CMP     E               ;OF B,C,D,E STRING HAVING ENDED FIRST
12840           INR     A               ;RETURN WITH A=1
12860           RNC                     ;TEST THE CONDITION
12880   ;HERE WHEN NETIHER STRING ENDED
12900           DCR     D               ;DECREMENT BOTH CHARACTER COUNTS
12920           DCR     E
12940           LDAX    B               ;GET CHARACTER FROM B,C,D,E STRING
12960           CMP     M               ;COMPARE WITH FACLO STRING
12980           INX     H               ;BUMP POINTERS (INX DOESNT CLOBBER CC'S)
13000           INX     B
13020           JZ      CSLOOP          ;IF BOTH THE SAME, MUST BE MORE TO STRINGS
13040           CMC                     ;HERE WHEN STRINGS DIFFER
13060           JMP     SIGNS>          ;SET [A] ACCORDING TO CARRY
13080   IFN     LENGTH,<
13100   DOCMP:  INR     A               ;SETUP BITS
13120           ADC     A               ;4=LESS 2=EQUAL 1=GREATER
13140           POP     B               ;WHAT DID HE WANT?
13160           ANA     B               ;ANY BITS MATCH?
13180           ADI     255             ;MAP 0 TO 0
13200           SBB     A               ;AND ALL OTHERS TO 377
13220   IFE     LENGTH-2,<
13240           CALL    CONIA##         ;CONVERT [A] TO AN INTEGER SIGNED
13260           JMP     RETAOP          ;RETURN FROM OPERATOR APPLICATION
13280   IFN     LENGTH-2,<
13300           JMP     FLOAT           ;MAKE FAC=[A] SIGNED
13320                                   ;COULD FALL INTO FLOAT BUT MESSY (SAVES
13340                                   ;TWO BYTES)
13360
13380   NOTER:  MVI     D,90            ;"NOT" HAS PRECEDENCE 90
13400           CALL    LPOPER          ;GO PERFORM
13420   IFN     STRING,<CALL    CHKNUM> ;MAKE SURE ITS INT
13440           CALL    DEINT           ;GET VALUE IN [D,E]
13460           MOV     A,E
13480           CMA                     ;COMPLEMENT
13500           MOV     C,A             ;[C] LOW ORDER OF ANSWER
13520           MOV     A,D
13540           CMA                     ;COMPLEMENT HIGH ORDER TOO
13560           CALL    GIVACF          ;FLOAT [A,C] AS RESULT
13580           POP     B               ;TAKE RETURN ADDRESS OF FRMEVL
13600           JMP     RETAOP>>        ;OFF AND RETURN TO THE RIGHT
13620                                   ;PLACE SO THE TEXT POINTER
13640                                   ;WILL GET SET UP TO WHAT IT WAS
13660                                   ;WHEN LPOPER RETURNED.
13680   IFE     LENGTH-2,<
13700   NOTER:  MVI     D,90            ;"NOT" HAS PRECEDENCE OF 90, SO
13720           CALL    LPOPER          ;FORMULA EVALUATION IS ENTERED WITH A DUMMY
13730                                   ;ENTRY OF 90 ON THE STACK
13740           CALL    FRCINT          ;COERCE THE ARGUMENT TO INTEGER
13760           MOV     A,L             ;COMPLEMENT [H,L]
13780           CMA
13800           MOV     L,A
13820           MOV     A,H
13840           CMA
13860           MOV     H,A
14880           SHLD    FACLO           ;UPDATE THE FAC
13900           POP     0               ;FRMEVL, AFTER SEEING THE PRECEDENCE
13910                                   ;OF 90 THINKS IT IS APPLYING AN OPERATOR
13915                                   ;SO IT HAS THE TEXT POINTER IN TEMP2 SO
13920           JMP     RETAOP          ;RETURN TO REFETCH IT
14042   ;
14044   ; DANDOR APPLIES THE "AND" AND "OR" OPERATORS
14046   ; AND SHOULD BE USED TO IMPLEMENT ALL LOGICAL OPERATORS.
14048   ; WHENEVER AN OPERATOR IS APPLIED, ITS PRECEDENCE IS IN[B].
14050   ; THIS FACT IS USED TO DISTINGUISH BETWEEN "AND" AND "OR".
14052   ; THE RIGHT HAND ARGUMENT IS COERCED TO INTEGER, JUST AS
14054   ; THE LEFT HAND ONE WAS WHEN IT WAS PUSHED ON THE STACK.
14056   ;
14060   DANDOR: PUSH    B               ;SAVE THE PRECEDENCE "OR"=70
14080           CALL    FRCINT          ;COERCE RIGHT HAND ARGUMENT TO INTEGER
14100           POP     PSW             ;GET BACK THE PRECEDENCE TO DISTINGUISH
14120                                   ;"AND" AND "OR"
14140           POP     D               ;POP OFF THE LEFT HAND ARGUMENT
14160           CPI     70              ;SET ZERO FOR "OR"
14180           MOV     A,E             ;SETUP LOW IN [A]
14200           JZ      ORFIN           ;DO "OR" IF PRECEDENCE WAS 70
14220           ANA     L
14240           MOV     L,A
14260           MOV     A,H
14280           ANA     D
14300           MOV     H,A
14320           JMP     MAKINT          ;RETURN THE INTEGER [H,L]
14322                                   ; AS THE "AND"ED RESULT
14324   ORFIN:  ORA     L
14326           MOV     L,A
14328           MOV     A,H
14330           ORA     D
14332           MOV     H,A
14334           JMP     MAKINT>         ;RETURN THE INTEGER [H,L]
14336                                   ; AS THE "OR"ED RESULT
14340   PAGE
14360   SUBTTL  DIMENSION & VARIABLE SEARCHING
14380   DIMCON: DCX     H               ;SEE IF COMMA ENDED THIS VARIABLE
14400           CHRGET
14420           RZ                      ;IF TERMINATOR, GOOD BYE
14440           SYNCHK  44              ;MUST BE COMMA
14442   ;
14444   ; THE "DIM" CODE SETS DIMFLG AND THEN FALLS INTO THE VARIABLE
14446   ; SEARCH ROUTINE. THE VARIABLE SEARCH ROUTIME LOOKS AT
14448   ; DIMFLG AT THREE DIFFERENT POINTS:
14450   ;
14452   ;       1) IF AN ENTRY IS FOUND, DIMFLG BEING ON INDICATES
14454   ;               A "DOUBLY DIMENSIONED" VARIABLE
14456   ;       2) WHEN A NEW ENTRY IS BEING BUILT DIMFLG'S BEING ON
14458   ;               INDICATES THE INDICES SHOULD BE USED FOR
14460   ;               THE SIZE OF EACH INDICE. OTHERWISE THE DEFAULT
14462   ;               OF TEN IS USED.
14464   ;       3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF DIMFLG IS
14466   ;               OFF WILL INDEXING BE DONE
14468   ;
14478   DIM:    LXI     B,DIMCON        ;PLACE TO COME BACK TO
14480           PUSH    B
14500           XWD     ^O1000,^O366    ;"ORI" NON ZERO THING
14520   ;
14540   ; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
14560   ; AND PUT A POINTER TO ITS VALUE IN [D,E]. [H,L] IS UPDATED
14580   ; TO POINT TO THE CHARACTER AFTER THE VARIABLE NAME.
14600   ; VALTYP IS SETUP. NOTE THAT EVALUATING SUBSCRIPTS IN
14620   ; A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO PTRGET SO AT
14640   ; THAT POINT ALL VALUES MUST BE STORED ON THE THE STACK.
15660   ;
15680   PTRGET: XRA     A               ;MAKE [A]=0
15700           STA     DIMFLG          ;FLAG IT AS SUCH
15720           MOV     B,M             ;GET FIRST CHARACTER IN [B]
15740   PTRGT2: CALL    ISLET           ;CHECK FOR LETTER
15760           JC      SNERR           ;MUST HAVE A LETTER
15780           XRA     A
15800           MOV     C,A             ;ASSUME NO SECOND CHARACTER
15820   IFN     LENGTH-2,<
15840   IFN     STRING,<
15860           STA     VALTYP>>        ;DEFAULT IS ZERO (NUMERIC)
15880           CHRGET                  ;GET THE FOLLOWING CHARACTER
15900   IFE     LENGTH,<
15920           JNC     NOSEC>          ;ONLY NUMBERS ALLOWED
15940   IFN     LENGTH,<
14960           JC      ISSEC           ;CARRY SET BY CHRGET IF CHARACTER IS
14980                                   ;NUMERIC
15000           CALL    ISLET           ;SET CARRY IF NOT ALPHABETIC
15020           JC      NOSEC>          ;ALLOW ALPHABETICS
15040   ISSEC:  MOV     C,A             ;IT IS A NUMBER--SAVE IN C
15060   EATEM:  CHRGET                  ;LOOK AT NEXT CHARACTER
15080   IFN LENGTH,<
15100           JC      EATEM           ;SKIP NUMERICS
15120           CALL    ISLET
15140           JNC     EATEM>          ;SKIP ALPHABETICS
15160   NOSEC:
15180   IFE     LENGTH-2,<
15200           LXI     D,HAVTYP        ;SAVE JUMPS BY USING RETURN ADDRESS
15220           PUSH    D
15240           MVI     D,B             ;ASSUME ITS DOUBLE PRECISION
15260           CPI     "#"             ;CHECK THE CHARACTER
15280           RZ                      ;WHEN WE MATCH, SETUP VALTYP
15300           MVI     D,2             ;CHECK FOR INTEGER
15320           CPI     "%"
15340           RZ
15360           INR     D               ;CHECK FOR STRING
15380           CPI     "$"
15400           RZ
15420           INR     D               ;SINGLE PRECISION IS THE DEFAULT
15440           DCX     H               ;NO MARKING CHARACTER
15460           RET                     ;GET RID OF RETURN ADDRESS
15480   HAVTYP: MOV     A,D             ;SETUP VALTYP
15500           STA     VALTYP
15520           CHRGET>                 ;READ PAST TYPE MARKER
15540   IFN     LENGTH-2,<
15560   IFN     STRING,<
15580           SUI     "$"             ;IS IT A STRING?
15600           JNZ     NOTSTR          ;IF NOT VALTYP ALREADY
15620           INR     A               ;[A]=1
15640           STA     VALTYP          ;FLAG THIS AS A STRING
15660           RRC                     ;MAKE [A]=128
15680           ADD     C               ;MAKE [A]=SECOND CHARACTER
15700           MOV     C,A             ;BACK INTO [C] WITH STRING BIT ON
15720           CHRGET                  ;GET CHARACTER AFTER "$"
15740   NOTSTR: >>
15760   IFN     LENGTH,<
15780           LDA     SUBFLG          ;GET FLAG WHETHER TO ALLOW ARRAYS
15800           ADD     M>              ;ADD ONTO CHARACTER
15820           CPI     "("             ;ARRAY PERHAPS (IF SUBFLG SET NEVER WILL MATCH)
15840           JZ      ISARY           ;IT IS!
15860   IFN     LENGTH,<
16880           XRA     A               ;ALLOW PARENS AGAIN
15900           STA     SUBFLG>         ;SAVE IN FLAG LOCATION
15920           PUSH    H               ;SAVE THE TEXT POINTER
15960   IFE     LENGTH-2,<
15980           MOV     A,D             ;VALUE TYPE INTO [A]
15990           LHLD    VARTAB          ;[H,L]=PLACE TO START THE SEARCH
16000   LOPFND: PUSH    PSW             ;SAVE THE VALUE TYPE
16020           XCHG                    ;[D,E]=POINTER INTO SIMPLE VARIABLES
16040           LHLD    ARYTAB          ;[H,L]=END OF SIMPLE VARIABLES
16060           COMPAR                  ;SEE IF THE END HAS BEEN REACHER
16080           POP     H               ;[H]=VALTYP
16100           JZ      NOTFNS          ;COULDN'T FIND IT, SO MAKE A NEW ENTRY
16120           LDAX    D               ;GET THE VALTYP OF THIS SIMPLE VARIABLE
16140           MOV     L,A             ;SAVE SO WE KNOW HOW MUCH TO SKIP
16160           CMP     H               ;COMPARE WITH OUT VALTYP
16180           INX     D
16200           JNZ     NOTIT1          ;NOT RIGHT KIND -- SKIP IT
16220           LDAX    D               ;[A]=FIRST CHARACTER OF THIS VARIABLE
16240           CMP     C               ;SEE IF OUR VARIABLE MATCHES
16260           JNZ     NOTIT1
16280           INX     D
16300           LDAX    D               ;SEE IF SECOND CHARACTER MATCHES
16320           CMP     B
16340           JZ      FINPTR          ;THAT WAS IT, ALL DONE
16360           XWD     ^O1000,^O76     ;"MVI A," AROUND THIS INX SINCE THE POINTER
16380                                   ;IS ALREADY INCREMENTED
16400   NOTIT1: INX     D
16420           INX     D
16440           MOV     A,H             ;SKIP OVER THE
16460                                   ;CURRENT VARIABLE SINCE WE DIDN'T MATCH
16480                                   ;SAVE THE VALTYP IN [A]
16500           MVI     H,0             ;[H,L]=NUMBER OF BYTES TO SKIP
16520           DAD     D               ;ADD ON THE POINTER
16540           JMP     LOPFND          ;AND SEARCH SOME MORE
16560   NOTFNS: PUSH    B               ;SAVE THE LOOKS
16580           MOV     C,H             ;[B,C]=LENGTH OF THIS VARIABLE
16600           MOV     B,A             ;[B]=0
16620           PUSH    B               ;SAVE THE VALTYP ON THE STACK
16640           INX     B               ;MAKE THE LENGTH INCLUDE
16660                                   ;THE LOOKS TOO
16680           INX     B
16700           INX     B>
16720   IFN     LENGTH-2,<
16730           LHLD    ARYTAB          ;PLACE TO STOP SEARCHING
16740           XCHG
16760           LHLD    VARTAB          ;GET THE PLACE TO START
16780   LOPFND: COMPAR                  ;SEE IF WE ARE THERE
16800           JZ      NOTFNS          ;COULDN'T FIND THIS VARIABLE
16820                                   ;SO MAKE ROOM FOR IT
16840           MOV     A,C
16860           SUB     M               ;IS THIS VARIABLE THE ONE?
16880           INX     H
16900           JNZ     NOTIT           ;NOPE
16920           MOV     A,B
16940           SUB     M               ;TRY SECOND CHARACTER MATCHING
16960   NOTIT:  INX     H
16980           JZ      FINPTR          ;THAT WAS IT!
17000           INX     H               ;SKIP OVER THAT ONE--NOT IT
17020           INX     H
17040           INX     H
17060           INX     H
17080           JMP     LOPFND          ;TRY AGAIN
17100   NOTFNS: PUSH    B               ;REMEMBER WHAT THIS
17120                                   ;VARIABLE LOOKS LIKE
17140           LXI     B,6+$CODE>      ;THE AMOUNT TO SHOVE
17160                                   ;EVERYTHING UP BY
17180           LHLD    STREND          ;THE CURRENT END OF STORAGE
17200           PUSH    H               ;SAVE THIS #
17220           DAD     B               ;ADD ON THE AMOUNT OF SPACE
17240                                   ;EXTRA NOW BEING USED
17260           POP     B               ;POP OFF HIGH ADDRESS TO MOVE
17280           PUSH    H               ;SAVE NEW CANDDIATE FOR STREND
17300           CALL    BLTU            ;BLOCK TRANSFER AND MAKE SURE
17320                                   ;WE ARE NOT OVERFLOWING THE
17340                                   ;STACK SPACE
17360           POP     H               ;[H,L]=NEW STREND
17380           SHLD    STREND          ;STORE SINCE WAS OK
17400                                   ;THERE WAS ROOM, AND BLOCK TRANSFER
17420                                   ;WAS DONE, SO UPDATE POINTERS
17440           MOV     H,B             ;GET BACK [H,L] POINTING AT THE END
17460           MOV     L,C             ;OF THE NEW VARIABLE
17480           SHLD    ARYTAB          ;UPDATE THE ARRAY TABLE POINTER
17500   ZEROER: DCX     H               ;[H,L] IS RETURNED POINTING TO THE
17520           MVI     M,0             ;END OF THE VARIABLE SO WE
17540           COMPAR                  ;ZERO BACKWARDS TO [D,E] WHICH
17560           JNZ     ZEROER          ;POINTS TO THE START OF THE VARIABLE
17580   IFE     LENGTH-2,<
17600           POP     D               ;[E]=VALTYP
17620           MOV     M,E             ;STORE AS PART OF THE LOOKS
17640           INX     H>
17660           POP     D
17680           MOV     M,E             ;PUT DESCRIPTION
17700           INX     H
17720           MOV     M,D             ;OF THIS VARIABLE
17740                                   ;INTO MEMORY
17760   IFE     LENGTH-2,<
17780           XCHG                    ;POINTER AT VARIABLE INTO [D,E]
17800   FINPTR: INX     D>              ;POINT AT THE VALUE
17820   IFN     LENGTH-2,<
17840           INX     H
17860   FINPTR: XCHG>                   ;VARIABLE POINTER INTO [D,E]
17880           POP     H               ;RESTORE THE TEXT POINTER
17900           RET
17940   IFE     MULDIM,<
17960   ISARY:  PUSH    B               ;REMEMBER WHAT VARIABLE LOOKS
17980                                   ;LIKE
18000   IFN     STRING,<
18020           PUSH    H               ;SAVE THE TXTPTR
18040           LHLD    DIMFLG          ;[L]=DIMFLG [H]=VALTYP
18060           XTHL>                   ;PUT VALTYP AND DIMFLG ON THE STACK
18080                                   ;AND RESTORE THE TEXT POINTER
18100   IFE     STRING,<
18120           LDA     DIMFLG          ;SINCE THIS CALL IS RECURSIVE
18140           PUSH    PSW>            ;DIMFLG MUST BE SAVED ON THE STACK
18160           CALL    INTIDX          ;EVALUATE THE INDEX INTO [D,E]
18180           SYNCHK  ")"             ;MAKE SURE HE CLOSED IT
18200   IFN     STRING,<
18220           XTHL                    ;[L]=DIMFLG [H]=VALTYP
18240                                   ;TEXT POINTER ONTO THE STACK
18260           SHLD    DIMFLG          ;SAVE BOTH VALUES BACK
18280           POP     H>              ;RESTORE THE TEXT POINTER
18300   IFE     STRING,<
18320           POP     PSW             ;GET DIMFLG OFF THE STACK
18340           STA     DIMFLG>         ;RESTORE IT
18360           XTHL                    ;[H,L] GET VARIABLE DESCRIPTOR
18380                                   ;TEXT POINTER IS PUT ONTO
18400                                   ;THE STACK
18420           XCHG                    ;[D,E]=DESCRIPTOR
18440                                   ;[H,L]=INDEX
18460           DAD     H               ;MULTIPLY BY 4 TO GET
18480           DAD     H               ;BYTE OFFSET
18500           PUSH    H               ;SAVE THE INDEX
18520           LHLD    ARYTAB          ;PLACE TO START SEARCH
18540           XWD     ^O1000,1        ;"LXI B," OVER THE NEXT 2
18560   LOPFD2: POP     B               ;[B,C]=LENGTH OF LAST VARIABLE
18580           DAD     B               ;SKIP OVER LAST VARIABLE BY ADDING ITS
18600                                   ;LENGTH ONTO [H,L]
18620           XCHG                    ;[D,E] GET CURRENT SEARCH POINT
18640           PUSH    H               ;SAVE THE VARIABLE LOOK
18660           LHLD    STREND          ;GET PLACE TO STOP
18680           COMPAR                  ;SEE IF WE ARE THERE
18700           XCHG                    ;[H,L] GETS SEARCH POINT
18720           POP     D               ;POP OFF VARIABLE LOOKS
18740           JZ      NOTFDO          ;COULDN'T FIND IT
18760           PUSHM                   ;PUT ON LOOKS OF VARIABLE
18780                                   ;WE ARE EXAMINING
18800           XTHL                    ;PUT [H,L] ON THE STACK AND
18820                                   ;LOOKS OF VARIABLE WE ARE
18840                                   ;EXAMINING INTO [H,L]
18860           COMPAR                  ;IS THIS THE VARIABLE
18880           POP     H               ;POP OFF SEARCH POINTER
18900           PUSHM                   ;PUSH LENGTH OF VARIABLE
18920                                   ;BEING EXAMINED ONTO THE STACK
18940           JNZ     LOPFD2          ;IF NO MATCH,GO LOOK SOMEMORE
18960           LDA     DIMFLG          ;IS THIS VARIABLE TRYING TO BE
18980                                   ;DIMENSIONED AND ALREADY
19000           ORA     A               ;EXISTS?
19020           MVI     E,ERRDD         ;THATS ERROR ERRDD
19040           JNZ     ERROR
19060   MAKDFN: POP     D               ;POP OFF LENGTH OF THIS VARIABLE
19080           DCX     D               ;DECREMENT LENGTH SO WE CAN
19100                                   ;JUST LOOK AT 'CARRY' AFTER
19120                                   ;CALLING COMPAR
19140           XTHL                    ;TRADE POINTER AT VARIABLE WITH
19160                                   ;INDEX INTO THE VARIABLE
19180           COMPAR                  ;SEE IF INDEX IS TOO BIG
19200           MVI     E,ERRBS         ;THATS ERROR ERRBS
19220           JNC     ERROR           ;SINCE LENGTH REALLY HAS AN
19240                                   ;EXTRA ONE ADDED TO IT
19260                                   ;IF INDEX-LENGTH DOESN'T CARRY
19280                                   ;HE IS IN TROUBLE
19300           POP     D               ;POP OFF POINTER AT VARIABLE
19320           DAD     D               ;ADD IT TO THE INDEX
19340           POP     D               ;POP OFF TEXT POINTER
19360           XCHG                    ;TEXT POINTER INTO [H,L]
19380           RET                     ;VARIABLE POINTER INTO [D,E]
19400
19420   NOTFOD: MOV     M,E             ;PUT LOOKS DOWN
19440           INX     H
19460           MOV     M,D
19480           INX     H
19500           LXI     D,$CODE+44      ;DEFAULT SIZE IS 10
19520           LDA     DIMFLG          ;ARE WE DIMENSIONING
19540           ORA     A
19560           JZ      NOTDIM
19580           POP     D               ;POP OFF INDEX
19600           PUSH    D               ;PUT INDEX BACK ON
19620           INX     D
19640           INX     D
19660           INX     D
19680           INX     D
19700   NOTDIM: PUSH    D
19720           MOV     M,E             ;PUT LENGTH DOWN
19740           INX     H
19760           MOV     M,D
19780           INX     H
19800           PUSH    H
19820           DAD     D
19840           CALL    REASON          ;MAKE SURE WE'RE NOT RUNNING
19860                                   ;INTO THE STACK
19880           SHLD    STREND          ;SETUP NEW STORAGE END
19900           POP     D
19920   ZERIT2: DCX     H
19940           MVI     M,0
19960           COMPAR
19980           JNZ     ZERIT2
20000           JMP     MAKDFN>         ;FINISH UP
20040   PAGE
20060   SUBTTL  MULTIPLE DIMENSION CODE
20100   IFN     MULDIM,
20120   ;
20140   ; FORMAT OF ARRAYS IN CORE
20160   ;
20180   ; DESCRIPTOR
20200   ;       LOW BYTE = SECOND CHARACTER
20220   ;       HIGH BYTE = FIRST CHARACTER
20240   ; LENGTH OF ARRAY IN CORE IN BYTES (DOES NOT INCLUDE DESCRIPTOR)
20260   ; NUMBER OF DIMENSIONS 1 BYTE
20280   ; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
20300   ; (2 BYTES EACH) OF THE MAX INDICE+1
20320   ; THE VALUES
20340   ;
20360   ISARY:  PUSH    H               ;SAVE DIMFLG AND VALTYP FOR RECURSION
20380           LHLD    DIMFLG
20400           XTHL                    ;TEXT POINTER BACK INTO [H,L]
20420           MVI     D,0             ;SET # DIMENSIONS =0
20440   INDLOP: PUSH    D               ;SAVE NUMBER OF DIMENSIONS
20460           PUSH    B               ;SAVE LOOKS
20480           CALL    INTIDX          ;EVALUATE INDICE INTO [D,E]
20500           POP     B               ;POP OFF THE LOOKS
20520           POP     PSW             ;[A] = NUMBER OF DIMENSIONS SO FAR
20540           XCHG                    ;[D,E]=TEXT POINTER
20560                                   ;[H,L]=INDICE
20580           XTHL                    ;PUT THE INDICE ON THE STACK
20600                                   ;[H,L]=VALTYP & DIMFLG
20620           PUSH    H               ;RESAVE VALTYP AND DIMFLG
20640           XCHG                    ;[H,L]=TEXT POINTER
20660           INR     A               ;INCREMENT # OF DIMENSIONS
20680           MOV     D,A             ;[D]=NUMBER OF DIMENSIONS
20700           MOV     A,M             ;GET TERMINATING CHARACTER
20720           CPI     44              ;A COMMA SO MORE INDICES FOLLOW?
20740           JZ      INDLOP          ;IF SO, READ MORE
20760           SYNCHK  ")"             ;MAKE SURE IT ENDED PROPERLY
20780           SHLD    TEMP2           ;SAVE THE TEXT POINTER
20800           POP     H               ;[H,L]= VALTYP & DIMFLG
20820           SHLD    DIMFLG          ;SAVE VALTYP AND DIMFLG
20840           PUSH    D               ;SAVE NUMBER OF DIMENSIONS
20860   ;
20880   ; AT THIS POINT [B,C]=LOOKS. THE TEXT POINTER IS IN TEMP2.
20900   ; THE INDICES ARE ALL ON THE STACK, FOLLOWED BY THE NUMBER OF DIMENSIONS.
20920   ;
20940           LHLD    ARYTAB          ;[H,L]=PLACE TO START THE SEARCH
20960           XWD     ^O1000,^O76     ;"MVI A," AROUND THE NEXT BYTE
20980   LOPFDA: DAD     D               ;SKIP OVER THIS ARRAY SINCE IT'S
21000                                   ;NOT THE ONE
21020           XCHG                    ;[D,E]=CURRENT SEARCH POINT
21040           LHLD    STREND          ;GET THE PLACE TO STOP INTO [H,L]
21050           XCHG                    ;[H,L]=SEARCH POINT
21060           COMPAR                  ;STOPPING TIME?
21080   IFE     LENGTH-2,<
21100           LDA     VALTYP>
21120           JZ      NOTFDO          ;YES,COULDN'T FIND THIS ARRAY
21140   IFE     LENGTH-2,<
21160           CMP     M               ;SEE IF THE VALTYPS ARE THE SAME
21180           INX     H
21200           JNZ     NMARY2>
21240           MOV     A,M             ;GET FIRST CHARACTER
21260           CMP     C               ;SEE IF IT MATCHES
21280           INX     H
21300           JNZ     NMARY1          ;NOT THIS ONE
21320           MOV     A,M             ;GET SECOND CHARACTER
21340           CMP     B               ;ANOTHER MATCH?
21360   IFE     LENGTH-2,<
21380           XWD     ^O1000,^O76     ;SKIP THIS INCREMENT WITH "MVI A,"
21400   NMARY2: INX     H>
21420   NMARY1: INX     H               ;POINT TO SIZE ENTRY
21440           MOV     E,M             ;[D,E]=LENGTH
21460           INX     H               ;OF THE ARRAY BEING LOOKED AT
21480           MOV     D,M
21500           INX     H
21520           JNZ     LOPFDA          ;IF NO MATCH, SKIP THIS ONE
21540                                   ;AND TRY AGAIN
21560           LDA     DIMFLG          ;SEE IF CALLED BY "DIM"
21580           ORA     A               ;ZERO MEANS NO
21600           MVI     E,ERRDD         ;"DOUBLY DIMENSIONED" ERROR
21620           JNZ     ERROR
21640   ;
21660   ; TEMP2=THE TEXT POINTER
21680   ; WE HAVE LOCATED THE VARIABLE WE WERE LOOKING FOR
21700   ; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
21720   ; THE INDICES ARE ON THE STACK FOLLOWED BY THE NUMBER OF DIMENSIONS
21740   ;
21760           POP     PSW             ;[A]=NUMBER OF DIMENSIONS
21780           CMP     M               ;MAKE SURE THE NUMBER GIVEN NOW AND
21800                                   ;AND WHEN THE ARRAY WAS SET UP ARE THE
21820                                   ;SAME
21840           JZ      GETDEF          ;JUMP OFF AND READ
21860                                   ;THE INDICES...
21880   BSERR:  MVI     E,ERRBS         ;"SUBSCRIPT OUT OF RANGE"
21900           JMP     ERROR
21920   ;
21940   ; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE
21960   ;
21980   ; BUILDING AN ENTRY:
22000   ;
22020   ;       PUT DOWN THE DESCRIPTOR
22040   ;       SETUP NUMER OF DIMENSIONS
22060   ;       MAKE SURE THERE IS ROOM FOR THE NEW ENTRY
22080   ;       REMEMBER VARPTR
22100   ;       TALLY=4 (VALTYP FOR THE EXTENDED)
22120   ;       SKIP 2 LOCS FOR LATER FILL IN -- THE SIZE
22140   ; LOOP: GET AN INDICE
22160   ;       PUT NUMBER +1 DOWN AT VARPTR AND INCREMENT VARPTR
22180   ;       TALLY= TALLY * NUMBER+1
22200   ;       DECREMENT NUMBER-DIMS
22220   ;       JNZ     LOOP
22240   ;       CALL REASON WITH [H,L] REFLECTING LAST LOC OF VARIABLE
22260   ;       UPDATE STREND
22280   ;       ZERO BACKWARDS
22300   ;       MAKE TALLY INCLUDE MAXDIMS
22320   ;       PUT DOWN TALLY
22340   ;       IF CALLED BY DIMENSION, RETURN
22360   ;       OTHERWISE INDEX INTO THE VARIABLE AS IF IT
22380   ;       WERE FOUND ON THE INITIAL SEARCH
22400   ;
22420   NOTFDO:
22440   IFE     LENGTH-2,<
22460           MOV     M,A             ;PUT DOWN THE VARIABLE TYPE
22480           INX     H
22500           MOV     E,A
22520           MVI     D,0>            ;[D,E]-SIZE OF ONE VALUE (VALTYP)
22540   IFN     LENGTH-2,<
22560           LXI     D,$CODE+4>      ;INITIALIZE TALLY TO FOUR
22580           MOV     M,C             ;PUT DOWN THE DESCRIPTOR
22600           INX     H
22620           MOV     M,B
22640           INX     H
22660           POP     PSW             ;[A]=NUMBER OF DIMENSIONS
22680           STA     TEMP6           ;SETUP GETSTR CALL
22700           CALL    GETSTK          ;GET SPACE FOR DIMENSION ENTRIES
22720   TEMP6:  PCHL                    ;PLACE TO STORE NUMBER OF DIMENSIONS
22740                                   ;FOR GETSTK AND LATER RECALL
22760                                   ;!!IMPURE!! PCHL TO CONFUSE DISASSEMBLY
22780           SHLD    TEMP3           ;SAVE THE LOCATION TO PUT THE SIZE
22800                                   ;IN
22820           INX     H               ;SKIP OVER THE SIZE LOCATIONS
22840           INX     H
23860           MOV     B,C             ;[B]=NUMBER OF DIMENSIONS
23880                                   ;THIS DEPENDS ON THE FACT THAT GETSTR
23900                                   ;RETURNS ITS ARGUMENT IN [C]
23920           MOV     M,B             ;STORE THE NUMBER OF DIMENSIONS
23940           INX     H
23960   LOPPTA: LDA     DIMFLG          ;CALLED BY DIMENSION?
23980           ORA     A
23000           MOV     A,B             ;[A]=NUMBER OF DIMENSIONS
23020           LXI     B,$CODE+11      ;[ASSUME ITS NOT "DIM"
23040           JZ      NOTDIM          ;DEFAULT DIMENSIONS TO TEN
23060           POP     B               ;POP OFF AN INDICE INTO [B,C]
23080           INX     B               ;ADD ONE TO IT FOR THE ZERO ENTRY
23100   NOTDIM: MOV     M,C             ;PUT THE MAXIMUM DOWN
23120           INX     H
23140           MOV     M,B
23160           INX     H
23180           PUSH    PSW             ;SAVE THE NUMBER OF DIMENSIONS
23200           PUSH    H               ;SAVE THE POINTERS INTO THE NEW ENTRY
23220           CALL    UMULT           ;MULTIPLY [B,C]=NEWMAX BY CURTOL=[D,E]
23240           XCHG                    ;[D,E]=NEW CURTOL
23260           POP     H               ;GET THE POINTER INTO ENTRY BACK
23280           POP     B               ;GET THE NUMBER OF DIMENSIONS BACK
23300           DCR     B               ;DECREMENT THE NUMBER OF DIMENSIONS LEFT
23320           JNZ     LOPPTA          ;HANDLE THE OTHER INDICES
23340           MOV     B,D             ;[B,C]=SIZE
23360           MOV     C,E
23380           XCHG                    ;[D,E]=START OF VALUES
23400           DAD     D               ;[H,L]=END OF VALUES
23420           JC      BSERR           ;OUT OF MEMORY POINTER BEING GENERATED?
23440           CALL    REASON          ;SEE IF THERE IS ROOM FOR THE VALUES
23460           SHLD    STREND          ;UPDATE THE END OF STORAGE
23480   ZERITA: DCX     H               ;ZERO THE NEW ARRAY
23500           MVI     M,0
23520           COMPAR                  ;BACK AT THE BEGINNING?
23540           JNZ     ZERITA          ;NO,ZERO MORE
23560           INX     B               ;ADD ONE TO THE SIZE TO INCLUDE
23580                                   ;THE BYTE FOR THE NUMBER OF DIMENSIONS
23600           MOV     H,A             ;[H]=ZERO
23620           LDA     DIMFLG
23640           ORA     A               ;ARE WE DIMENSIONING ?
23660           LDA     TEMP6           ;GET THE NUMBER OF DIMENSIONS
23680           MOV     L,A             ;[L]=NUMBER OF DIMENSIONS
23700           DAD     H               ;[H,L]=NUMBER OF DIMENSIONS TIMES TWO
23720           DAD     B               ;ADD ON THE SIZE
23740                                   ;TO GET THE TOTAL NUMBER OF BYTES USED
23760           XCHG                    ;[D,E]=TOTAL SIZE
23780           LHLD    TEMP3           ;PLACE TO STORE SIZE
23800           MOV     M,E             ;PUT DOWN THE SIZE
23820           INX     H
23840           MOV     M,D
23860           INX     H
23880           JNZ     FINNOW
23900   ;
23920   ; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
23940   ; STRATEGY:
23960   ;       NUMDIM=NUMBER OF DIMENSIONS
23980   ;       CURTOL=0
24000   ; INLPNM:GET A NEW INDICE
24020   ;       POP NEW MAX INTO CURMAX
24040   ;       MAKE SURE INDICE IS NOT TOO BIG
24060   ;       MULTIPLY CURTOL BY CURMAX
24080   ;       ADD INDICE TO CURTOL
24100   ;       NUMDIM=NUMDIM-1
24120   ;       JNZ     INLPNM
24140   ;       USE CURTOL*4 (VALTYP FOR EXTENDED) AS OFFSET
24160   ;
24180   GETDEF: INX     H               ;POINT PAST THE NUMBER OF DIMENSIONS
24200           LXI     B,$CODE         ;CURTOL=ZERO
24220           XWD     ^O1000,^O26     ;"MVI D," AROUND THE NEXT BYTE
24240   INLPNM: POP     H               ;[H,L]= POINTER INTO VARIABLE ENTRY
24260           MOV     E,M             ;[D,E]=MAXIMUM FOR THE CURRENT INDICE
24280           INX     H
24300           MOV     D,M
24320           INX     H
24340           XTHL                    ;[H,L]=CURRENT INDICE
24360                                   ;POINTER INTO THE VARIABLE GOES ON THE STACK
24380           PUSH    PSW             ;SAVE THE NUMBER OF DIMENSIONS
24400           COMPAR                  ;SEE IF THE CURRENT INDICE IS TOO BIG
24420           JNC     BSERR           ;IF SO "BAD SUBSCRIPT" ERROR
24440           PUSH    H               ;SAVE THE CURRENT INDICE
24460           CALL    UMULT           ;CURTOL=CURTOL*CURRENT MAXIMUM
24480           POP     D               ;INDICE INTO [D,C]
24500           DAD     D               ;ADD THE INDICETO CURTOL
24520           POP     PSW             ;GET THE NUMBER OF DIMENSIONS IN [A]
24540           DCR     A               ;SEE IF ALL THE INDICES HAVE BEEN PROCESSED
24560           MOV     B,H             ;[B,C]=CURTOL IN CASE WE LOOP BACK
24580           MOV     C,L
24600           JNZ     INLPNM          ;PROCESS THE REST OF THE INDICES
24620   IFE     LENGTH-2,<
24640           LDA     VALTYP          ;SEE HOW BIG THE VALUES ARE
24660                                   ;AND MULTIPLY BY THAT SIZE
24680           MOV     B,H             ;SAVE THE ORIGINAL VALUE FOR MULTIPLYING
24700           MOV     C,L             ;BY THREE
24720           DAD     H               ;MULTIPLY BY TWO AT LEAST
24740           SUI     4               ;FOR INTEGERS AND STRINGS
24760                                   ;NO MORE MULTIPLYING BY TWO
24760           JC      SMLVAL
24800           DAD     H               ;NOW MULTIPLIED BY FOUR
24820           JZ      DONMUL          ;IF SINGLE ALL DONE
24840           DAD     H               ;BY EIGHT FOR DOUBLES
24860   SMLVAL: JPO     DONMUL          ;FOR STRINGS
24880           DAD     B               ;ADD IN THE ORIGINAL
24900   DONMUL:>
24920   IFN     LENGTH-2,<
24940           DAD     H               ;MULTIPLY CURTOL BY FOUR
24960           DAD     H>
24980           POP     B               ;POP OFF THE ADDRESS WHERE THE VALUES
25000                                   ;BEGIN
25020           DAD     B               ;ADD IT ONTO CURTOL TO GET THE
25040                                   ;PLACE THE VALUE IS STORED
25060           XCHG                    ;RETURN THE POINTER IN [D,E]
25080   FINNOW: LHLD    TEMP2           ;REGET THE TEXT POINTER
25100           DCX     H               ;REREAD THE TERMINATING CHARACTER
25120           CHRGET
25140           RET>
25180   PAGE
25200   SUBTTL FRE  FUNCTION AND INTEGER TO FLOATING  ROUTINES
25220   IFN     LENGTH,<
25240   FRE:    LHLD    STREND          ;GET END OF VARIABLE AND TEXT SPACE
25260           XCHG                    ;PUT IT IN [D,E] FOR SUBTRACTION
25280           LXI     H,$CODE         ;ZERO [H,L]
25300           DAD     SP              ;PUT THE STACK POINTER IN [H,L]
25320   IFN     STRING,<
25340   IFE     LENGTH-2,<
25360           CALL    GETYPE
25370           JNZ     GIVDBL
25380   IFN     LENGTH-2,<
25400           LDA     VALTYP          ;WAS THE ARGUMENT A STRING?
25420           ORA     A
25440           JZ      GIVDBL>         ;NO, GIVE FREE VARIABLE SPACE
25460           CALL    FREFAC          ;FREE UP ARGUMENT AND SETUP
25480                                   ;TO GIVE FREE STRING SPACE
25500           CALL    GARBA2          ;DO GARBAGE COLLECTION
25520           LHLD    STKTOP          ;BOTTOM OF FREE AREA
25540           XCHG
25560           LHLD    FRETOP>>        ;TOP OF FREE AREA
25580   ;
25600   ; THIS ROUTINE SUBTRACTS [D,E] FROM [H,L]
25620   ; AND FLOATS THE RESULT LEAVING IT IN FAC.
25640   ;
25660   IFE     LENGTH-1,<
25680   GIVDBL: MOV     A,L             ;DO THE SUBTRACTION
25700           SUB     E
25720           MOV     C,A
25740           MOV     A,H
25760           SBB     D
25780   GIVACF: MOV     B,C>
25790   IFN     LENGTH-2,<
25800   GIVABF: MOV     D,B
25820           MVI     E,0             ;GET ZERO IN LOW
25840   IFN     STRING,<
25860           LXI     H,VALTYP        ;FLAG VALUE TYPE AS NUMERIC
25880           MOV     H,E>
25900           MVI     B,144           ;SETUP TO FLOAT [B,C]
25920           JMP     FLOATR>
26120   IFE     LENGTH-2,<
26140   GIVDBL: MOV     A,L             ;[H,L]=[H,L]-[D,E]
26160           SUB     E
26180           MOV     L,A
26200           MOV     A,H
26220           SBB     D
26240           XWD     ^O1000,^O21     ;SKIP THE NEXT TWO BYTES WITH "LXI D,"
26260   SNGFLT: MOV     L,A             ;MAKE [A] AN UNSIGNED INTEGER
26280           XRA     A
26300   GIVINT: MOV     H,A
26320           JMP     MAKINT>
26322   IFN     LENGTH,<
26324   IFN     LPTSW,<
26326   LPOS:   LDA     LPTPOS
26328           JMP     SNGFLT>
26330   POS:    LDA     TTYPOS          ;GET TELETYPE POSITION
26332   IFN     LENGTH-2,<
26334   SNGFLT: MOV     B,A             ;RETURN FLOATING 1 BYTE
26336           XRA     A               ;UNSIGNED FROM A
26338           JMP     GIVABF>>        ;GIVING 0-255
26360   PAGE
26380   SUBTTL  SIMPLE-USER-DEFINED-FUNCTION CODE
26390   IFN     FUNCTS,
26400   ;
26420   ; NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
26440   ; AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
26460   ; DEF FNA(X)=X^2+X-2
26480   ; NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS
26520   ; IDEA: CREATE A FUNNY SIMPLE VARIABLE ENTRY
26540   ; WHOSE FIRST CHARACTER (SECOND WORD IN MEMORY)
26560   ; HAS THE 200 BIT SET.
26580   ; THE VALUE WILL BE:
26600   ;
26620   ;       A TXTPTR TO THE FORMULA
26640   ;       A PTR TO THE ARGUMENT VARIABLE
26660   ;
26680   ; FUNCTION NAMES CAN BE LIKE "FNA4"
26700   ;
26780   DEF:    CALL    GETFNM          ;GET A POINTER TO THE
26800                                   ;FUNCTION VARIABLE
26820           LXI     B,DATA          ;EVENTUALLY RETURN TO "DATA"
26840           PUSH    B               ;AND SKIP THE FORMULA
26860           PUSH    D               ;SAVE A POINTER TO IT
26880           CALL    ERRDIR          ;DEF IS "ILLEGAL DIRECT"
26900           SYNCHK  "("             ;MUST HAVE "("
26920                                   ;SINCE WE STORE A TEXT POINTER
26940           CALL    PTRGET          ;GET POINTER TO ARGUMENT
26960   IFN     LENGTH-2,<
26980   IFN     STRING,<CALL    CHKNUM>>;STRINGS ILLEGAL
27000           SYNCHK  ")"             ;MUST CLOSE IT WITH ")"
27020           SYNCHK  EQULTK          ;MUST HAVE EQUAL
27040           MOV     B,H
27060           MOV     C,L
27080           XTHL                    ;PUT THE TXTPTR ON THE STACK
27100                                   ;[H,L]=PTR TO FUNCTION VARIABLE
27120                                   ;[B,C]=TXTPTR
27140           JMP     DEFFIN          ;PUT DOWN THE TEXT-POINTER
27160                                   ;AND ARUGMENT POINTER IN
27180                                   ;MEMORY, RESTORE THE TXTPTR
27200                                   ;AND GO TO "DATA" SKIPPING THE
27220                                   ;REST OF THE FORMULA
27260   FNDOER: CALL    GETFNM          ;GET A POINTER TO
27280                                   ;THE FUNCTON DEFINITION IN [D,E]
27300           PUSH    D               ;SAVE THE POINTER
27320           CALL    PARKCHK         ;EVALUATE THE VALUE TO BE PASSED
27340   IFN     LENGTH-2,<
27360   IFN     STRING,<CALL    CHKNUM>> ;ARG CANNOT BE STRING
27380           XTHL                    ;[H,L]=POINTER TO FUNCTION DEF
27400                                   ;TEXT POINTER GOES ON THE STACK
27420           PUSHM                   ;PUSH THE POINTER AT THE FORMULA
27440                                   ;ONTO THE STACK
27460           POP     D               ;[D,E]=PTR TO FORMULA
27480           PUSHM                   ;PUT A POINTER TO THE
27500                                   ;ARGUMENT ON THE STACK
27520           POP     H               ;[H,L]=POINTER TO ARG
27540           PUSHFM                  ;SAVE ARGS OLD VALUE ON THE STACK
27560           DCX     H
27580           DCX     H
27600           DCX     H               ;POINT TO FRONT OF ARG AGAIN
27620           DCX     H
27640           PUSH    H               ;SAVE IT
27660           COMPAR                  ;SHOULDN'T BE EQUAL UNLESS
27680                                   ;FUNCTION WAS NEVER DEFINED
27700           PUSH    D               ;SAVE FORMULA TEXT POINTER
27720           MVI     E,ERRUF         ;NOW [D,E] FREE SO CHECK IF (ZERO) SET
27740           JZ      ERROR
27760           CALL    MOVMF           ;PUT CURRENT FAC INTO OUT ARG VARIABLE
27780                                   ;OUT OF FAC INTO [H,L] LOCATION
27800           POP     H               ;POP OFF FORMULA TXTPTR
27810   IFN     LENGTH-2,<
27820           CALL    FRMNUM>         ;EVALUATE IT AND MUST SURE ITS NUMERIC
27822   IFE     LENGTH-2,<
27824           CALL    FRMEVL
27826           PUSH    H
27828           CALL    FRCSNG
27830           POP     H>
27840           DCX     H
27860           CHRGET                  ;SEE IF TERMINATED
27880           JNZ     SNERR           ;IF NOT SYNTAX ERROR
27900                                   ;TO BE NICE SHOULD HAVE NEW CURLIN
27920                                   ;BUT VERY MESSY
27940           POP     H               ;POP OFF POINTER AT ARG VARIABLE
27960           POP     D
27980           POP     B>              ;POP OFF OLD VALUE
28000   IFN     MULDIM!STRING!FUNCTS,<
28020   DEFFIN: MOV     M,C
28040           INX     H               ;STORE THE OLD VALUE
28060           MOV     M,B
28080   PUTDEI: INX     H
28100           MOV     M,E
28120           INX     H
28140           MOV     M,D
28160           POP     H               ;POP OFF OLD TXTPTR
28180           RET>                    ;VALUE IS IN FAC -- ALL DONE
28200   IFN     FUNCTS,<
28220   ;
28240   ; SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE AND
28360   ; COMPLAIN IF SO
28380   ;
28300   ERRDIR: PUSH    H               ;SAVE THEIR [H,L]
28320           LHLD    CURLIN          ;SEE WHAT THE CURRENT LINE IS
28340           INX     H               ;DIRECT IS 65,535 SO NOW 0
28360           MOV     A,H
28380           ORA     L               ;IS IT ZERO NOW?
28400           POP     H
28420           RNZ                     ;RETURN IF NOT
28440           MVI     E,ERRID         ;"ILLEGAL DIRECT" ERROR
28460           JMP     ERROR
28480   ;
28500   ; SUBROUTINE TO GET A POINTER TO A FUNCTION NAME
28520   ;
28540   GETFNM: SYNCHK  FNTK            ;MUST START WITH "FN"
28560           MVI     A,128           ;DONT ALLOW AN ARRAY
28580           STA     SUBFLG          ;DON'T RECOGNIZE THE "(" AS
28600                                   ;THE START OF AN ARRAY REFERENCE
28620           ORA     M               ;PUT FUNCTION BIT ON
28640           MOV     B,A             ;GET FIRST CHARACTER INTO [B]
28660   IFN     LENGTH-2,<
28680   IFN     STRING,<CALL    PTRGT2  ;REALLY GET THE POINTER
28700           JMP     CHKNUM>>        ;MAKE SURE ITS NOT A STRING NAME
28720   IFE     STRING&<LENGTH-2>,<JMP  PTRGT2>>
28740   PAGE
28760   SUBTTL  STRING FUNCTIONS
28780   IFN     STRING,<                ;STRING HANDLING SUBROUTINES
28800   ;
28820   ; THE STR$ FUNCTION TAKES A NUMBER AND GIVES
28840   ; A STRING WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
28860   ; WOULD HAVE GIVEN
28880   ;
28900   STR$:
28920   IFN     LENGTH-2,<
28940           CALL    CHKNUM>         ;MAKE SURE THE ARGUMENT
28960                                   ;IS A NUMERIC
28980           CALL    FOUT            ;DO ITS OUTPUT
29000           CALL    STRLIT          ;SCAN IT AND TURN IT INTO A STRING
29020           CALL    FREFAC          ;FREE UP THE TEMP
29040           LXI     B,FINBCK
29060           PUSH    B               ;SET UP ANSWER IN NEW TEMP
29080   ;
29100   ; STRCPY CREATES A COPY OF THE STRING
29120   ; WHOSE DESCRIPTOR IS POINTED TO BY [H,L].
29140   ; ON RETURN [D,E] POINTS TO DSCTMP
29160   ; WHICH HAS THE STRING INFO (LENGTH,WHERE COPIED TO)
29180   ;
29200   STRCPY: MOV     A,M             ;GET LENGTH
29220           INX     H               ;MOVE UP TO THE POINTER
29240   IFN     LENGTH-2,<
29260           INX     H>
29280           PUSH    H               ;GET POINTER TO POINTER OF ARG
29300           CALL    GETSPA          ;GET THE SPACE
29320           POP     H               ;FIND OUT WHERE STRING TO COPY
29340           PUSHM                   ;REALLY IS IN [B,C]
29360           POP     B
29380           CALL    STRAD2          ;SETUP DSCTMP
29400           PUSH    H               ;SAVE POINTER TO DSCTMP
29420           MOV     L,A             ;GET CHARACTER COUNT INTO [L]
29440           CALL    MOVSTR          ;MOVE THE CHARS IN
29460           POP     D               ;RESTORE POINTER TO DSCTMP
29480           RET                     ;RETURN
29520   STRINI: CALL    GETSPA          ;GET SOME STRING SPACE ([A] CHARS)
29540   STRAD2: LXI     H,DSCTMP        ;GET DESC. TEMP
29560   STRAD1: PUSH    H               ;SAVE DESC. POINTER
29580           MOV     M,A             ;SAVE CHARACTER COUNT
29600   IFN     LENGTH-2,<
29620           INX     H>              ;MOVE TO ADDRESS FIELD
29640           JMP     PUTDEI          ;USE COMMON CODE TO
29660                                   ;STORE [D,E]=POINTER TO FREE SPACE
29680                                   ;AND RESTORE [H,L] AS THE DESCRIPTOR POINTER
29682   ;
29684   ; STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
29686   ; IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.
29688   ; THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW
29690   ; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
29692   ; AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN
29694   ; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN [B]
29696   ; AND [D]. IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
29697   ; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN
29698   ; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
29700   ; BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE
29702   ; NOT SET UP.
29704   ;
29720   STRLIT: DCX     H
29740   STRLTI: MVI     B,34            ;ASSUME STR ENDS ON QUOTE
29760   STRLT3: MOV     D,B
29780   STRLT2: PUSH    H               ;SAVE POINTER TO START OF LITERAL
29800           MVI     C,255           ;INITIALIZE CHARACTER COUNT
29820   STRGET: INX     H
29840           MOV     A,M             ;GET CHAR
29860           INR     C               ;BUMP CHARACTER COUNT
29880           ORA     A               ;IF 0, (END OF LINE) DONE
29900           JZ      STRFIN          ;TEST
29920           CMP     D
29940           JZ      STRFIN
29960           CMP     0               ;CLOSING QUOTE
29980           JNZ     STRGET          ;NO, GO BACK FOR MORE
30000   STRFIN: CPI     34              ;IF QUOTE TERMINATES THE STRING
30020           CZ      CHRGTR          ;SKIP OVER THE QUOTE
30040           XTHL
30060           INX     H
30080           XCHG                    ;GET POINTER TO TEMP
30100           MOV     A,C             ;GET CHARACTER COUNT IN A
30120           CALL    STRAD2          ;SAVE STR INFO
30140                                   ;COMPARE DESC. POINTER & STR POINTER
30160           COMPAR                  ;TO SEE IF STR IN BUF
30180           CNC     STRCPY          ;IF IN BUF, MUST COPY IT.
30200                                   ;OTHERWISE STR IN PROGRAM.
30220   ;
30240   ; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP
30260   ; WE WANT TO SETUP A TEMP DESCRIPTOR WITH DSCTMP IN IT
30280   ; PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE
30300   ; RESULT AS TYPE STRING
30320   ;
30340   PUTNEW: LXI     D,DSCTMP        ;[D,E] POINT AT RESULT DESCRIPTOR
30360           LHLD    TEMPPT          ;[H,L]=POINTER TO FIRST FREE TEMP
30380           SHLD    FACLO           ;POINTER AT WHERE RESULT DESCRIPTOR WILL BE
30400   IFE     LENGTH-2,<
30420           MVI     A,3
30440           STA     VALTYP          ;FLAG THIS AS A STRING
30460           CALL    VMOVE>          ;AND MOVE THE VALUE INTO A TEMPORARY
30480   IFN     LENGTH-2,<
30500           MVI     A,1             ;FLAG RESULT AS STRING
30520           STA     VALTYP          ;STORE IN "VALUE-TYPE" LOCATION
30540           CALL    MOVE>           ;TRANSFER THE DESCRIPTOR IN
30560           COMPAR                  ;DSCTMP IS JUST BEYOND THE TEMPS
30580                                   ;AND IF TEMPPT POINTS AT IT THERE
30600                                   ;ARE NO FREE TEMPS
30620           MVI     E,ERRST         ;"STRING TEMPORARY" ERROR
30640           JZ      ERROR           ;GO TELL HIM
30660           SHLD     TEMPPT         ;SAVE NEW TEMPORARY POINTER
30680           POP     H               ;GET THE TEXT POINTER
30700           MOV     A,M             ;GET CURRENT CHARACTER INTO [A]
30720           RET
30740   ;
30760   ; PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO
30780   ; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE
30800   ;
30820   STROUI: INX     H               ;POINT AT NEXT CHARACTER
30840   STROUT: CALL    STRLIT          ;GET A STRING LITERAL
30860   ;
30880   ; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO
30900   ;
30920   STRPRT: CALL    FREFAC          ;RETURN TEMP POINTER BY FACLO
30940   IFE     LENGTH-2,<
30960           CALL    GETBCD          ;[D]=LENGTH [B,C]=POINTER AT DATA
30970           INR     D               ;INCREMENT AND DECREMENT EARLY
30980                                   ;TO CHECK FOR NULL STRING
30990   STRPR2: DCR     D>              ;DECREMENT THE LENGTH
31060   IFN     LENGTH-2,<
31080           CALL    MOVRM           ;GET LENGTH IN [E]
31100           INR     E               ;AND POINTER TO CHARACTERS IN [B,C]
31120   STRPR2: DCR     E>
31140           RZ                      ;ALL DONE
31160           LDAX    B               ;GET CHARACTER TO PRINT
31180           OUTCHR
31200           CPI     CR
31220           CZ      CRFIN
31240           INX     B               ;POINT TO THE NEXT CHARACTER
31260           JMP     STRPR2          ;AND PRINT IT...
31280   ;
31300   ; GETSPA - GET SPACE FOR CHARACTER STRING
31320   ; MAY FORCE GARBAGE COLLECTION.
31340   ;
31360   ; # OF CHARS (BYTES) IN [A]
31380   ; RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE
31400   ; BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
31420   ;
31440   GETSPA: ORA     A               ;MUST BE NON ZERO. SIGNAL NO GARBAG YET
31460           XWD     ^O1000,^O016    ;"MVI C" AROUND THE NEXT
31480   TRYGI2: POP     PSW             ;IN CASE COLLECTED WHAT WAS LENGTH?
31500           PUSH    PSW             ;SAVE IT BACK
31520           LHLD    STKTOP          ;GET BOTTOM OF STRING SPACE
31540           XCHG                    ;IN [D,E]
31560           LHLD    FRETOP          ;GET TOP OF FREE SPACE IN [H,L]
31580           CMA                     ;-# OF CHARS
31600           MOV     C,A             ;IN [B,C]
31620           MVI     B,255
31640           DAD     B               ;SUBTRACT FROM TOP OF FREE
31660           INX     H
31680           COMPAR                  ;COMPARE THE TWO
31700           JC      GARBAG          ;NOT ENOUGH ROOM FOR STRING, OFFAL TIME
31720           SHLD    FRETOP          ;SAVE NEW BOTTOM OF MEMORY
31740           INX     H               ;MOVE BACK TO POINT TO STRING
31760           XCHG                    ;RETURN WITH POINTER IN [D,E]
31780   PPSWRT: POP     PSW             ;GET CHARACTER COUNT
31800           RET                     ;RETURN FROM GETSPA
31840   GARBAG: POP     PSW             ;HAVE WE COLLECTED BEFORE?
32860           MVI     E,ERRSO         ;GET READY FOR OUT OF STRING SPACE ERROR
32880           JZ      ERROR           ;GO TELL USER HE LOST
32900           CMP     A               ;SET ZERO FLAG TO SAY WEVE GARBAGED
32920           PUSH    PSW             ;SAVE FLAG BACK ON STACK
32940           LXI     B,TRYGI2        ;PLACE FOR GARBAG TO RETURN TO.
32960           PUSH    B               ;SAVE ON STACK
32980   GARBA2: LHLD    MEMSIZ          ;START FROM TOP DOWN
32000   IFE     REALIO,<
32020           MVI     A,7             ;RING THE BELL ON GARBAGE COLLECTION
32040           OUTCHR>
32060   FNDVAR: SHLD    FRETOP          ;LIKE SO
32080           LXI     H,$CODE         ;GET DOUBLE ZERO
32100           PUSH    H               ;SAY DIDNT SEE VARS THIS PASS
32120           LHLD    STKTOP          ;FORCE DVARS TO IGNORE STRINGS
32140                                   ;IN THE PROGRAM TEXT (LITERALS, DATA)
32160           PUSH    H               ;FORCE FIND HIGH ADDRESS
32180           LXI     H,TEMPST        ;GET START OF STRING TEMPS
32200   TVAR:   XCHG                    ;ASVE IN [D,E]
32220           LHLD    TEMPPT          ;SEE IF DONE
32240           XCHG                    ;FLIP
32260           COMPAR                  ;TEST
32280           LXI     B,TVAR          ;FORCE JUMP TO TVAR
32300           JNZ     DVAR2           ;DO TEMP VAR GARBAGE COLLECT
32340   SVARS:  LHLD    VARTAB          LGET START OF SIMPLE VARIABLES
32360   SVAR:   XCHG                    ;GET IN [D,E]
32380           LHLD    ARYTAB          ;GET END OF SIMPS
32400           XCHG                    ;FLIP
32420           COMPAR                  ;SEE IF AT END OF SIMPS
32440           JZ      ARYTAB          ;IF YES, DO ARRAY TYPE STRINGS
32460           MOV     A,M             ;GET 2ND CHARACTER OF VARIABLE
32480           INX     H               ;BUMP POINTER TWICE
32500           INX     H               ;
32520   IFE     LENGTH-2,<
32540           INX     H               ;POINT AT THE VALUE
32560           CPI     3               ;SEE IF ITS A STRING
32580           JNZ     SKPVAR          ;IF NOT, JUST SKIP AROUND IT
32600           CALL    DVARS           ;COLLECT IT
32620           XRA     A               ;AND DON'T SKIP ANYTHING MORE
32640   SKPVAR: MOV     E,A
32660           MVI     D,0             ;[D,E]=AMOUNT TO SKIP
32680           DAD     D>
32700   IFN     LENGTH-2,<
32720           ORA     A               ;SET CC'S
32740           CALL    DVARS>          ;CALL THE VARIABLE GARB ROUT.
32760           JMP     SVAR            ;GET NEXT ONE
32800   ARYVA2: POP     B               ;GET RID OF STACK GARBAGE
32820   ARYVAR: XCHG                    ;SAVE ARYVAR IN [D,E]
32840           LHLD    STREND          ;GET END OF ARRAYS
32860           XCHG                    ;FLIP BACK
32880           COMPAR                  ;SEE IF DONE WITH ARRAYS
32900           JZ      GRBPAS          ;YES, SEE IF DONE COLLECTING
32920   IFE     LENGTH-2,<
32940           MOV     A,M             ;GET THE VALUE TYPE INTO [A]
32960           INX     H>
32980           CALL    MOVRM           ;GET LENGTH OF ARRAY IN [B,C]
33000   IFN     LENGTH-2,<
33020           MOV     A,E>            ;GET 2ND CHAR OF VAR NAME IN A
33040           PUSH    H               ;SAVE POINTER TO DIMS
33060           DAD     B               ;ADD TO CURRENT POINTER POSITION
33080   IFE     LENGTH-2,<
33100           CPI     3               ;SEE IF ITS A STRING
33120           JNZ     ARYVA2>         ;IF NOT JUST SKIP IT
33140   IFN     LENGTH-2,<
33160           ORA     A               ;SEE IF STRING VAR
33180           JP      ARYVA2>         ;NO, KEEP ON TRUCKIN
33200           SHLD    TEMP3           ;SAVE END OF ARRAY
33220           POP     H               ;GET BACK CURRENT POSITION
33240           MOV     C,M             ;PICK UP NUMBER OF DIMS
33260           MVI     B,0             ;MAKE DOUBLE WITH HIGH ZERO
33280           DAD     B               ;GO PAST DIMS
33300           DAD     B               ;BY ADDING ON TWICE #DIMS (2 BYTE GUYS)
33320           INX     H               ;ONE MORE TO ACCOUNT FOR #DIMS.
33340   ARYSTR: XCHG                    ;SAVE CURRENT POSIT IN [D,E]
33360           LHLD    TEMP3           ;GET END OF ARRAY
33380           XCHG                    ;FIX [H,L] BACK TO CURRENT
33400           COMPAR                  ;SEE IF AT END OF ARRAY
33420           JZ      ARYVAR          ;END OF ARRAY, TRY NEXT ARRAY
33440           LXI     B,ARYSTR        ;ADDR OF WHERE TO RETURN TO
33460   DVAR2:  PUSH    B               ;GOES ON STACK
33480   IFE     LENGTH-2,<
33500   DVAR:
33520   DVARS:  XRA     A
33540           ORA     H               ;SEE IF ITS THE NULL STRING
33560           INX     H
33580           MOV     E,M
33600           INX     H
33620           MOV     D,M
33640           INX     H>              ;[D,E]=POINTER AT THE VALUE
33660   IFN     LENGTH-2,<
33680   DVAR:   ORI     128             ;FORCE DVAR TO CALL GRBVAR
33700   DVARS:  PUSHM                   ;SAVE LENGTH
33720           PUSHM                   ;SKIP NEXT TWO BYTES
33740           POP     D               ;GET POINTER IN [D,E]
33760           POP     B               ;POP OF STRING LENGTH
33780           RP                      ;IF WASNT A STR, RETURN
33800           MOVE    A,C             ;GET LENGTH OF STRING
33820           ORA     A>              ;SET CONDITION CODES
33840           RZ                      ;NULL STRING, RETURN
33860           MOV     B,H             ;MOVE [H,L] TO [B,C]
33880           MOV     C,L
33900           LHLD    FRETOP          ;GET POINTER TO TOP OF STRING FREE SPACE
33920           COMPAR                  ;IS THIS STRINGS POINTER .LT. FRETOP
33940           MOV     H,B             ;MOVE [B,C] BACK TO [H,L]
33960           MOV     L,C
33980           RC                      ;IF NOT, NO NEED TO MESS WITH IT FURTHUR
34000           POP     H               ;GET RETURN ADDRESS OFF STACK
34020           XTHL                    ;GET MAX SEEN SO FAR & SAVE RETURN ADDRESS
34040           COMPAR                  ;LETS SEE
34060           XTHL                    ;SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK
34080           PUSH    H               ;SAVE RETURN ADDRESS BACK
34100           MOV     H,B             ;MOVE [B,C] BACK TO [H,L]
34120           MOV     L,C
34140           RNC                     ;IF NOT, LETS LOOK AT NEXT VAR
34160           POP     B               ;GET RETURN ADDR OFF STACK
34180           POP     PSW             ;POP OFF MAX SEEN
34200           POP     PSW             ;AND VARIABLE POINTER
34220           PUSH    H               ;SAVE NEW VARIABLE POINTER
34240           PUSH    D               ;AND NEW MAX POINTER
34260           PUSH    B               ;SAVE RETURN ADDRESS BACK
34280           RET                     ;AND RETURN
34300   ;
34320   ; HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS
34340   ;
34360   GRBPAS: POP     D               ;POP OFF MAX POINTER
34380           POP     H               ;AND GET VARIABLE POINTER
34400           MOV     A,L             ;GET LOW IN
34420           ORA     H               ;SEE IF ZERO POINTER
34440           RZ                      ;IF END OF COLLECTION,
34460                                   ;THEN MAYBE RETURN TO GETSPA
34480           DCX     H               ;CURRENTLY JUST PAST THE DESCRIPTOR
34500           MOV     B,M             ;[B]=HIGH BYTE OF DATA POINTER
34520           DCX     H
34540           MOV     C,M             ;[B,C]=POINTER AT STRING DATA
34550           PUSH    H               ;SAVE THIS LOCATION SO THE POINTER
34552                                   ;CAN BE UPDATED AFTER THE STRING IS
34554                                   ;MOVED
34560           DCX     H
34580   IFN     LENFTH-2,<
34600           DCX     H>
34620           MOV     L,M             ;[L]=STRING LENGTH
34640           MVI     H,0             ;[H,L] GET CHARACTER COUNT
34660           DAD     B               ;[H,L]=POINTER BEYOND STRING
34680           MOV     D,0
34700           MOV     E,C             ;[D,E]=ORIGINAL POINTER
34720           DCX     H               ;DON'T MOVE ONE BEYOND STRING
34740           MOV     B,H             ;GET TOP OF STRING IN [B,C]
34760           MOV     C,L
34780           LHLD    FRETOP          ;GET TOP OF FREE SPACE
34800           CALL    BLTUC           ;MOVE STRING
34820           POP     H               ;GET BACK POINTER TO DESC.
34840           MOV     M,C             ;SAVE FIXED ADDR
34860           INX     H               ;MOVE POINTER
34880           MOV     M,B             ;HIGH PART
34900           MOV     L,C
35920           MOV     H,B             ;[H,L]=NEW POINTER
35940           DCX     H               ;FIX UP FRETOP
35960           JMP     FNDVAR          ;AND TRY TO FIND HIGH AGAIN
35000   ;
35020   ; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS
35040   ; THE FACLO CONTAINS THE FIRST ONE AT THIS POINT.
35060   ; [H,L] POINTS BEYOND THE + SIGN AFTER IT
35080   ;
35100   CAT:    PUSH    B               ;PUT OLD PRECEDENCE BACK ON
35120           PUSH    H               ;SAVE TEXT POINTER
35140           LHLD    FACLO           ;GET POINTER TO STRING DESC.
35160           XTHL                    ;SAVE ON STACK & GET TEXT POINTER BACK
35180           CALL    EVAL            ;EVALUATE REST OF FORMULA
35200           XTHL                    ;SAVE TEXT POINTER, GET BACK DESC.
35220           CALL    CHKSTR
35240           MOV     A,H
35260           PUSH    H               ;SAVE DESC. POINTER.
35280           LHLD    FACLO           ;GET POINTER TO 2ND DESC.
35300           PUSH    H               ;SAVE IT
35320           ADD     M               ;ADD TWO LENGTHS TOGETHER
35340           MVI     E,ERRLS         ;SEE IF RESULT .LT. 256
35360           JC      ERROR           ;ERROR "LONG STRING"
35380           CALL    STRINI          ;GET INITIAL STRING
35400           POP     D               ;GET 2ND DESC.
35420           CALL    FRETMP
35440           XTHL                    ;SAVE POINTER TO IT
35460           CALL    FRETM2          ;FREE UP 1ST TEMP
35480           PUSH    H               ;SAVE DESC. POINTER (FIRST)
35500           LHLD    DSCTMP+2        ;GET POINTER TO FIRST
35520           XCHG                    ;IN [D,E]
35540           CALL    MOVINS          ;MOVE IN THE FIRST STRING
35560           CALL    MOVINS          ;AND THE SECOND
35580           LXI     H,TSTOP         ;CAT REENTERS FORMULA EVALUATION AT TSTOP
35600           XTHL
36620           PUSH    H               ;TEXT POINTER OFF FIRST
36640           JMP     PUTNEW          ;THEN RETURN ADDRESS OF TSTOP
35700   MOVINS: POP     H               ;GET RETURN ADDR
35720           XTHL                    ;PUT BACK, BUT GET DESC.
35740   IFE     LENGTH-2,<
35760           MOV     A,M             ;[A]=STRING LENGTH
35780           INX     H
35800           MOV     C,M             ;[B,C]=POINTER AT STRING DATA
35820           INX     H
35840           MOV     B,M
35860           MOV     L,A>            ;[L]=STRING LENGTH
35880   IFN     LENGTH-2,<
35900           PUSHM                   ;GET LENGTH ON STACK
35920           PUSHM                   ;AND POINTER
35940           POP     B               ;TEXT POINTER HERE
35960           POP     H>              ;CHARACTER COUNT HERE
35980   MOVSTR: INR     L
36000   MOVLP:  DCR     L               ;SET CC'S
36020           RZ                      ;0 NO BYTE TO MOVE
36040           LDAX    B               ;GET CHAR
36060           STAX    D               ;SAVE IT
36080           INX     B               ;MOVE POINTERS
36100           INX     D
36120           JMP     MOVLP           ;KEEP DOING IT
36140   ;
36160   ; FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]
36180   ; THIS VALUE IS RETURNED IN [H,L]. ALL THE OTHER REGISTERS ARE MODIFIED.
36200   ; A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS
36220   ; TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
36240   ; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.
36260   ; IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE
36280   ; STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE
36300   ; LOWEST PART OF THE STRING SPACE IN USE.
36320   ; IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO
36340   ; LONGER IS USE. THIS CAUSES DIFFICULTY FOR ASSIGNMENT ("LET") BECAUSE
36360   ; THOUGH A TEMPORARY IS BEING FREED UP, NAMELY THE VALUE TO THE RIGHT
36380   ; OF THE EQUAL SIGN IN THE "LET", THE ACTUAL DATA
36400   ; IS STILL ACTIVE DATA SINCE A VARIABLE IS BEING SET UP TO POINT
36420   ; AT IT. "LET" FOOLS FRETMP BY SETTING THE LENGTH OF THE
36440   ; TEMPORARY TO ZERO TEMPORARILY.
36460   ;
36480   FRESTR: CALL    CHKSTR          ;MAKE SURE ITS A STRING
36500   FREFAC: LHLD    FACLO
36520   FRETM2: XCHG                    ;FREE UP THE TEMP IN THE FACLO
36540   FRETMP: LHLD    TEMPPT          ;GET TEMP POINTER
36560           DCX     H               ;LOOK AT WHAT IS IN THE LAST TEMP
36580           MOV     B,M             ;[B,C]=POINTER AT STRING
36600           DCX     H               ;DECREMENT TEMPPT BY STRSIZ
36620           MOV     C,M
36640           DCX     H
36660   IFN     LENGTH-2,<
36680           DCX     H>
36700           COMPAR                  ;SEE IF [D,E] POINT AT THE LAST
36720           XCHG                    ;RETURN WITH [H,L]
36740                                   ;POINTING AT CURRENT DESCRIPTOR
36760           RNZ                     ;RETURN NOW IF NOW FREEING DONE
36780           SHLD    TEMPPT          ;UPDATE THE TEMP POINTER SINCE
36800                                   ;ITS BEEN DECREMENTED BY 4
36820           PUSH    D               ;SAVE [D,E] TO RETURN IN [H,L]
36840           MOV     D,B             ;[D,E]=POINTER AT STRING
36860           MOV     E,C
36880           DCX     D               ;SUBTRACT ONE
36900           MOV     C,M             ;[C]=LENGTH OF THE STRING FREED UP
36920           LHLD    FRETOP          ;SEE IF ITS THE FIRST
36940                                   ;ONE IN STRING SPACE
36960           COMPAR
36980           JNZ     NOTLST          ;NO SO DON'T ADD
37000           MOV     B,A             ;MAKE [B]=0
37020           DAD     B               ;ADD
37040           SHLD    FRETOP          ;AND UPDATE FRETOP
37060   NOTLST: POP     H               ;GET POINTER AT CURRENT DESCRIPTOR
37080           RET
37100   ;
37120   ; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE
37140   ; STRING PASSED AS AN ARGUMENT
37160   ;
37180   LEN:    LXI     B,SNGFLT        ;CALL SNGFLT WHEN DONE
37200           PUSH    B               ;LIKE SO
37220   LEN1:   CALL    FRESTR          ;FREE UP TEMP POINTED TO BY FACLO
37240           XRA     A               ;FORCE NUMERIC FLAG
37260           MOV     D,A             ;SET HIGH OF [D,E] TO ZERO FOR VAL
37280   IFN     LENGTH-2,<
37300           STA     VALTYP>
37320           MOV     A,M
37340           ORA     A               ;SET CONDITION CODES ON LENGTH
37360           RET                     ;RETURN
37380   ;
37400   ; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS AN INTEGER
37420   ; WHICH IS THE DECIMAL ASCII EQUIVALENT
37440   ;
37460   ASC:    CALL    LEN1            ;SET UP ORIGINAL STR
37480           JNZ     FCERR           ;NULL STR, BAD ARD.
37500           INX     H               ;BUMP POINTER
37520   IFN     LENGTH-2,<
37540           INX     H>              ;BUMP POINTER
37560           PUSHM                   ;GET ADDRESS
37580           POP     H               ;GET ADDR IN [H,L]
37600           MOV     A,M             ;GET FIRST CHAR
37620           JMP     SNGFLT          ;SNGFLT IT
37640   ;
37660   ; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
37680   ; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARG (#)
37700   ; WHICH MUCH BE .LT. 255.
37720   ;
37740   CHR$:   MVI     A,1             ;ONE CHARACTER STR
37760           CALL    STRINI          ;GET STRING IN DSCTMP
37780           CALL    CONINT          ;GET INTEGER IN RANGE
37800           LHLD    DSCTMP+2        ;GET ADDR OF STR
37820           MOV     M,E             ;SAVE ASCII BYTE
37840   FINBCK: POP     B               ;RETURN TO HIGHER LEVEL &
37860                                   ;SKIP THE CHKNUM CALL.
37880           JMP     PUTNEW          ;GO CALL PUTNEW
37900   ;
37920   ; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
37940   ; IT TAKES THE LEFTMOST # CHARS OF THE STR.
37960   ; IF # IS .GR. THAN THE LEN OF THE STR, IT REURNS THE WHOLE STR.
37980   ;
38000   LEFT$:  CALL    PREAM           ;TEST THE PARAMETERS
38020           XRA     A               ;LEFT NEVER CHANGES STRING POINTER
38040   LEFT3:  XTHL                    ;SAVE THE TEXT POINTER
38060           MOV     C,A             ;OFFSET NOW IN [C]
38080   LEFT2:  PUSH    H               ;SAVE DESC. FOR  FRETMP
38100           MOV     A,H             ;GET STRING LENGTH
38120           CMP     B               ;ENTIRE STRING WANTED?
38140           JC      ALLSTR          ;IF #CHARS ASKED FOR.GE.LENGTH.YES
38160           MOV     A,B             ;GET TRUNCATED LENGTH OF STRING
38180           XWD     ^O1000,^O21     ;SKIP OVER MVI USING "LXI D,"
38200   ALLSTR: MVI     C,0             ;MAKE OFFSET ZERO
38220           PUSH    B               ;SAVE OFFSET ON STACK
38240           CALL    GETSPA          ;GET SPACE FOR NEW STRING
38260           POP     B               ;GET BACK OFFSET
38280           POP     H               ;GET BACK DESC POINTER.
38300           PUSH    H               ;BUT KEEP ON STACK
38320           INX     H               ;MOVE TO STRING POINTER FIELD
38340   IFN     LENGTH-2,<
38360           INX     H>
38380           MOV     B,M             ;GET POINTER LOW
38400           INX     H               ;
38420           MOV     H,M             ;POINTER HIGH
38440           MOV     L,B             ;GET LOW IN  L
38460           MVI     B,0             ;GET READY TO ADD OFFSET TO POINTER
38480           DAD     B               ;ADD  IT
38500           MOV     B,H             ;GET OFFSET POINTER IN [B,C]
38520           MOV     C,L
38540           CALL    STRAD2          ;SAVE INFO IN DSCTMP
38560           MOV     L,A             ;GET#  OF CHARS TO  MOVE IN L
38580           CALL    MOVSTR          ;MOVE THEM IN
38600           POP     D               ;GET BACK DESC. POINTER
38620           CALL    FRETMP          ;FREE IT UP.
38640           JMP     PUTNEW          ;PUT TEMP IN TEMP LIST
38680   RIGHT$: CALL    PREAM           ;CHECK ARG
38700           POP     D               ;GET DESC. POINTER
38720           PUSH    D               ;SAVE BACK FOR LEFT
38740           LDAX    D               ;GET PRESENT LEN OF STR
38760           SUB     B               ;SUBTRACT 2ND PARM
38780           JMP     LEFT3           ;CONTINUE WITH LEFT CODE
38800   ;
38820   ; MID ($,#) RETURNS STR WITH CHARS FROM # POSITION
38840   ; ONWARD. IF # IS GT LEN($) THEN RETURN NULL STRING.
38860   ; MID ($,#,#) RETURNS STR WITH CHARS FROM # POSITION
38880   ; FOR #2 CHARS. IF @2 GOES PAST END OF STRING, RETURN
38900   ; AS MUCH AS POSSIBLE
38920   ;
38940   MID$:   XCHG                    ;PUT THE TEXT POINTER IN [H,L]
38960           MOV     A,M             ;GET THE FIRST CHARACTER
38980           CALL    PREAM2          ;GET OFFSET OFF STACK AND MAKE
39000                                   ;SURE DOES NOT = 0
39020           PUSH    B               ;PUT OFFSET ON TO THE STACK
39040           MVI     E,255           ;IF TWO ARG GUY, TRUNCATE.
39060           CPI     ")"
39080           JZ      MID2            ;[E] SAYS USE ALL CHARS
39100                                   ;IF ONE ARGUMENT THIS IS CORRECT
39120           SYNCHK  442             ;COMMA? MUST DELINEATE 3RD ARG.
39140           CALL    GETBYT          ;GET ARGUMENT  IN  [E]
39160   MID2:   SYNCHK  ")"             ;MUST BE FOLLOWED BY )
39180           POP     PSW             ;GET OFFSET BACK IN A
39200           XTHL                    ;SAVE TEXT POINTER, GET DESC.
39220           LXI     B,LEFT2         ;WHERE TO RETURN TO.
39240           PUSH    B               ;GOES ON STACK
39260           DCR     A               ;SUB ONE FROM OFFSET
39280           CMP     M               ;POINTER PAST END OF STR?
39300           MVI     B,0             ;ASSUME NULL LENGTH STR
39320           RNC                     ;YES, JUST USE NULL STR
39340           MOV     C,A             ;SAVE OFFSET OF CHARACTER POINTER
39360           MOC     A,M             ;GET PRESENT LEN OF STR
39380           SUB     C               ;SUBTRACT INDEX (2ND ARG)
39400           CMP     E               ;IS IT TRUNCATION
39420           MOV     B,A             ;GET CALCED LENGTH IN B
39440           RC                      ;IF NOT USE PARTIAL STR
39460           MOV     B,E             ;USE TRUNCATED LENGTH
39480           RET>                    ;RETURN TO LEFT2
39500   IFN LENGTH,<
39520   ;
39540   ; THE FOLLOWING FUNCTIONS ALLOW THE
39560   ; USER FULL ACCESS TO THE ALTAIR I/O PORTS
39580   ; INP(CHANNEL#) RETURNS AN INTEGER WHICH IS THE STATUS
39600   ; OF THE CHANNEL. OUT CHANNEL#,VALUE PUTS OUT THE INTEGER
39620   ; VALUE ON CHANNEL #. IT IS A STATEMENT, NOT A FUNCTION.
39640   ;
39660   FNINP:  CALL    CONINT          ;GET INTEGER CHANNEL #
39680           STA     INPWRD+1        ;GET INP INSTR
39700   INPWRD: IN      0               ;THE INP INSTR
39720           JMP     SNGFLT          ;SNGFLT RESULT
                                        ;GET READY
39760   FNOUT:  CALL    SETIO
39780   OUTWRD: OUT     0               ;DO IT
39800           RET                     ;AND THATS ALL
39820   ;
39840   ; THE WAIT CHANNEL#,MASK,MASK2,WAITS UNTIL THE STATUS
39860   ; RETURNED BY CHANNEL# IS NON ZERO WHEN XORED WITH MASK2
39880   ; AND THEN ANDED WITH MASK. IF MASK2 IS NOT PRESENT IT IS ASSUMED
39900   ; TO BE ZERO
39920   ;
39940   FNWAIT: CALL    SETIO           ;SET UP FOR WAIT
39960           PUSH    PSW             ;SAVE THE MASK
39980           MVI     E,0             ;DEFAULT MASK2 TO ZERO
40000           DCX     H
40020           CHRGET                  ;SEE IF THE STATEMENT ENDED
40040           JZ      NOTTHR          ;IF NO THIRD ARGUMENT SKIP THIS
40060           SYNCHK  44              ;MAKE SURE THERE IS A ","
40080           CALL    GETBYT
40100   NOTTHR: POP     B               ;REGET THE "AND" MASK
40120   STAINP: IN      0               ;THE INPUT INSTR
40140           XRA     E               ;XOR WITH MASK2
40160           ANA     B               ;AND WITH MASK
40180           JZ      STAINP          ;LOOP UNTIL RESULT IS NON-ZERO
40200                                   ;NOTE: THIS LOOP CANNOT BE CONTROL-C'ED
40220                                   ;UNLESS THE AIT IS BEING DONE ON CHANNEL
40240                                   ;ZERO. HOWEVER A RESTART AT 0 IS OK.
40260           RET>
40280   IFN     STRING,<
40300   ;USED BY RIGHT$ AND LEFT$ FOR PARAMETER CHECKING AND SETUP
40320   PREAM:  XCHG                    ;PUT THE TEXT POINTER IN [H,L]
40340           SYNCHK  ")"             ;PARAM LIST SHOULD END
40360   ;USED BY MID$ FOR PARAMETER CHECKING AND SETUP
40380   PREAM2: POP     B               ;GET RETURN ADDR OFF STACK
40400           POP     D               ;GET LENGTH OF ARG OFF STACK
40420           PUSH    B               ;SAVE RETURN ADDR BACK ON
40440           MOV     B,E             ;SAVE INIT LENGTH
40460           INR     B
40480           DCR     B               ;SEE IF EQUAL TO ZERO
40500   IFE     LENGTH-2,<
40520           RNZ
40536   ILLFUN:
40540   FCERR:  MVI     E,ERRFC
40560           JMP     ERROR>
40580   IFN     LENGTH-2,<
40600           JZ      FCERR           ;IT MUST NOT BE 0
40620           RET>
40640   IFN     LENGTH,<
40660   SETIO:  CALL    GETBYT          ;GET INTEGER CHANNEL NUMBER IN [A]
40680           STA     STAINP+1        ;SETUP "WAIT"
40700           STA     OUTWRD+1        ;SETUP "OUT"
40720           SYNCHK  44              ;MAKE SURE THERE IS A COMMA
40740           XWD     ^O1000,6>       ;"MVI B," AROUND THE CHRGET
40760   IFN     STRING!LENGTH,<
40780   GTBYTC: CHRGET
40800   IFE     LENGTH-2,<
40820   GETBYT: CALL    FRMEVL
40840   CONINT: PUSH    H
40860           CALL    FRCINT
40880           ZCHG
40900           POP     H>
40920   IFN     LENGTH-2,<
40940   GETBYT: CALL    FRMNUM          ;READ FORMULA INTO THE FAC.
40960   CONINT: CALL    POPINT>         ;CONVERT THE FAC TO A SINGLE BYTE INTEGER
40980           MOV     A,D             ;SHOULD BE .LT. 255
41000           ORA     A               ;SET CC'S
41020           JNZ     FCERR           ;WASN'T ERROR
41040           DCX     H               ;ACTUALLY FUNCTIONS CAN GET HERE
41060                                   ;WITH BAD [H,L] BUT NOT SERIOUS
41080                                   ;SET CONDITION CODES ON TERMINATOR
41100           CHRGET
41120           MOV     A,E             ;RETURN THE RESULT IN [A] AND [E]
41140           RET>
41180   IFN     STRING,<
41200   ;
41202   ; THE VAL FUNCTION TAKES A STRING AND TURN IT INTO
41204   ; A NUMBER BY INTERPRETING THE ASCII DIGITS. ETC...
41206   ; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
41208   ; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL
41210   ; IS MERELY A CALL TO FLOATING INPUT (FIN)
41212   ;
41220   VAL:    CALL    LEN1            ;DO SETUP, SET RESULT=REAL
41240           JZ      ZERO            ;RETURN ZERO IF NULL
41260           MOV     E,A             ;GET LENGTH OF STR
41270   IFN     LENGTH-2,<
41280           INX     H>              ;THIS IS ALL A KLUDGE
41300           INX     H               ;TO HANDLE THE FACT THE IF
41320           PUSHM                   ;TWO STRINGS "1" AND "2"
41340           MOV     H,B             ;ARE STORED NEXT TO EACH OTHER
41360           MOV     L,C             ;AND FIN IS CALLED POINTING TO
41380           DAD     D               ;THE FIRST TWELVE WILL BE RETURNED
41400           MOV     B,M             ;THE IDEA IS TO STORE 0 IN THE
41420           MOV     M,D             ;STRING BEYOND THE ONE VAL
41440           XTHL                    ;IS BEING CALLED ON
41460           PUSH    B               ;THE FIRST CHARACTER OF THE NEXT STRING
41480           MOV     A,M             ;GET FIRST CHARACTER OF ARGUMENT
41500           CALL    FIN             ;TURN IT INTO A NUMBER IN THE FAC
41520           POP     B               ;GET THE MODIFIED CHARACTER OF THE NEXT
41540                                   ;STRING INTO [B]
41560           POP     H               ;GET THE POINTER TO THE MODIFIED CHARACTER
41580           MOV     M,B             ;RESTORE THE CHARACTER
41600                                   ;IF STRING IS THE HIGHEST IN STRING SPACE
41620                                   ;WE ARE MODIFYING [MEMSIZ] AND
41640                                   ;THIS IS WHY [MEMSIZ] CAN'T BE USED TO STORE
41660                                   ;STRING DATA BECAUSE WHAT IF THE
41680                                   ;USER TOOK VAL OFF THAT HIGH STRING
41700           RET>
41740   PAGE
41760   SUBTTL  FANCY LIST,DELETE,EDIT,LLIST
41780   IFE     LENGTH-2,<
41800   IFN     LPTSW,<
41820   LLIST:  MVI     A,1             ;GET NON ZERO VALUE
41840           STA     PRTFLG>         ;SAVE IN I/O FLAG
41860   LIST:   POP     B               ;GET RID OF NEWSTT RETURN ADDR
41880           CALL    SCNLIN          ;SCAN LINE RANGE
41900           PUSH    B               ;SAVE POINTER TO 1ST LINE
41920   LIST4:  POP     H               ;GET POINTER TO LINE
41940           POP     D               ;GET MAX LINE # OFF STACK
41960           PUSHM                   ;PUSH LINK
41980           MOV     A,B             ;SEE IF END OF CHAIN
42000           ORA     C
42020           POP     B               ;GET LINK OFF STACK FOR ISCNTC
42040           JZ      READY           ;LAST LINE, STOP.
42060   IFN     LISTEN,<
42080           CALL    ISCNTC>         ;CHECK FOR CONTROL-C
42100           PUSH    B               ;SAVE LINK BACK ON
42120           PUSHM                   ;PUSH LINE #
42140           XTHL                    ;GET LINE # INTO [H,L]
42160           XCHG                    ;GET MAX LINE IN [H,L]
42180           COMPAR                  ;PAST LAST LINE IN RANGE?
42200           POP     B               ;TEXT POINTER TO [B,C]
42260           JC      STPRDY          ;IF PAST, THEN DONE LISTING.
42280           XTHL                    ;SAVE MAX ON BOTTOM OF STACK
42300           PUSH    H               ;SAVE LINK ON TOP
42320           PUSH    B               ;SAVE TEXT POINTER BACK
42340           XCHG                    ;GET LINE # IN [H,L]
42360           CALL    CRDO            ;DO CRLF TO START OUT
42380                                   ;AND WE WANT [H,L] ON THE STACK
42400           CALL    LINPRT          ;PRINT AS INT WITHOUT LEADING SPACE
42420           MVI     A," "
42440           POP     H
42460           OUTCHR                  ;PRINT A SPACE AFTER THE LINE #
42480           CALL    BUFLIN          ;UNPACK THE LINE INTO BUG
42500           LXI     H,BUF-1         ;POINT AT THE START OF THE UNPACKED CHARACTERS
42520           MVI     B,0             ;STOP ON ZERO ONLY
42540           CALL    STRLT3          ;LITERALIZE THE LINE STRING
42560           CALL    STRPRT          ;PRINT OUT THE CHARACTERS
42580           JMP     LIST4           ;PRINT ANOTHER LINE
42600   BUFLIN: LXI     B,BUF-1
42620           XWD     ^O1000,^O26     ;"MVI   D," AROUND THE NEXT BYTE
42640   PRIT4:  POP     H               ;RESTORE POINTER TO START OF TEXT
42660   PLOOP:  MOV     A,M             ;GET A CHARACTER FROM LINE.
42680           INX     B               ;ADVANCE STUFF COUNT
42700           ORA     A               ;IS IT A RESERVED WORD
42720           INX     H               ;INCREMENT POINTER INTO TEXT
42740           STAX    B               ;STORE A ZERO IF THE END
42760           RZ                      ;ZERO, END OF LINE.
42780           JP      PLOOP           ;REGULAR CHAR, JUST PRINT IT
42800           CPI     ELSETK          ;IF ITS "ELSE" DON'T PRINT THE COLON
42820                                   ;IN FRONT OF IT
42840           CZ      DCXBRT##        ;BACKUP STUFF COUNT TO ELIMINATE
42860           SUI     127             ;GET RID OF SIGN BIT AND ADD ONE
42880           PUSH    H               ;SAVE CURRENT POSIT
42900           LXI     D,RESLST        ;GET RESLIST POINTER.
42920   RESRCH: PUSH    D
42940           PUSH    PSW             ;SAVE THE RESERVED WORD NUMBER
42960   RESCR1: LDAX    D               ;GET CHARACTER FROM RESLST
42980           INX     D               ;BUMP RESLST POINTER
43000           ORA     A               ;TEST BITS
43020           JP      RESCR1          ;NOT AT END OF RESERVED WORD YET
43040           POP     PSW
43060           DCR     A               ;DECREMENT CHAR
43080           POP     H               ;POP START POINTER HERE
43100           JNZ     RESRCH          ;NOT AT END OF RESLST YET.
43120   ;HERE WHEN FOUND RIGHT RESERVED WORD
43140   PRIT3:  MOV     A,M             ;GET A CHARACTER FROM RESERVED WORD
43160           ORA     A               ;SET CONDITION CODES
43180           STAX    B
43200           JM      PRIT4
43220           INX     B
43240           INX     H               ;BUMP RESLST POINTER
43260           JMP     PRT3            ;PRINT THE REST
43280   ;
43300   ; THE FOLLOWING CODE IS FOR THE DELETE RANGE
43320   ; COMMAND. BEFORE THE LINES ARE DELETED, 'OK'
43340   ; IS TYPED.
43360   ;
43380   DELETE: CALL    SCNLIN          ;SCAN LINE RANGE
43400           POP     D               ;POP MAX LINE OFF STACK
43420           PUSH    B               ;SAVE POINTER TO START OF 1ST LINE
43440           CALL    FNDLIN          ;FIND THE LAST LINE
43460           POP     B               ;GET POINTER TO FIRST IN [B,C]
43480           PUSH    H               ;SAVE THE POINTER TO THE NEXT LINE
43500           LXI     H,REDDY         ;PRINT "OK" PREMATURELY
43520           CALL    STROUT
43540           LXI     H,FINI          ;GO BACK TO FINI WHEN DONE
43560           XTHL                    ;[H,L]=POINTER TO THE NEXT LINE
43580   DEL:    XCHG                    ;[D,E] NOW HAVE THE POINTER TO THE LINE
43600                                   ;BEYOND THIS ONE
43620           LHLD    VARTAB          ;COMPACTIFYING TO VARTAB
43640   MLOOP:  LDAX    D
43660           STAX    B               ;SHOVING DOWN TO ELIMINATE A LINE
43680           INX     B
43700           INX     D
43720           COMPAR
43740           JNC     MLOOP           ;DONE COMPACTIFYING?
43760           MOV     H,B
43780           MOV     L,C
43800           INX     H               ;NEW VARTAB
43820           SHLD    VARTAB
43840           RET>
43860   PAGE
43880   SUBTTL  DISK CODE
43900   IFN     DSKFUN,<
43920   ;
43940   ; THE STATEMENT DSKO$ STRING,SECTOR WRITES
43960   ; THE STRING (UP TO 132 DECIMAL CHARS
43980   ; ON THE SECTOR SPECIFIED.
44000   ; DSKI$ (SECTOR) IS A STRING FUNCTION THAT
44020   ; RETURNS THE 133 BYTE STRING STORED ON SECTOR.
44040   ;
44060   DSKO$:  CALL    FRMEVL          ;EVALUATE FORMULA
44080           SYNCHK  44              ;FOLLOWED BY COMMA
44100           PUSH    H               ;SAVE TEXT POINTER
44120           CALL    FRESTR          ;FREE UP THE FACLO
44140           XTHL                    ;[H,L]=TXTPTR SAVE POINTER AT
44160                                   ;STRING DESCRIPTOR ON THE STACK
44180           CALL    GETBYT          ;EVALUATE 2ND ARG(SECTOR) IN [E]
44200           XTHL                    ;SAVE TEXT POINTER, GET DESC.
44220           PUSHM                   ;[C]=LENGTH [H,L]=POINTER
44240           PUSHM
44260           POP     H               ;[H,L] GET STRING POINTER
44280           POP     B
44300           MOV     B,A             ;SECTOR NUMBER INTO [B]
44320           MVI     A,^D137
44340           SUB     C
44360           JC      FCERR           ;STRING TOO LONG
44380           INR     A
44400           MOV     E,A             ;NUMBER OF ZEROS+1
44420           MVI     D,64            ;SETUP A MASK
44440           INR     C
44460           MVI     A,4             ;LOAD THE HEAD
44480           OUT     9               ;TO DISK STATUS
44500   SECLP:  IN      ^O11            ;GET SECTOR STATUS
44520           RAR                     ;TEST FOR START OF SECTOR
44540           JNC     SECLP           ;KEEP WAITING
44560           ANI     63              ;START OF SECTOR, RIGHT ONE
44580           CMP     B               ;COMPARE TO FIND OUT
44600           JNZ     SECLP           ;IF NOT
44620           MVI     A,128           ;WRITE ENABLE DISK
44640           OUT     9
44660           MVI     8,255           ;ALL ONE'S ALWAYS WRITTEN FIRST
44680   WRITOK: IN      8               ;GET STATUS
44700           ANA     D               ;WRITE OK
44720           JZ      WRITOK          ;NO, MORE LOOPING.
44740           MOV     A,B             ;GET CHARACTER TO WRITE
44760           OUT     10              ;SEND IT OUT
44780           DCR     C               ;TEST FOR NULL
44800           JZ      ZRLOP
44820   NOTYTD: IN      8               ;POLL
44840           ANA     D               ;MASK TEST
44860           JZ      NOTYTD          ;WAITING
44880           MOV     A,M             ;GET CHARACTER
44900           OUT     10
44920           DCR     C               ;DECREMENT CHARACTER COUNT
44940           INX     H
44960           JNZ     NOTYTD
44980   ZRLOP:  IN      8
45000           ANA     D
45020           JZ      ZRLOP
45040           XRA     A               ;PUT OUT A ZERO
45060           OUT     10
45080           DCR     E
45100           JNZ     ZRLOP
45120   TRUFIN: MVI     A,8             ;UNLOAD THE HEAD
45140           OUT     9
45160           POP     H
45180           RET                     ;DONE
45200
45220   DSKI$:  MVI     A,137           ;A LOT OF CHARACTERS ARE COMING
45240           CALL    STRINI          ;MAKE ROOM!
45260           CALL    CONINT          ;WHERE ARE THEY?
45280                                   ;SECTOR NOW IN [E]
45300           LHLD    DSCTMP+2        ;PLACE TO STORE THEM
45320           MVI     A,4             ;LOAD THE HEAD
45340           OUT     9
45360   SECLP2: IN      9               ;GET SECTOR INFO
45380           ORA     A               ;SEE IF BEGINNING OF SECTOR(READ)
45400           JP      SECLP2          ;IF NOT, KEEP WAITING
45420           RAR                     ;FIX UP SECTOR #
45440           ANI     63              ;GET SECTOR #
45460           CMP     E               ;IS IT THE ONE WE WAITED
45480           JNZ     SECLP2          ;TRY TO FIND IT
45500           MVI     C,137           ;GET # OF CHARS TO READ
45520   READOK: IN      8               ;GET DISK STATUS
45540           ORA     A               ;READY TO READ BYTE
45560           JP      READOK
45580           IN      10              ;READ THE STUFF
45600           MOV     M,A             ;SAVE IN STR
45620           INX     H               ;BUMP DEST POINTER
45640           DCR     C               ;LESS CHARS
45660           JNZ     READOK
45680           MVI     A,8             ;UNLOAD HEAD
45700           OUT     9
45720           JMP     FINBCK          ;USE CHR$ TO FINISH UP
45740
45760   PATCH:  BLOCK   20>
45780   PAGE
45800   SUBTTL  CLOAD,CSAVE,CONSOLE
45820   ;
45840   ; THE CONSOLE COMMAND ALLOWS THE USER TO CHANGE THE I/O CHANNEL
45860   ; THAT THE USER TERMINAL IS ON. BY GIVING THE COMMAND CONSOLE X
45880   ; WHERE X IS SOME INTEGER THE TERMINAL DEVICE WILL BE POLLED FROM
45900   ; CHANNELS X AND X+1. RESTARTING AT LOCATION ZERO FORCED THE TERMINAL
45920   ; TO BE ON CHANNEL ZERO AGAIN.
45940   ;
45960   IFN     CONSSW,<
45980   INTERNAL        CONSDO
46000   CONSDO: XRA     A               ;FORCE A CHANNEL ZERO CONSOLE
46020           CALL    CONS2           ;ON RESTART AT ZERO
46040           JMP     READY           ;TYPE "OK" AND ACCEPT INPUT
46060   CONSOL: CALL    GETBYT          ;FETCH AN INTEGER INTO [A]
46080           RNZ                     ;CHECK FOR A TERMINATOR
46100   CONS2:
46120   IFN     REALIO,<
46140           STA     CNLCA1          ;CHANGE ALL THE FLAG INPUT CHANNEL
46160           STA     CNLCA2
46180           STA     CNLCA3>
46200   IFN     LENGTH,<
46220           STA     CNLCA4>
46240           INR     A               ;[A]=DATA INPUT CHANNEL
46260           STA     CNLCB1          ;CHANGE ALL THE DATA INPUT CHANNEL
46280           STA     CNLCB2
46300           RET>
46320   IFN     CASSW,<
46340   ;
46360   ; CASIN READS A CHARACTER FROM THE CASSETTE
46380   ; INTO [A] WITHOUT MODIFYING ANYTHING BUT [A] AND THE CONDITION
46400   ; CODES
46420   ;
46440   CASIN:  IN      6               ;ROUTINE TO READ A CHARACTER
46460           ANI     IDONE           ;FROM THE CASSETTE INTO [A]
46480           JNZ     CASIN
46500           IN      7               ;READ THE DATA
46520           RET
46540   ;
46560   ; CASOUT OUTPUTS THE CHARACTER IN [A] TO THE CASSETTE
46580   ; WITHOUT MODIFYING ANYTHING
46600   ;
46620   TWOCSO: CALL    CASOUT          ;DOUBLE OUT OF [A]
46640   CASOUT: PUSH    PSW             ;ROUTINE TO WRITE A CHARACTER IN [A]
46660   CASLK:  IN      6               ;ONTO THE CASSETTE
46680           ANI     ODONE
46700           JNZ     CASLK           ;WAIT TILL CASSETTE IS READY
46720           POP     PSW             ;GET THE CHARACTER BACK
46740           OUT     7               ;OUTPUT THE CHARACTER
46760           RET
46780   ;
46800   ; THE CSAVE COMMAND WRITES A PROGRAM ONTO CASSETTE BY DUMPING
46820   ; BASICS CORE. THE HEADER IS THREE 211'S FOLLOWED BY A ONE
46840   ; CHARACTER FILE NAME. THE END IS THREE ZEROS IN A ROW.
46860   ;
46880   CSAVE:  PUSH    H
46900           MVI     A,211
46920           CALL    CASOUT          ;PUT OUT THE START BYTES
46940           CALL    TWOCSO          ;TWO MORE TIMES
46960           MOV     A,M             ;GET FILENAME
46980           CALL    CASOUT          ;STORE AFTER 211'S
47000           LHLD    TXTTAB          ;START OF PROGRAM
47020           XCHG
47040           LHLD    VARTAB          ;END OF PROGRAM
47060   LOPCSO: LDAX    D               ;GET A BYTE FROM THE PROGRAM
47080           INX     D
47100           CALL    CASOUT          ;SEND IT OUT TO THE CASSETTE
47120           COMPAR                  ;THE END?
47140           JNZ     LOPCSO          ;IF NOT,OUTPUT MORE
47160           CALL    TWOCSO          ;TWO MORE 0'S TO MARK THE END
47180           POP     H               ;RESTORE THE TEXT POINTER
47200           CHRGET                  ;GO PAST THE FILE NAME
47220           RET
47240   ;
47260   ; THE CLOAD COMMAND CLEARS CORE AND THEN READS A PROGRAM
47280   ; FROM CASSETTE. SINCE THE LINKS OF THE FILE ON CASSETTE
47300   ; WILL BE WRONG IF THE FILE WAS SAVED WITH A DIFFERENT VERSION
47320   ; BASIC FINI IS JUMPED TO. A SCRATCH IS DONE AT THE START SO RESTARTS
47340   ; AT 0 WON'T LEAVE THIGNS IN A GARBAGE STATE.
47360   ;
47380   CLOAD:  STA     FACLO           ;SAVE THE FILENAME
47400           CALL    SCRTCH          ;RESET EVERYTHING
47420   LOPCLK: MVI     B,3             ;NUMBER OF START CHARACTERS
47440   LOPCL2: CALL    CASIN           ;GET A CHARACTER
47460           CPI     211             ;START CHARACTER?
47480           JNZ     LOPCLK          ;NO RESET COUNT AND LOOK SOME MORE
47500           DCR     B               ;DECREMENT THE COUNT
47520           JNZ     LOPCL2          ;SEEN THREE YET?
47540           LXI     H,FACLO         ;POINT AT THE FILENAME
47560           CALL    CASIN           ;READ THIS FILENAME
47580           CMP     M               ;THE RIGHT FILE?
47600           JNZ     LOPCLK          ;IF NOT,START COMPLETELY OVER
47620           LHLD    TXTTAB          ;PLACE TO STORE THE PROGRAM
47640   DOCRS:  MVI     B,4             ;NUMBER OF ZEROS TO GET
47660                                   ;BEFORE STOPPING
47680   DOCSMR: CALL    CASIN           ;GET A CHARACTER
47700           MOV     M,A             ;STORE IT
47720           CALL    REASON          ;MAKE SURE THERE IS ROOM
47740           MOV     A,M             ;REGET THE CHARACTER
47760           ORA     A               ;A ZERO?
47780           INX     H
47800           JNZ     DOCRS           ;RESET # OF ZEROES SEEN
47820           DCR     B               ;DECREMENT NUMBER OF ZEROS
47840           JNZ     DOCSMR          ;SEEN FOUR?
47860           SHLD    VARTAB          ;SETUP END OF PROGRAM
47880           LXI     H,REDDY         ;TYPE "OK" PREMATURELY
47900           CALL    STROUT
47920           JMP     FINI>           ;FIX UP THE LINKS AND GO BACK TO MAIN
47940   PAGE
47960   SUBTTL PEEK AND POKE
47980   IFN     LENGTH,<
48000   IFE     LENGTH-2,<
48020   PEEK:   CALL    FRCINT          ;GET AN INTEGER IN [H,L]
48040           MOV     A,M>            ;GET THE VALUE TO RETURN
48060   IFN     LENGTH-2,<
48080   PEEK:   CALL    POSINT          ;GET THE VALUE OF FACLO INTO [D,E]
48100           LDAX    D>              ;READ THE VALUE
48120           JMP     SNGFLT          ;AND FLOAT IT
48140   IFE     LENGTH-2,<
48160   POKE:   CALL    FRMEVL
48180           PUSH    H               ;SAVE THE TEXT POINTER
48200           CALL    FRCINT          ;GET INTEGER VALUE OF FAC IN [H,L]
48220           XTHL>                   ;GET BACK THE TEXT POINTER
48240   IFN     LENGTH-2,<
48260   POKE:   CALL    INTID2          ;READ LOCATION TO POKE
48280           PUSH    D>              ;SAVE THE LOCATION
48300           SYNCHK  44              ;CHECK FOR A COMMA
48320           CALL    GETBYT
48340           POP     D               ;GET THE ADDRESS BACK
48360           STAX    D               ;STORE IT AWAY
48380           RET>                    ;SCANNED EVERYTHING
48400   ;
48420   ; NOTE: IN THE 8K PEEK ONLY ACCEPTS POSITIVE NUMBERS UP TO 32767
48440   ; POKE WILL ONLY TAKE AN ADDRESS UP TO 32767 , NO
48460   ; FUDGING ALLOWED. THE VALUE IS UNSIGNED.
48480   ;
48500   .C1=.P
48520   END
        003114' SIN     DCOMP           000702' EXT
        003127' SIN     DCXBRT          011204' EXT
        003461' SIN     DDIV            000700' EXT
        003303' SIN     DEF             007411'
        003124' SPD     DEFFIN          007521'
        003136' SPD     DEL             011271'
        003465'         DELETE          011245'
        001541' INT     DFACLO          001633' INT
        002705'         DIM             006500'
        004553'         DIMCON          006473'
        006405' EXT     DIMFLG          001542'
        011023'         DIRIS           003542'
        006041' EXT     DMULT           000676' EXT
        000000  SPD     DNTCPY          004217'
        003542'         DOASIG          005056'
        000001  SPD     DOCMP           006375'
        000017          DOCOND          004354'
        004237'         DODSP           005756'
        000131' EXT     DOMIN           006146'
        000131' INT     DONMUL          007326'
        000015  SPD     DORES           001544'
        004523' INT     DOSIZT          004621'
        002753'         DSCTMP          001570'
        004534'         DSKFUN          000000  SPD
        002533'         DSUB            000674' EXT
        006345'         DV0ERR          002075' INT
        001607' INT     DVAR            010214'
        002316'         DVAR2           010213'
        000002          DVARS           010214'
        000672' EXT     E               000003
        006437'         EATEM           006535'
        004072'         EDIT            000632' EXT
        000203  SPD     ELSE            007074'
        005025'         ELSETK          000220  SPD
        005166'         END             003474'
        001577'         ENDCON          003501'
        005163'         ENDREL          005415'
        001627'         ENDTK           000200  SPD
        002064'         EQULTK          000260
        000672'         ERRBS           000011  SPD
                        ERRCN           000021  SPD
                        ERRDD           000012  SPD
                        ERRDIR          007532'
                        ERRDV0          000013  SPD
                        ERRFC           000005  SPD
                        ERRFIN          002127'
                        ERRID           000014  SPD
                        ERRLS           000017  SPD
                        ERRNF           000001  SPD
                        ERROD           000004  SPD
00100   SEARCH  MCS808                  ;THE UNIVERSAL FILE
00200   SUBTTL  COMMON FILE
00300   SALL
00400   LENGTH==1                       ; 0 MEANS 4K, 1 MEANS 8K, 2 MEANS 12K
00500   REALIO==1
00600   CASSW==1                        ;CASSETTE SWITCH (CSAVE,CLOAD)
00700   LPTSW==0
00800   DSKFUN==0                       ;ON TO READ/WRITE
00900   CONSSW==0
01100   CONTRW==1                       ;ALLOW ^O
01200   IFE     REALIO,<
01300           LPTSW==0                ;SIMULATOR DEFAULTS
01400           CASSW==0
01500           CONSSW==0
01600           DSKFUN==0
01700           CONTRW==0>
01900   IFE     LENGTH,<
02000           EXTFNC==0               ;ON MEANS EXTENDED FUNCTIONS
02100           MULDIM==0               ;ON MEANS MULTIPLE DIMENSIONED ARRAYS ALLOWED
02200           STRING==0               ;ON MEANS STRINGS ALLOWED
02300           CASSW==0
02400           LPTSW==0
02500           DSFFUN==0
02600           CONSSW==0
02700           CONTRW==0>
02900   IFE     LENGTH-1,<
03000           EXTFNC==1
03100           MULDIM==1
03200           STRING==1>
03400   IFE     LENGTH-2,<
03500           EXTFNC==1
03600           MULDIM==1
03700           STRING==1>
03900   DEFINE  SYNCHK(A),<RST  1
04000                   A>
04100   DEFINE  CHRGET,<RST     2>
04200   DEFINE  OUTCHR,<RST     3>
04300   DEFINE  COMPAR,<RST     4>
04400   DEFINE  FSIGN,<RST      5>
04500   DEFINE  PUSHM,<RST      6>
04600   DEFINE  PUSHFM,<PUSHM
04700                   PUSHM>
04800   DEFINE  ACRLF,<
04900           ^D13
05000   IFN     STRING,<^D10>>
05100   DEFINE  PUSHR,<
05200           PUSH    D
05300           PUSH    B>
05400   DEFINE  POPR,<
05500           POP     B
05600           POP     D>
05700   DEFINE  MOVRI(B,C,D,E),<
05800           XWD     ^O1000,^O001    ;; "LXI B"
05900           EXP     C
06000           EXP     B
06100           XWD     ^O1000,^O021    ;; "LXI D"
06200           EXP     E
06300           EXP     D>
06500   IF1,<
06600   IFE     LENGTH,<PRINTX  /SMALL/>
06700   IFE     LENGTH-1,<PRINTX        /MEDIUM/>
06800   IFE     LENGTH-2,<PRINTX        /BIG/>
06900   IFE     REALIO,<PRINTX  /SIMULATE/>
07000   IFN     REALIO,<PRINTX  /ON MACHINE/>
07100   IFN     CASSW,<PRINTX   /CASSETTE/>
07200   IFN     LPTSW,<PRINTX   /LPT/>
07300   IFN     DSKFUN,<PRINTX  /DISK/>
07400   IFN     CONSSW,<PRINTX  /CONSOLE/>>
07500   PAGE
00100   SUBTTL  FLOATING POINT MATH PACKAGE CONFIGURATION
00120   TITLE   MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF
00160   IFNDEF  LENGTH,<
00180           PRINTX  !!! MUST HAVE COM !!!
00200           END>
00240   RADIX   8                       ;!!!! ALERT !!!!
00260                                   ;THROUGHOUT THE MATHPACKAGE!!
00300           ,P==0
00340   INTERNAL        ZERO,FLOAT,FLOATR,MOVE,FADD,FADDS,FSUB,FMULT,FDIV,FUN,FOUT
00360   INTERNAL        PUSHF,ABS,INT,QINT,SGN,SQR,RND,SIN,FCOMP,SIGNC,OVERR
00380   INTERNAL        INPRT,LINPRT,MOVFM,MOVMF,MOVFR,MOVRF,MOVRM,NEG,INRART,INXHRT
00400   IFN     EXTFNC,<
00420   INTERNAL        FPWR,EXP,LOG,COS,TAN,ATN,FONE>
00440   IFN     MULDIM&<LENGTH-2>,<
00460   INTERNAL        DMULT>
00480   IFN     STRING,<
00500   INTERNAL        SIGNS>
00520   IFN     LENGTH-2,<
00540   INTERNAL        FADDT,FSUBT,FMULTT,FDIVT>
00560   IFE     LENGTH-1,<
00580   INTERNAL        FPWRT>
00600   IFE     LENGTH-2,<
00620   INTERNAL        VMOVMF,VMOVFM,FRCINT,FRCSNG,FRCDBL,VNEG,PUFOUT,DCXBRT,IADD
00640   INTERNAL        ISUB,IMULT,IDIV,ICOMP,INET,DADD,DSUB,DMULT,DDIV,DCOMP,INTFNC>
00700   EXTERNAL        FAC,FACLO,FBUFFR,MINUTK,PLUSTK,ERROR,DV0ERR,ERROV,FCERR,SIGN
00720   EXTERNAL        $CODE
00740   IFE     LENGTH-2,<
00760   EXTERNAL        DFACLO,ARG,ARGLO,VALTYP,TMERR,TEMP2,TEMP3>
00820   COMMENT %
00840           EXTERNAL LOCATIONS USED BY THE MATH-PACKAGE
00860           ;THE FLOATING ACCUMULATOR
00880   IFE     LENGTH-2,<
00900           BLOCK   1               ;[TEMPORARY LEAST SIGNIFICANT BYTE]
00920   DFACLO: BLOCK   4>              ;[FOUR LOWEST ORDERS FOR DOUBLE PRECISION]
00940   FACLO:  BLOCK   3               ;[LOW ORDER OF MANTISSA (LO)]
00960                                   ;[MIDDLE ORDER OF MANTISSA (MO)]
00980                                   ;[HIGH ORDER OF MANTISSA (HO)]
01000   FAC:    BLOCK   2               ;[EXPONENT]
01020                                   ;[TEMPORARY COMPLEMENT OF SIGN IN MSG]
01040   IFE     LENGTH-2,<
01060   ARGLO:  BLOCK   7               ;[LOCATION OF SECOND ARGUMENT FOR DOUBLE
01080   ARG:    BLOCK   1>              ; PRECISION]
01100   FBUFFR: BLOCK   ^D13            ;BUFFER FOR FOUT
01120   IFE     LENGTH-2,<BLOCK ^D<35-13>>
01180   THE FLOATING POINT FORMAT IS AS FOLLOWS:
01220   THE SIGN IS THE FIRST BIT OF THE MANTISSA
01240   THE MANTISSA IS 24 BITS LONG    ;;
01260   THE BINARY POINT IS TO THE LEFT OF THE MSB
01280   NUMBER = MANTISSA * 2 ^ EXPONENT
01300   THE MANTISSA IS POSITIVE, WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS
01320   THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT
01340   THE EXPONENT IS STORED IN EXCESS 200 I.E. WITH A BIAS OF 200
01360   SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT
01380   AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO. THE OTHER BYTES ARE IGNORED
01400   TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING:
01420           TO SHIFT RIGHT, EXP:=EXP+1
01440           TO SHIFT LEFT,  EXP:=EXP-1
01480   SO, IN MEMORY THE NUMBER LOOKS LIKE THIS:
01500           (BITS 17-24 OF THE MANTISSA)
01520           (BITS 9-16 OF THE MANTISSA)
01540           (THE SIGN IN BIT 7, BITS 2-8 OF THE MANTISSA ARE IN BITS 6-0)
01560           (THE EXPONENT AS A SIGNED NUMBER + 200
01580   (REMEMBER THAT BIT 1 OF THE MANTISSA IS ALWAYS A ONE)
01620   ARITHMETIC ROUTINE CALLING CONVENTIONS:
01660   FOR ONE ARGUMENT FUNCTIONS:
01680           THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
01700   FOR TWO ARGUMENT OPERATIONS:
01720           THE FIRST ARGUMENT IS IN B,C,D,E I.E. THE "REGISTERS"
01740           THE SECOND ARGUMENT IS IN THE FAC
01760           THE RESULT IS LEFT IN THE FAC
01800   THE "S" ENTRY POINTS TO THE TWO ARGUMENT OPERATIONS HAVE (HL) POINTING TO
01820   THE FIRST ARGUMENT INSTEAD OF THE FIRST ARGUMENT BEING IN THE REGISTERS.
01840   MOVRM IS CALLED TO GET THE ARGUMENT IN THE REGISTERS.
01860   THE "T" ENTRY POINTS ASSUME THE FIRST ARGUMENT IS ON THE STACK.
01880   POPR IS USED TO GET THE ARGUMENT IN THE REGISTERS.
01900   NOTE: THE "T" ENTRY POINTS SHOULD ALWAYS BE JUMPED TO AND NEVER CALLED
01920   BECAUSE THE RETURN ADDRESS ON THE STACK WILL BE CONFUSED WITH THE NUMBER.
01960   ON THE STACK, THE TWO LO'S ARE PUSHED ON FIRST AND THEN THE HO AND SIGN.
01980   THIS IS DONE SO IF A NUMBER OF STORED IN MEMORY, IT CAN BE PUSHED ON THE
02000   STACK WITH TWO PUSHM'S.  THE LOWER BYTE OF EACH PART IS IN THE LOWER
02020   MEMORY ADDRESS SO WHEN THE NUMBER IS POPPED INTO THE REGISTERS, THE HIGHER
02040   ORDER BYTE WILL BE IN THE HIGHER ORDER REGISTER OF THE REGISTER PAIR, I.E.
02060   THE HIGHER ORDER BYTE WILL BE POPPED INTO B, D OR H.
02080   %
02100   PAGE
02120   SUBTTL FLOATING POINT ADDITION AND SUBTRACTION
02140           ;ENTRY TO FADD WITH POINTER TO ARG IN (HL)
02160   FADDH:  LXI     H,FHALF         ;ENTRY TO ADD 1/2
02180   FADDS:  CALL    MOVRM           ;GET ARGUMENT INTO THE REGISTERS
02200           JMP     FADD            ;DO THE ADDITION
02320           ;SUBTRACTION    FAC:=ARG-FAC
02280   IFN     EXTFNC,<
02300   FSUBS:  CALL    MOVRM>          ;ENTRY IF POINTER TO ARG IS IN (HL)
02320   IFE     LENGTH-1,<
02340           XWD     1000,041>       ;"LXI   H" AROUND NEXT 2 BYTES
02360   IFN     LENGTH-2,<
02380   FSUBT:  POPR>                   ;ENTRY IF ARGUMENT IS ON THE STACK
02400   FSUB:   CALL    NEG             ;NEGATE SECOND ARGUMENT
02420                                   ;FALL INTO FADD
02480           ;ADDITION       FAC:=ARG+FAC
02500           ;ALTERS A,B,C,D,E,H,L
02520   IFN     LENGTH-2,<
02540           XWD     1000,041        ;"LXI   H" AROUND NEXT 2 BYTES
02560   FADDT:  POPR>                   ;ENTRY IF ARGUMENT IS ON THE STACK
02580   FADD:   MOV     A,B             ;CHECK IF FIRST ARGUMENT IS ZERO
02600           ORA     A               ;GET EXPONENT
02620           RZ                      ;IT IS, RESULT IS NUMBER IN FAC
02640           LDA     FAC             ;GET EXPONENT
02660           ORA     A               ;SEE IF THE NUMBER IS ZERO
02680           JZ      MOVFR           ;IT IS, ANSWER IS IN REGISTERS
02720   ;WE WANT TO GET THE SMALLER NUMBER IN THE REGISTERS SO WE CAN SHIFT IT RIGHT
02740   ;AND ALIGN THE BINARY POINTS OF THE TWO NUMBERS.  THEN WE CAN JUST ADD OR
02760   ;SUBTRACT THEM (DEPENDING ON THEIR SIGNS) BYTEWISE.
02780           SUB     B               ;CHECK RELATIVE SIZES
02800           JNC     FADD1           ;IS FAC SMALLER?
02820           CMA                     ;YES, NEGATE SHIFT COUNT
02840           INR     A
02860           XCHG                    ;SWITCH FAC AND REIGSTERS, SAVE (DE)
02880           CALL    PUSHF           ;PUT FAC ON STACK
02900           XCHG                    ;GET (DE) BACK WHERE IT BELONDS
02920           CALL    MOVFR           ;PUT REGISTERS IN THE FAC
02940           POPR                    ;GET THE OLD FAC IN THE REGISTERS
02960   FADD1:
02980   IFN     LENGTH,<
03060           CPI     31              ;ARE WE WITHIN 24 BITS?
03080           RNC>                    ;NO, ALL DONE
03100           PUSH    PSW             ;SAVE SHIFT COUNT
03120           CALL    UNPACK          ;UNPACK THE NUMBERS
03080           MOV     M,A             ;SAVE SUBTRACTION FLAG
03100           POP     PSW             ;GET SHIFT COUNT BACK
03120           CALL    SHIFTR          ;SHIFT REGISTERS RIGHT THE RIGHT AMOUNT
03160   ;IF THE NUMBERS HAVE THE SAME SIGN, THEN WE ADD THEM.  IF THE SIGNS ARE
03180   ;DIFFERENT, THEN WE AHVE TO SUBTRACT THEM.  WE HAVE TO DO THIS BECAUSE THE
03200   ;MANTISSAS ARE POSITIVE.  JUDGING BY THE EXPONENTS, THE LARGER NUMBER IS IN
03220   ;THE FAC, SO IF WE SUBTRACT, THE SIGN OF THE RESULT SHOULD BE THE SIGN OF THE
03240   ;FAC; HOWEVER, IF THE EXPONENTS ARE THE SAME, THE NUMBER IN THE REGISTERS
03260   ;COULD BE BIGGER, SO AFTER WE SUBTRACT THEM, WE HAVE TO CHECK IF THE RESULT
03280   ;WAS NEGATIVE.  IF IT WAS, WE NEGATE THE NUMBER IN THE REGISTERS AND
03300   ;COMPLEMENT THE SIGN OF THE FAC.  (HERE THE FAC IS UNPACKED)
03320   ;IF WE HAVE TO ADD THE NUMBERS, THE SIGN OF THE RESULT IS THE SIGN OF THE
03340   ;FAC.  SO, IN EITHER CASE, WHEN WE ARE ALL DONE, THE SIGN OF THE RESULT
03360   ;WILL BE THE SIGN OF THE FAC.
03380           ORA     H               ;GET SUBTRACTION FLAG
03400           LXI     H,FACLO         ;SET POINTER TO LO'S
03420           JP      FADD3           ;SUBTRACT IF THE SIGNS WERE DIFFERENT
03440           CALL    FADDA           ;ADD THE NUMBERS
03460           JNC     ROUND           ;ROUND RESULT IF THERE WAS NO OVERFLOW
03480                                   ;THE MOST IT CAN OVERFLOW IS ONE BIT
03500           INX     H               ;THERE WAS OVERFLOW
03520           INR     M               ;INCREMENT EXPONENT
03540           JZ      OVERR           ;CHECK FOR OVERFLOW
03560   IFE     LENGTH,<
03580           CALL    SHFTRO>         ;SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
03600   IFN     LENGTH,<
03620           MVI     L,1             ;SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
03640           CALL    SHRADD>
03660           JMP     ROUND           ;ROUND RESULT AND WE ARE DONE
03680           ;HERE TO SUBTRACT C,D,E,B FROM ((HL)+0,1,2),0
03700   FADD3:  XRA     A               ;SBUBTRACT NUBMERS, NEGATE UNDERFLOW BYTE
03720           SUB     B
03740           MOV     B,A             ;SAVE IT
03760           MOV     A,H             ;SUBTRACT LOW ORDERS
03780           SBB     E
03800           MOV     E,A
03820           INX     H               ;UPDATE POINTER TO NEXT BYTE
03840           MOV     A,M             ;SUBTRACT MIDDLE ORDERS
03860           SBB     D
03880           MOV     D,A
03900           INX     H               ;UPDATE POINTER TO HIGH ORDERS
03920           MOV     A,M             ;SUBTRACT HIGH ORDERS
03940           ABB     C
03960           MOV     C,A
03980           ;BECAUSE WE WANT A POSITIVE MANTISSA, CHECK IF WE HAVE TO NEGATE THE
04000           ; NUMBER
04020   FADFLT: CC      NEGR            ;ENTRY FROM FLOATR, INT: NEGATE NUMBER IF IT
04040                                   ; WAS NEGATIVE, FALL INTO NORMALIZE
04100           ;NORMALIZE C,D,E,B
04120           ;ALTERS A,B,C,D,E,M,L
04140           ;HERE WE SHIFT THE MANTISSA LEFT UNTIL THE MSB IS A ONE.
04160           ;EXCEPT IN 4K, THE IDEA IS TO SHIFT LEFT BY 8 AS MANY TIMES AS
04180           ;POSSIBLE.
04200   NORMAL:
04220   IFE     LENGTH,<
04240           MVI     H,0             ;CLEAR SHIFT COUNT
04260           MOV     A,C             ;IS THE NUMBER NORMALIZED?
04280           ORA     A
04300           JM      ROUND           ;YES, WE ARE DONE
04320   NORM2:  CPI     340             ;IS THE RESULT ZERO?
04340           JZ      ZERO            ;YES, ZERO THE FAC
04360           DCR     H               ;NO, DECREMENT SHIFT COUNT
04380           MOV     A,B             ;SHIFT THE LO LEFT
04400           ADD     A               ;SHIFT IN A ZERO
04420           MOV     B,A
04440           CALL    SHFTLO          ;SHIFT THE REST OF THE NUMBER LEFT ONE
04460           MOV     A,H             ;GET THE SHIFT COUNT
04480           JP      NORM2>          ;CONTINUE IF NUMBER IS NOT NORMALIZED
04500   IFN     LENFRG,<
04520           MOV     L,B             ;PUT LOWEST 2 BYTES IN (HL)
04540           MOV     H,E
04560           XRA     A               ;ZERO SHIFT COUNT
04580   NORM1:  MOV     B,A             ;SAVE SHIFT COUNT
04600           MOV     A,C             ;DO WE HAVE 1 BYTE OF ZEROS
04620           ORA     A
04640           JNZ     NORM3           ;NO, SHIFT ONE PLACE AT A TIME
04660           ;THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
04680           MOV     C,D             ;YES, SHIFT OVER 1 BYTE
04700           MOV     D,H
04720           MOV     H,L
04740           MOV     L,A             ;SHIFT IN 8 ZEROS FOR THE LOW ORDER
04760           MOV     A,B             ;UPDATE SHIFT COUNT
04780           SUI     10
04800           CPI     340             ;DID WE SHIFT IN 4 BYTES OF ZEROS?
04820           JNZ     NORM1           ;NO, TRY TO SHIFT OVER 8 MORE
04840                                   ;YES, NUMBER WAS ZERO.  FALL INTO ZERO
04900           ;ZERO FAC
04920           ;ALTERS A ONLY
04940           ;EXITS WITH A=0
04960           ;BY OUR FLOATING POINT FORMAT, THE NUMBER IS ZERO IF THE EXPONENT IS
04980           ; ZERO
05000   ZERO:   XRA     A               ;ZERO A
05020   ZERO0:  STA     FAC             ;ZERO THE FAC'S EXPONENT, ENTRY IF A=0
05040           RET                     ;ALL DONE
05100   NORM2:  DCR     B               ;DECREMENT SHIFT COUNT
05120           DAD     H               ;ROTATE (HL) LEFT ONE, SHIFT IN A ZERO
05140           MOV     A,D             ;ROTATE NEXT HIGHER ORDER LEFT ONE
05160           RAL
05180           MOV     D,A
05200           MOV     A,C             ;ROTATE HIGH ORDER LEFT ONE
05220           ADC     A               ;SET CONDITION CODES
05240           MOV     C,A
05260   NORM3:  JP      NORM2           ;WE HAVE MORE NORMALIZATION TO DO
05280           MOV     A,B             ;ALL NORMALIZED, GET SHIFT COUNT
05300           MOV     E,H             ;PUT LO'S BACK IN E,B
05320           MOV     B,L
05340           ORA     A               ;CHECK IF WE DID NO SHIFTING
05360           JZ      ROUND>
05380           LXI     H,FAC           LOOK AT FAC'S EXPONENT
05400           ADD     M               ;UPDATE EXPONENT
05420           MOV     M,A
05440           JNC     ZERO            ;CHECK FOR UNDERFLOW
05460           RZ                      ;NUMBER IS ZERO, ALL DONE
05480                                   ;FALL INTO ROUND AND WE ARE DONE
05540           ;ROUND RESULT IN C,D,E,B AND PUT NUMBER IN THE FAC
05560           ;ALTERS A,B,C,D,E,H,L
05580           ;WE ROUND C,D,E UP OR DOWN DEPENDING UPON THE MSB OF B
05600   ROUND:  MOV     A,B             ;SEE IF WE SHOULD ROUND UP
05620   ROUNDB: LXI     H,FAC           ;ENTRY FROM FDIV, GET POINTER TO EXPONENT
05640           ORA     A
05660           CM      ROUNDA          ;DO IT IF NECESSARY
05680           MOV     B,M             ;PUT EXPONENT IN B
05700           ;HERE WE PACK THE HO AND SIGN
05720           INX     H               ;POINT TO SIGN
05740           MOV     A,M             ;GET SIGN
05760           ANI     200             ;GET RID OF UNWANTED BITS
05780           XRA     C               ;PACK SIGN AND HO
05800           MOV     C,A             ;SAVE IT IN C
05820           JMP     MOVFR           ;SAVE NUMBER IN FAC
05880   IFE     LENGTH,<
05900           ;SHIFT C,D,E LEFT ONE
05920           ;THIS IS USED BY NORMAL, FDIV
05940           ;ALTERS A,C,D,E
05960   SHFTLO: MOV     A,E             ;GET THE LO
05980           RAL                     ;SHIFT IT
06000           MOV     E,A             ;SAVE IT
06020           MOV     A,D             ;SHIFT THE NEXT HIGHER ORDER
06040           RAL
06060           MOV     D,A
06080           MOV     A,C             ;SHIFT THE HIGHEST ORDER
06100           ADC     A               ;ROTATE A LEFT AND SET CONDITION CODES
06120           MOV     C,A
06140           RET>                    ;ALL DONE
06200           ;SUBROUTINE FOR ROUND:  ADD ONE TO C,D,E
06220   ROUNDA: INR     E               ;ADD ONE TO THE LOW ORDER, ENTRY FROM QINT
06240           RNZ                     ;ALL DONE IF IT IS NOT ZERO
06260           INR     D               ;ADD ONE TO NEXT HIGHER ORDER
06280           RNZ                     ;ALL DONE IF NO OVERFLOW
06300           INR     C               ;ADD ONE TO THE HIGHEST ORDER
06320           RNZ                     ;RETURN IF NO OVERFLOW
06340           MVI     C,200           ;THE NUMBER OVERFLOWED, SET NEW HIGH ORDER
06360           INR     M               ;UPDATE EXPONENT
06380           RNZ                     ;RETURN IF IT DID NOT OVERFLOW
06400                                   ;IT DID, FALL INTO OVERR
06440           ;OVERFLOW ERROR
06460   OVERR:  MVI     E,ERROV         ;SET OVERFLOW ERROR CODE
06480           JMP     ERROR           ;GO TO IT!!
06540           ;ADD (HL)+2,1,0 TO C,D,E
06560           ;THIS CODE IS USED BY FADD, FOUT
06580   FADDA:  MOV     A,M             ;GET LOWEST ORDER
06600           ADD     E               ;ADD IN OTHER LOWEST ORDER
06620           MOV     E,A             ;SAVE IT
06640           INX     H               ;UPDATE POINTER TO NEXT BYTE
06660           MOX     A,M             ;ADD MIDDLE ORDERS
06680           ADC     D
06700           MOV     D,A
06720           INX     H               ;UPDATE POINTER TO HIGH ORDER
06740           MOV     A,M             ;ADD HIGH ORDERS
06760           ADC     C
06780           MOV     C,A
06800           RET                     ;ALL DONE
06860           ;NEGATE NUMBER IN C,D,E,B
06880           ;THIS CODE IS USED BY FADD, QINT
06900           ;ALTERS A,B,C,D,E,L
06920   NEGH:   LXI     H,FAC+1         ;NEGATE FAC
06940           MOV     A,M             ;GET SIGN
06960           CMA                     ;COMPLEMENT IT
06980           MOV     M,A             ;SAVE IT AGAIN
07000           XRA     A               ;ZERO A
07020           MOV     L,A             ;SAVE ZERO IN L
07040           SUB     B               ;NEGATE LOWEST ORDER
07060           MOV     B,A             ;SAVE IT
07080           MOV     A,L             ;GET A ZERO
07100           SBB     E               ;NEGATE NEXT HIGHEST ORDER
07120           MOV     E,A             LSAVE IT
07140           MOV     A,L             ;GET A ZERO
07160           SBB     D               ;NEGATE NEXT HIGHEST ORDER
07180           MOV     D,A             ;SAVE IT
07200           MOV     A,L             ;GET ZERO BACK
07220           SBB     C               ;NEGATE HIGHEST ORDER
07240           MOV     C,A             ;SAVE IT
07260           RET                     ;ALL DONE
07320           ;SHIFT C,D,E RIGHT
07340           ;A = SHIFT COUNT
07360           ;ALTERS A,B,C,D,E,L
07380           ;THE IDEA (EXCEPT IN 4K) IS TO SHIFT RIGHT 8 PLACES
07400           ; POSSIBLE
07420   SHIFTR: MVI     B,0             ;ZERO OVERFLOW BYTE
07440   IFE     LENGTH,<
07460           INR     A>              ;ADD ONE TO SHIFT COUNT
07580   IFN     LENGTH,<
07500   SHFTR1: SUI     10              ;CAN WE SHIFT IT 8 RIGHT?
07520           JC      SHFTR2          ;NO, SHIFT IT ONE PLACE AT A TIME
07540           ;THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
07560           MOV     B,E             ;SHIFT NUMBER 1 BYTE RIGHT
07580           MOV     E,D
07600           MOV     D,C
07620           MVI     C,0             ;PUT 0 IN HO
07640           JMP     SHFTR1          ;TRY TO SHIFT 8 RIGHT AGAIN
07660   SHFTR2: ADI     11>             ;CORRECT SHIFT COUNT
07680           MOV     L,A             ;SAVE SHIFT COUNT
07700   SHFTR3: XRA     A               ;CLEAR CARRY
07720           DCR     L               ;ARE WE DONE SHIFTING?
07740           RZ                      ;RETURN IF WE ARE
07760   IFE     LENGTH,<
07780   SHRADD: CALL    SHFTRD>         ;SHIFT THE NUMBER RIGHT ONE
07800   IFN     LENGTH,<
07820           MOV     A,C             ;GET HO
07840   SHRADD: RAR                     ;ENTRY FROM FADD, SHIFT IT RIGHT
07860           MOV     C,A             ;SAVE IT
07880           MOV     A,D             ;SHIFT NEXT BYTE RIGHT
07900           RAR
07920           MOV     D,A
07940           MOV     A,E             ;SHIFT LOW ORDER RIGHT
07960           RAR
07980           MOV     E,A
08000           MOV     A,B             ;SHIFT OVERFLOW BYTE RIGHT
08020           RAR
08040           MOV     B,A>
08060           JMP     SHFTR3          ;SEE IF WE ARE DONE
08120   IFE     LENGTH,<
08140           ;SHIFT C,D,E,B RIGHT ONE
08160           ;THIS IS USED BY SHIFTR, FMULT, FADD
08180           ;ALTERS A,B,C,D,E
08200   SHFTRO: MOV     A,C             ;GET THE HO
08220   SHFR0A: RAR                     LSHIFT IS RIGHT, ENTRY FROM FMULT
08240           MOV     C,A
08260           MOV     A,D             ;SHIFT THE MO RIGHT
08280           RAR
08300           MOV     D,A
08320           MOV     A,E             ;SHIFT THE LO
08340           RAR
08360           MOV     E,A
08380           MOV     A,B             ;SHIFT THE EXTRA LO BYTE
08400           RAR
08420           MOV     B,A
08440           RET>                    ;ALL DONE
08460   PAGE
08480   SUBTTL  NATURAL LOG FUNCTION
08500   IFN     EXTFNC,<
08520           ;CALCULATION IS BY:
08540           ; LN(F*2^N)=(N+LOG2(F))*LN(2)
08560           ;AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F)
08600           ;CONSTANTS USED BY LOG
08620   FONE:   000     ; 1
08640           000
08660           000
08680           201
08700   LOGCN2: 3       ;DEGREE+1
08720           252     ; 0.598978650
08740           126
08760           031
08780           200
08800           361     ; 0.961470632
08820           042
08840           166
08860           200
08880           105     ; 2.88539129
08900           252     ; NOTE: THE REFERENCE FOR THIS CONSTANT HAS 100 NOT 105
08920           070     ; IN THE LOW ORDER BYTE.
08940           202
08980   LOG:    FSIGN                   ;CHECK FOR A NEGATIVE OR ZERO ARGUMENT
09000           JPE     FCERR           ;FAC .LE. 0, BLOW HIM OUT OF THE WATER
09020                                   ;FSIGN ONLY RETURNS 0,1 OR 377 IN A
09040                                   ;THE PARITY WILL BE EVEN IF A HAS 0 OR 377
09060           LXI     H,FAC           ;GET POINTER TO EXPONENT
09080           MOV     A,H             ;GET EXPONENT IN A
09100           MOVRI   200,065,004,363 ;GET SQR(.5)
09120           SUB     B               ;REMOVE EXCESS 200
09140           PUSH    PSW             ;SAVE EXPONENT FOR LATER
09160           MOV     M,B             ;SET EXP TO 200, RESULT IS NUM IN (.5,1)
09180           PUSHR                   ;SAVE SQR(.5)
09200           CALL    FADD            ;CALCULATE (F-SQR(.0))/(F+SQR(.5))
09220           POPR                    ;GET SQR(.5) BACK
09240           INR     B               ;GET SQR(2)
09260           CALL    FDIV            ;WHERE F=NUMBER LEFT IN FAC
09280           LXI     H,FONE          ;THE CALCULATION IS EQUIVALENT TO THE ABOVE
09300           CALL    FSUBS           ; BUT DONE IN A DIFFERENT ORDER
09320           LXI     H,LOGCN2        ;EVALUATE APPROXIMATION POLYNOMIAL
09340           CALL    POLYX
09360           MOVRI   200,200,000,000 ;GET -1/2
09380           CALL    FADD            ;ADD IN LAST CONSTANT
09400           POP     PSW             ;RETRIEVE ORIGINAL EXPONENT
09420           CALL    FINLOG          ;ADD IT TO ORIGINAL NUMBER
09440   MULLN2: MOVRI   200,061,162,030>CMT
09460   ;       JMP     FMULT           ;MULTIPLY BY LN(2)
09480   PAGE
09500   SUBTTL  FLOATING MULTIPLICATION AND DIVISION
09520           ;MULTIPLICATION         FAC:=ARC*FAC
09540           ;ALTERS A,B,C,D,E,H,L
09560   IFE     EXTFNC,<
09580   FMULTS: CALL    MOVRM>          ;ENTRY WITH POINTER TO ARG IN (HL)
09600   IFN     LENGTH-2,<
09620           XWD     1000,041        ;"LXI   H" AROUND NEXT 2 BYTES
09640   FMULTI: POPR>                   ;ENTRY IF ARGUMENT IS ON THE STACK
09660   FMULT:  FSIGN                   ;CHECK IF FAC IS ZERO
09680           RZ                      ;IF IT IS, RESULT IS ZERO
09700           MVI     L,0             ;ADD THE TWO EXPONENTS, L IS A FLAG
09720           CALL    MULDIV          ;FIX UP THE EXPONENTS
09740           ;SAVE THE NUMBER IN THE REGISTERS SO WE CAN ADD IT FAST
09760           MOV     A,C             ;GET HO
09780           STA     FMULTA+1        ;STORE HO OF REGISTERS
09800           XCHG                    ;STORE THE TWO LO'S OF THE REGISTERS
09820           SHLD    FMULTB+1
09840           LXI     B,$CODE         ;ZERO THE PRODUCT REGISTERS
09860           MOV     D,B
09880           MOV     E,B
09900           LXI     H,NORMAL        ;PUT ADDRESS OF NORMAL, WHERE WE FINISH UP,
09920           PUSH    H               ; ON THE STACK
09940           LXI     H,FMULT2        ;PUT FMULT2 ON THE STACK TWICE, SO AFTER
09960           PUSH    H               ; WE MULTIPLY BY THE LO BYTE, WE WILL
09980           PUSH    H               ; MULTIPLY BY THE MO AND HO
10000           LXI     H,FACLO         ;GET ADDRESS OF LO OF FAC
10020   FMULT2: MOV     A,M             ;GET BYTE TO MULTIPLY BY
10040           INX     H               ;MOVE POINTER TO NEXT BYTE
10060   IFN     LENGTH,<
10080           ORA     A
10100           JZ      FMULT3>         ;ARE WE MULTPLYING BY ZERO?
10120           PUSH    H               ;SAVE POINTER
10140   IFE     LENGTH,<
10160           MVI     L,10>           ;SET UP A COUNT
10180   IFN     LENGTH,<
10200           XCHG                    ;GET LO'S IN (HL)
10220           MVI     E,10>           ;SET UP A COUNT
10260   ;THE PRODUCT WILL BE FORMED IN C,D,E,B. THIS WILL BE IN C,H,L,B PART OF THE
10280   ;TIME IN ORDER TO USE THE "DAD" INSTRUCTION.  AT FMULT2, WE GET THE NEXT
10300   ;BYTE OF THE MANTISSA IN THE FAC TO MULTIPLY BY.  ((HL) POINTS TO IT)
10320   ;(THE FMULT2 SUBROUTINE PRESERVED (HL))  IN 8K, IF THE BYTE IS ZERO, WE JUST
10340   ;SHIFT THE PRODUCT 8 RIGHT.  THIS BYTE IS THEN SHIFTED RIGHT AND SAVED IN D
10360   ;(H IN 4K).  THE CARRY DETERMINES IF WE SHOULD ADD IN THE SECOND FACTOR
10380   ;IF WE DO, WE ADD IT TO C,H,L.  B IS ONLY USED TO DETERMINE WHICH WAY WE
10400   ;ROUND.  WE THEN SHIFT C,H,L,B (C,D,E,B) IN 4K RIGHT ONE TO GET READY FOR THE
10420   ;NEXT TIME THROUGH THE LOOP.  NOTE THAT THE CARRY IS SHIFTED INTO THE MSB OF
10440   ;C.  E HAS A COUNT (L IN 4K) TO DETERMINE WHEN WE HAVE LOOKED AT ALL THE BITS
10460   ;OF D (H IN 4K).
10480   FMULT4: RAR                     ;ROTATE BYTE RIGHT
10500   IFE     LENGTH,<
10520           MOV     H,A>            ;SAVE THE COUNT
10540   IFN     LENGTH,<
10560           MOV     D,A>            ;SAVE IT
10580           MOV     A,C             ;GET HO
10600           JNC     FMULTS          ;DON'T ADD IN NUMBER IF BIT WAS ZERO
10620   IFE     LENGTH,<
10640           XCHG>                   ;PUT THE LO'S IN (HL)
10660           PUSH    D               ;SAVE COUNTERS
10680   FMULTB: LXI     D,$CODE         ;GET LO'S OF NUMBER TO ADD, THIS IS SET ABOVE
10700           DAD     D               ;ADD THEM IN
10720           POP     D               ;GET COUNTERS BACK
10740   FMULTA: ACI     0               ;ADD IN HO, THIS IS SET UP ABOVE
10760   IFE     LENGTH,<
10780           XCHG                    ;PUT THE LO'S BACK IN (DE)
10800   FMULT5: CALL    SHFROA          ;SHIFT THE RESULT RIGHT ONE
10820           DCR     L               ;ARE WE DONE?
10840           MOV     A,H>            ;GET NUMBER WE ARE MULTIPLYING BY
10860   IFN     LENGTH,<
10880   FMULT5: RAR                     ;ROTATE RESULT RIGHT ONE
10900           MOV     C,A
10920           MOV     A,H             ;ROTATE NEXT BYTE
10940           RAR
10960           MOV     H,A
10980           MOV     A,L             ;ROTATE NEXT LOWER ORDER
11000           RAR
11020           MOV     L,A
11040           MOV     A,B             ;ROTATE LO
11060           RAR
11080           MOV     B,A
11100           DCR     E               ;ARE WE DONE?
11120           MOV     A,D>            ;GET NUMBER WE ARE MULTIPLYING BY
11140           JNZ     FMULT4          ;MULTIPLY AGAIN IF WE ARE NOT DONE
11160   IFN     LENGTH,<
11180           XHG>                    ;GET LO'S IN (HL)
11200   POPHRT: POP     H               ;GET POINTER TO NUMBER TO MULTIPLY BY
11220           RET                     ;ALL DONE
11240   IFN     LENGTH,<
11260   FMULT3: MOV     B,E             ;MULTIPLY BY ZERO: SHIFT EVERYTHING 8 RIGHT
11280           MOV     E,D
11300           MOV     D,C
11320           MOV     C,A             ;SHIFT IN 8 ZEROS ON THE LEFT
11340           RET>                    ;ALL DONE
11400           ;DIVIDE FAC BY 10
11420           ;ALTERS A,B,C,D,E,H,L
11440   DIV10:  CALL    PUSHF           ;SAVE NUMBER
11460   IFN     LENGTH-2,<
11480           MOVRI   204,040,000,000 ;LOAD CONSTANT '10' INTO REGISTERS
11500           CALL    MOVFR>          ;MOVE THE CONSTANT TO THE FAC
11520   IFE     LENGTH-2,<
11540           LXI     H,FTEN          ;GET POINTER TO THE CONSTANT '10'
11560           CALL    MOVFM>          ;MOVE TEN INTO THE FAC
11580   FDIVT:  POPR                    ;GET NUMBER BACK IN REGISTERS
11600                                   ;FALL INTO DIVIDE AND WE ARE DONE
11660           ;DIVISION       FAC:=ARG/FAC
11680           ;ALTERS A,B,C,D,E,H,L
11700   FDIV:   FSIGN                   ;CHECK FOR DIVISION BY ZERO
11720           JZ      DV0ERR          ;HE IS TRYING TO GET AWAY WITH IT
11740           MVI     L,377           ;SUBTRACT THE TWO EXPONENTS, L IS A FLAG
11760           CALL    MULDIV          ;FIX UP THE EXPONENTS AND THINGS
11780           INR     M               ;ADD 2 TO EXPONENT TO CORRECT SCALING
11800           INR     M
11820           ;HERE WE SAVE THE FAC IN MEMORY SO WE CAN SUBTRACT IT FROM THE NUMBER
11840           ;IN THE REGISTERS QUICKLY.
11860           DCX     H               ;POINT TO HO
11880           MOV     A,M             ;GET HO
11900           STA     FDIVA+1         ;SAVE IT
11920           DCX     H               ;SAVE MIDDLE ORDER
11940           MOV     A,M
11960           STA     FDIVB+1         ;PUT IT WHERE NOTHING WILL HURT IT
11960           DCX     H               ;SAVE LO
12000           MOV     A,M
12020           STA     FDIVC+1
12060   ;THE NUMERATOR WILL BE KEPT IN B,H,L.  THE QUOTIENT WILL BE FORMED IN C,D,E.
12080   ;TO GET A BIT OF THE QUOTIENT, WE FIRST SAVE B,H,L ON THE STACK, THEN
12100   ;SUBTRACT THE DENOMINATOR THAT WE SAVED IN MEMORY.  THE CARRY INDICATES
12120   ;WHETHER OR NOT B,H,L WAS BIGGER THAN THE DENOMINATOR.  IF B,H,L WAS BIGGER,
12140   ;THE NEXT BIT OF THE QUOTIENT IS A ONE.  TO GET THE OLD B,H,L OFF THE STACK,
12160   ;WE POP THEM INTO THE PSW.  IF THE DENOMINATOR WAS BIGGER, THE NEXT BIT OF
12180   ;THE QUOTIENT IS ZERO, AND WE GET THE OLD B,H,L BACK BY POPPING IT OFF THE
12200   ;STACK.  WE HAVE TO KEEP AN EXTRA BIT OF THE QUOTIENT IN FDIVG+1 IN CASE THE
12220   ;DENOMINATOR WAS BIGGER,  THEN B,H,L WILL GET SHIFTED LEFT.  IF THE MSB  OF
12240   ;B WAS ONE, IT HAS TO BE STORED SOMEWHERE, SO WE STORE IT IN FDIVG+1.  THEN
12260   ;THE NEXT TIME THROUGH THE LOOP B,H,L WILL LOOK BIGGER BECAUSE IT HAS AN
12280   ;EXTRA HO BIT IN FDIVG+1. WE ARE DONE DIVIDING WHEN THE MSB OF C IS A ONE.
12300   ;THIS OCCURS WHEN WE HAVE CALCULATED 24 BITS OF THE QUOTIENT.  WHEN WE JUMP
12320   ;TO ROUND, THE 25TH BIT OF THE QUOTIENT DETERMINES WHETHER WE ROUND OR NOT.
12340   ;IT IS IN THE MSB OF A.  IF INITIALLY THE DENOMINATOR IS BIGGER THAN THE
12360   ;NUMERATOR, THE FIRST BIT OF THE QUOTIENT WILL BE ZERO.  THIS MEANS WE
12380   ;WILL GO THROUGH THE DIVIDE LOOP 26 TIMES, SINCE IT STOPS ON THE 25TH BIT
12400   ;AFTER THE FIRST NON-ZERO BIT OF THE EXPONENT.  SO, THIS QUOTIENT WILL LOOK
12420   ;SHIFTED LEFT ONE FROM THE QUOTIENT OF TWO NUMBERS IN WHICH THE NUMERATOR IS
12440   ;BIGGER.  THIS CAN ONLY OCCUR ON THE FIRST TIME THROUGH THE LOOP, SO C,D,E
12460   ;ARE ALL ZERO.  SO, IF WE FINISH THE LOOP AND C,D,E ARE ALL ZERO, THEN WE
12480   ;MUST DECREMENT THE EXPONENT TO CORRECT FOR THIS.
12500           MOV     B,C             ;GET NUMBER IN B,H,L
12520           XCHG
12540           XRA     A               ;ZERO C,D,E AND HIGHEST ORDER
12560           MOV     C,A
12580           MOV     D,A
12600           MOV     E,A
12620           STA     FDIVG+1
12640   FDIV1:  PUSH    H               ;SAVE LO'S OF NUMBER
12660           PUSH    B               ;SAVE HO OF NUMBER
12680           MOV     A,L             ;SUBTRACT NUMBER THAT WAS IN FAC
12700   FDIVC:  SUI     0               ;SUBTRACT LO
12720           MOV     L,A             ;SAVE IT
12740           MOV     A,H             ;SUBTRACT MIDDLE ORDER
12760   FDIVB:  SBI     0
12780           MOV     H,A
12800           MOV     A,B             ;SUBTRACT HO
12820   FDIVA:  SBI     0
12840           MOV     B,A
12860   FDIVG:  MVI     A,0             ;GET HIGHEST ORDER
12880           SBI     0               ;SUBTRACT THE CARRY FROM IT
12900           CMC                     ;SET CARRY TO CORESPOND TO NEXT QUOTIENT BIT
12920           JNC     FDIV2           ;GET OLD NUMBER BACK IF WE SUBTRACTED TOO MUCH
12940           STA     FDIVG+1         ;UDPATE HIGHEST ORDER
12960           POP     PSW             ;THE SUBTRACTION WAS GOOD
12980           POP     PSW             ;GET PREVIOUS NUMBER OFF STACK
13000           STC                     ;NEXT BIT IN QUOTIENT IS A ONE
13020           XWD     1000,322        ;"JNC" AROUND NEXT 2 BYTES
13040   FDIV2:  POP     B               ;WE SUBTRACTED TOO MUCH
13060           POP     H               ;GET OLD NUMBER BACK
13080           MOV     A,C             ;ARE WE DONE?
13100           INR     A               ;SET SIGN FLAG WITHOUT AFFECTING CARRY
13120           DCR     A
13140           RAR                     ;PUT CARRY IN MSB
13160           JM      ROUNDB          ;WE ARE DONE
13180           RAL                     ;WE AREN'T, GET OLD CARRY BACK
13200   IFE     LENGTH,<
13220           CALL    SHFTLD>         ;ROTATE EVERYTHING LEFT ONE
13240   IFN     LENGTH,<
13260           MOV     A,E             ;ROTATE EVERYTHING LEFT ONE
13280           RAL                     ;ROTATE NEXT BIT OF QUOTIENT IN
13300           MOV     E,A
13320           MOV     A,D
13340           RAL
13360           MOV     D,A
13380           MOV     A,C
13400           RAL
13420           MOV     C,A>
13440           DAD     H               ;ROTATE A ZERO INTO RIGHT END OF NUMBER
13460           MOV     A,B             ;THE HO BYTE, FINALLY!
13480           RAL
13500           MOV     B,A
13520           LDA     FDIVG+1         ;ROTATE THE HIGHEST ORDER
13540           RAL
13560           STA     FDIVG+1
13580           MOV     A,C             ;ADD ONE TO EXPONENT IF THE FIRST SUBTRACTION
13600           ORA     D               ; DID NOT WORK
13620           ORA     E
13640           JNZ     FDIV1           ;THIS ISN'T THE CASE
13660           PUSH    H               ;SAVE PART OF NUMBER
13680           LXI     H,FAC           ;GET POINTER TO FAC
13720           OCR     M               ;DECREMENT EXPONENT
13740           POP     H               ;GET NUMBER BACK
13760           JNZ     FDIV1           ;DIVIDE MORE IF NO OVERFLOW OCCURED
13760           JMP     OVERR           ;OVERFLOW!!
13820           ;CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV
13840           ;ALTERS A,B,H,L
13860   IFE     LENGTH-2,<
13880   MULDVS: A       377             ;ENTRY FROM DDIV, SUBTRACT EXPONENTS
13900           XWD     1000,056        ;"MVI   L" AROUND NEXT BYTE
13920   MULDVA: XRA     A               ;ENTRY FROM DMULT, ADD EXPONENTS
13940           LXI     H,ARG-1         ;GET POINTER TO SIGN AND HO OF ARG
13960           MOV     C,M             ;GET HO AND SIGN FOR UNPACKING
13980           INX     H               ;INCREMENT POINTER TO EXPONENT
14000           MOV     B,M             ;GET EXPONENT FOR BELOW
14020           MOV     L,A>            ;SAVE ADD OR SUBTRACT FLAG
14040   MULDIV: MOV     A,B             ;IS NUMBER IN REGISTERS ZERO?
14060           ORA     A
14080           JZ      MULDV2          ;IT IS, ZERO FAC AND WE ARE DONE
14100           MOV     A,L             ;GET ADD OR SUBTRACT FLAG
14120           LXI     H,FAC           ;GET POINTER TO EXPONENT
14140           XRA     M               ;GET EXPONENT
14160           ADD     B               ;ADD IN REGISTER EXPONENT
14180           MOV     B,A             ;SAVE IT
14200           RAR                     ;CHECK FOR OVERFLOW
14220           XRA     B               ;OVERFLOW IF SIGN IS THE SAME AS CARRY
14240           MOV     A,B             ;GET SUM
14260           JP      MULDV1          ;WE HAVE OVERFLOW!!
14280           ADI     200             ;PUT EXPONENT IN EXCESS 200
14300           MOV     M,A             ;SAVE IT IN THE FAC
14320           JZ      POPHRT          ;WE HAVE UNDERFLOW!! RETURN.
14340           CALL    UNPACK          ;UNPACK THE ARGUMENTS
14360           MOV     M,A             ;SAVE THE NEW SIGN
14380           DCX     H               ;POINT TO EXPONENT
14400           RET                     ;ALL DONE, ELAVE HO IN A
14420   IFN     EXTFNC,<
14440   MLDVEX: FSIGN                   ;ENTRY FROM EXP, PICK UNDERFLOW IF NEGATIVE
14460           CMA                     ;PICK OVERFLOW IF POSITIVE
14480           POP     H>              ;DON'T SCREW UP STACK
14500   MULDV1: ORA     A               ;IS ERROR OVERFLOW OR UNDERFLOW?
14520   MULDV2: POP     H               ;GET OLD RETURN ADDRESS OFF STACK
14540   IFE     LENGTH,<
14560           JM      OVERR           ;OVERFLOW
14580                                   ;UNDERFLOW -- FALL INTO ZERO
14600
14620
14640           ;ZERO FAC
14660           ;ALTERS A ONLY
14680           ;EXITS WITH A=0
14700   ZERO:   XRA     A               ;ZERO A
14720           STA     FAC             ;ZERO FAC
14740           RET>                    ;ALL DONE
14800   IFN     LENGTH,<
14820           JP      ZERO            ;UNDERFLOW
14840           JMP     OVERR>          ;OVERFLOW
14900           ;MULTIPLY FAC BY 10
14920           ;ALTERS A,B,C,D,E,H,L
14940   MUL10:  CALL    MOVRF           ;GET NUMBER IN REGISTERS
14960           MOV     A,B             ;GET EXPONENT
14980           ORA     A               ;RESULT IS ZERO IF ARG IS ZERO
15000           RZ                      ;IT IS
15020           ADI     2               ;MULTIPLY BY 4 BY ADDING 2 TO EXPONENT
15040           JC      OVERR           ;OVERFLOW!!
15060           MOV     B,A             ;RESTORE EXPONENT
15080           CALL    FADD            ;ADD IN ORIGINAL NUMBER TO GET 5 TIMES IT
15100           LCI     H,FAC           ;ADD 1 TO EXPONENT TO MULTIPLY NUMBER BY
15120           INR     M               ; 2 TO GET 10 TIMES ORIGINAL NUMBER
15140           RNZ                     ;ALL DONE IF NO OVERFLOW
15160           JMP     OVERR           ;OVERFLOW
15180   PAGE
15200   SUBTTL  SIGN, SGN, FLOAT, NEG AND ABS
15220           ;PUT SIGN OF FAC IN A
15240           ;ALTERS A ONLY
15260           ;LEAVES FAC ALONE
15280           ;NOTE: TO TAKE ADVANTAGE OF THE RST INSTRUCTIONS TO SAVE BYTES,
15300           ;FSIGN IS DEFINED TO BE AN RST.  "FSIGN" IS EQUIVALENT TO "CALL SIGN"
15320           ;THE FIRST FEW INSTRUCTIONS OF SIGN (THE ONES BEFORE SIGNC) ARE DONE
15340           ;IN THE 8 BYTES AT THE RST LOCATION.
15360   REPEAT  0,<                     ;FSIGN IS ALWAYS AN RST
15380   SIGN:   LDA     FAC             ;CHECK IF THE NUMBER IS ZERO
15400           ORA     A
15420           RZ>                     ;IT IS, A IS ZERO
15440   SIGNC:  LDA     FAC-1           ;GET SIGN OF FAC, IT IS NON-ZERO
15460           XWD     1000,376        ;"CPI" AROUND NEXT BYTE
15480   FCOMPS: CMA                     ;ENTRY FROM FCOMP, COMPLEMENT SIGN
15500   ICOMPS: RAL                     ;ENTRY FROM ICOMP, PUT SIGN BIT IN CARRY
15520   SIGNS:  SBB     A               ;A=0 IF CARRY WAS 0, A=377 IF CARRY WAS 1
15540           RNZ                     ;RETURN IF NUMBER WAS NEGATIVE
15560   INRART: INR     A               ;PUT ONE IN A IF NUMBER WAS POSITIVE
15580           RET                     ;ALL DONE
15640           ;SGN FUNCTION
15660           ;ALTERS A,B,C,D,E,H,L
15680   IFN     LENGTH-2,<
15700   SGN:    FSIGN>                  ;GET SIGN OF FAC IN A
15720                                   ;FALL INTO FLOAT
15780           ;FLOAT THE SIGNED INTEGER IN A
15800           ;ALTERS A,B,C,D,E,H,L
15820   FLOAT:  MVI     0,210           ;SET EXPONENT CORRECTLY
15840           LXI     D,$CODE         ;ZERO D,E
15860                                   ;FALL INTO FLOATR
15920           ;FLOAT THE SIGNED NUMBER IN B,A,D,E
15940           ;ALTERS A,B,C,D,E,H,L
15960   FLOATR: LXI     H,FAC           ;GET POINTER TO FAC
15980           MOV     C,A             ;PUT HO IN C
16000           MOV     M,B             ;PUT EXPONENT IN THE FAC
16020           MVI     B,0             ;ZERO OVERFLOW BYTE
16040           INX     H               ;POINT TO SIGN
16060           MVI     M,200           ;ASSUME A POSITIVE NUMBER
16080           RAL                     ;PUT SIGN IN CARRY
16100           JMP     FADFLT          ;GO AND FLOAT THE NUMBER
16160           ;ABSOLUTE VALUE OF FAC
16180           ;ALTERS A,H,L
16200   ABS:
16220   IFE     LENGTH-2,<
16240           CPI     2               ;IS THE ARGUMENT AN INTEGER?
16260           JZ      IABS>           ;YES, USE THE INTEGER ABSOLUTE VALUE
16280           FSIGN                   ;GET THE SIGN OF FAC
16300           RP                      ;ALL DONE IF IT IS POSITIVE
16320                                   ;FALL INTO NEG
16380           ;NEGATE NUMBER IN THE FAC
16400           ;ALTERS A,H,L
16420           ;NOTE: THE NUMBER MUST BE PACKED
16440   NEG:    LXI     H,FAC-1         ;GET POINTER TO SIGN
16460           MOV     A,M             ;GET SIGN
16480           XRI     200             ;COMPLEMENT SIGN BIT
16500           MOV     M,A             ;SAVE IT
16520           RET                     ;ALL DONE
16580   IFE     LENGTH-2,<
16600           ;NEGATE ANY TYPE VALUE IN THE FAC
16620           ;ALTERS A,B,C,D,E,H,L
16640   VNEG:   LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
16660           CPI     2
16680           JZ      INEG            ;WE HAVE AN INTEGER, NEGATE IT THAT WAY
16700           JM      TMERR           ;SLOW UP ON STRINGS
16720           JMP     NEG             ;NEGATE SNG AND DBL THE SAME
16740
16760
16780           ;SGN FUNCTION
16800           ;ALTERS A,H,L
16820   SGN:    CALL    VSIGN           ;GET THE SIGN OF THE FAC IN A
16840           MOV     L,A             ;PUT IT IN THE LO POSITION
16860           RAL                     ;EXTEND THE SIGN TO THE HO
16880           SBB     A
16900           MOV     H,A
16920           JMP     CONISS          ;RETURN THE RESULT AND SET VALTYP
16940
16960
16980           ;GET THE SIGN OF THE VALUE IN THE FAC IN A
17000           ;ASSUMES A HAS THE VALTYP WHEN CALLED
17020           ;ALTERS A,H,L
17040   VSIGN:  CPI     2               ;IS THE ARGUMENT AN INTEGER?
17060           JNZ     SIGN            ;NO, SINGLE AND DOUBLE PREC. WORK THE SAME
17080           LHLD    FACLO           ;GET THE INTEGER ARGUMENT
17100           MOV     A,H             ;GET ITS SIGN
17120           ORA     L               ;CHECK IF THE NUMBER IS ZERO
17140           RZ                      ;IT IS, WE ARE DONE
17160           MOV     A,H             ;IT ISN'T SIGN IS THE SIGN OF H
17180           JMP     ICOMPS>         ;GO SET A CORRECTLY
17200   PAGE
17220   SUBTTL  FLOATING POINT MOVEMENT ROUTINES
17240           ;PUT FAC ON STACK
17260           ;ALTERS D,E
17280   PUSHF:  XCHG                    ;SAVE (HL)
17300           LHLD    FACLO           ;GET LO'S
17320           XTHL                    ;SWITCH LO'S AND RET ADDR
17340           PUSH    H               ;PUT RET ADDR BACK ON STACK
17360           LHLD    FAC-1           ;GET HO'S
17380           XTHL                    ;SWITCH HO'S AND RET ADDR
17400           PUSH    H               ;PUT RET ADDR BACK ON STACK
17420           XCHG                    ;GET OLD (HL) BACK
17440           RET                     ;ALL DONE
17500           ;MOVE NUMBER FROM MEMORY [(HL)] TO FAC
17520           ;ALTERS B,C,D,E,H,L
17540           ;AT EXIT NUMBER IS IN B,C,D,E
17560           ;AT EXIT (HL):=(HL)+4
17580   MOVFM:  CALL    MOVRM           ;GET NUMBER IN REGISTERS
17600                                   ;FALL INTO MOVFR AND PUT IT IN FAC
17660           ;MOVE REGISTERS (B,C,D,E) TO FAC
17680           ;ALTERS D,E
17700   MOVFR:  XCHG                    ;GET LO'S IN (HL)
17720           CHLD    FACLO           ;PUT THEM WHERE THEY BELONG
17740           MOV     H,B             ;GET HO'S IN (HL)
17760           MOV     L,C
17780           SHLD    FAC-1           ;PUT HO'S WHERE THEY BELONG
18000           XCHG                    ;GET OLD (HL) BACK
18020           RET                     ;ALL DONE
17880           ;MOVE FAC TO REGISTERS (B,C,D,E)
17900           ;ALTERS B,C,D,E,H,L
17920   MOVRF:  LXI     H,FACLO         ;GET POINTER TO FAC
17940                                   ;FALL INTO MOVRM
18000           ;GET NUMBER IN REGISTERS (B,C,D,E) FROM MEMORY [(HL)]
18020           ;ALTERS B,C,D,E,H,L
18040           ;AT EXIT (HL):=(HL)+4
18060   MOVRM:  MOV     E,M             ;GET LO
18080           INX     H               ;POINT TO MO
18100           MOV     D,M             ;GET MO
18120           INX     H               ;POINT TO HO
18140           MOV     C,M             ;GET HO
18160           INX     H               ;POINT TO EXPONENT
18180           MOV     B,M             ;GET EXPONENT
18200   INXHRT: INX     H               ;INC POINTER TO BEGINNING OF NEXT NUMBER
18220           RET                     ;ALL DONE
18280           ;MOVE NUMBER FROM FAC TO MEMORY[(HL)]
18300           ;ALTERS A,B,D,E,H,L
18320   MOVMF:  LXI     D,FACLO         ;GET POINTER TO FAC
18340                                   ;FALL INTO MOVE
18400           ;MOVE NUMBER FROM (DE) TO (HL)
18420           ;ALTERS A,B,D,E,H,L
18440           ;EXITS WITH (DE):=(DE)+4
18460   MOVE:   MVI     B,4             ;SET COUNTER
18480   IFE     LENGTH-2,<
18500           XWD     1000,076        ;"MVI   A" OVER NEXT BYTE
18520   MOVVFM: XCHG>                   ;MOVE NUMBERS INTO THE FAC
18540   MOVE1:  LDAX    D               ;GET WORD ENTRY FROM VMOVMF
18560           MOV     M,A             ;PUT IT WHERE IT BELONGS
18580           INX     D               ;INCREMENT POINTERS TO NEXT WORD
18600           INX     H
18620           DCR     B               ;SEE IF DONE
18640           JNZ     MOVE1
18660           RET
18720           ;UNPACK THE FAC AND THE REGISTERS
18740           ;ALTERS A,C,H,L
18760           ;WHEN THE NUMBER IN THE FAC IS UNACKED, THE ASSUMED ONE IN THE
18780           ;MANTISSA IS RESTORED, AND THE COMPLEMENT OF THE SIGN IS PLACED
18800           ;IN FAC+1
18820   UNPACK: LXI     H,FAC-1         ;POINT TO HO AND SIGN
18840           MOV     A,H             ;GET HO AND SIGN
18860           PUSH    PSW             ;SAVE SIGN
18880           ORA     200             ;RESTORE THE HIDDEN ONE
18900           MOV     M,A             ;SAVE HO
18920           POP     PSW             ;GET SIGN
18940           XRA     M               ;GET COMPLEMENT OF SIGN IN MSB
18960           INX     H               ;POINT TO TEMPORARY SIGN BYTE
18980           INX     H
19000           MOV     M,A             ;SAVE COMPLEMENT OF SIGN
19020           MOV     A,C             ;GET HO AND SIGN OF THE REGISTERS
19040           PUSH    PSW             ;SAVE SIGN
19060           ORI     200             ;RESTORE THE HIDDEN ONE
19080           MOV     C,A             ;SAVE THE HO
19100           POP     PSW             ;GET THE SIGN BACK
19120           XRA     M               ;COMPARE SIGN OF FAC AND SIGN OF REGISTERS
19140           RET                     ;ALL DONE
19200   IFE     LENGTH-2,<
19220   REPEAT  0,<                     ;VPUSHF WILL BE IN-LINE IN F3
19240           ;PUT ANY TIME VALUE ON THE STACK FROM FAC
19260           ;STRINGS ARE TREATED AS INTEGERS
19280           ;ALTERS A,B,C,H,L
19300   VPUSHF: LDA     VALTYP          ;GET THE VALUE TYPE
19320           CPI     4               ;SET FLAGS ACCORDING TO VALTYP
19340           LXI     H,FACLO         ;GET POINTER TO LO IN FAC
19360           PUSHM                   ;PUSH FACLO+0,1 ON THE STACK
19380           JM      VPUSHD          ;RETURN IF THE DATA WAS AN INTEGER OR A STRING
19400           PUSHM                   ;PUSH FAC-1,0 ON THE STACK
19420           JZ      VPUSHD          ;RETURN IF WE HAD A SINGLE PRECISION NUMBER
19440           LXI     D,DFACLO        ;WE HAVE A DOUBLE PRECISON NUMBER
19460           PUSHM                   ;PUSH ITS 4 LO BYTES ON THE STACK
19480           PUSHM
19500   VPUSHD:>                        ;ALL DONE
19520
19540
19560           ;MOVE ANY TYPE VALUE FROM MEMORY [(HL)] TO FAC
19580           ;ALTERS A,B,D,E,H,L
19600   VMOVFA: LXI     H,ARGLO         ;ENTER FROM DADD, MOVE ARG TO FAC
19620   VMOVFM: LXI     D,MOVVFM        ;GET ADDRESS OF LOCATION THAT DOES
19640           JMP     VMVVFM          ; AN "XCHG" AND FALLS INTO MOVE1:
19660
19680
19700           ;MOVE ANY TYPE VALUE FROM FAC TO MEMORY [(HL)]
19720           ;ALTERS A,B,D,E,H,L
19740   VMOVAF: LXI     H,ARGLO         ;ENTRY FROM FIN, DMUL10, DDIV10
19760                                   ;MOVE FAC TO ARG
19780   VMOVMF: LXI     D,MOVE1         ;GET ADDRESS OF MOVE SUBROUTINE
19800   VMVVFM: PUSH    D               ;SHOVE IT ON THE STACK
19820           LXI     D,FACLO         ;GET FIRST ADDRESS FROM INT, SNG
19840           LDA     VALTYP          ;GET THE VALUE TYPE
19860           ANI     177             ;STRINGS LOOK LIKE REALS
19880           MOV     B,A             ;SET UP THECOUNT
19900           CPI     10              ;DO WE HAVE DBL?
19920           RNZ                     ;WE DO NOT, GO DO THE MOVE
19940           LXI     D,DFACLO        ;WE DO, GET LO ADDR OF THE DBL DUMBER
19960           RET>                    ;GO DO THE MOVE
19980   PAGE
20000   SUBTTL  COMPARE TWO NUMBERS
20020           ;COMPARE TWO SINGLE PRECISION NUMBERS
20040           ;A=1 IF ARG .LT. FAC
20060           ;A=0 IF ARG=FAC
20080           ;A=-1 IF ARG .GT. FAC
20100           ;DOREL DEPENDS UPON THE FACT THAT FCOMP RETURNS
20120           ; IFF A HAS 377
20140           ;ALTERS A,H,L
20160   FCOMP:  MOV     A,B             ;CHECK IF ARG IS ZERO
20180           ORA     A
20200           JZ      SIGN
20220           LXI     H,FCOMPS        ;WE JUMP TO FCOMPS WHEN WE ARE DONE
20240           PUSH    H               ;PUT THE ADDRESS ON THE STACK
20260           FSIGN                   ;CHECK IF FAC IS ZERO
20280           MOV     A,C             ;IF IT IS, RESULT IS MINUS THE SIGN OF ARG
20300           RZ                      ;IT IS
20320           LXI     H,FAC-1         ;POINT TO SIGN OF FAC
20340           XRA     M               ;SEE IF THE SIGNS ARE THE SAME
20360           MOV     A,C             ;IF THEY ARE DIFFERENT, RESULT IS SIGN OF ARG
20380           RM                      ;THEY ARE DIFFERENT
20400           CALL    FCOMP2          ;CHECK THE REST OF THE NUMBER
20420   FCOMPD: RAR                     ;NUMBERS ARE DIFFERENT, CHANGE SIGN IF
20440           XRA     C               ; BOTH NUMBERS ARE NEGATIVE
20460           RET                     ;GO SET UP A
20500   FCOMP2: INX     H               ;POINT TO EXPONENT
20520           MOV     A,B             ;GET EXPONENT OF ARG
20540           CMP     M               ;COMPARE THE TWO
20560           RNZ                     ;NUMBERS ARE DIFFERENT
20580           DCX     H               ;POINT TO HO
20600           MOV     A,C             ;GET HO OF ARG
20620           CMP     M               ;COMPARE WITH HO OF FAC
20640           RNZ                     ;THEY ARE DIFFERENT
20660           DCX     H               ;POINT TO MO OF FAC
20680           MOV     A,D             ;GET MO OF ARG
20700           CMP     M               ;COMPARE WITH MO OF FAC
20720           RNZ                     ;THE NUMBERS ARE DIFFERENT
20740           DCX     H               ;POINT TO LO OF FAC
20760           MOV     A,E             ;GET LO OF ARG
20780           SUB     M               ;SUBTRACT LO OF ARG
20700           RNZ                     ;NUMBERS ARE DIFFERENT
20820           POP     H               ;NUMBERS ARE THE SAME, DON'T SCREW UP STACK
20840           POP     H
20860           RET                     ;ALL DONE
20900
20920   IFE     LENGTH-2,<
20940           ;COMPARE TWO INTEGERS
20960           ;A=1 IF (DE) .LT. (HL)
20980           ;A=0 IF (DE)=(HL)
21000           ;A=-1 IF (DE) .GT. (HL)
21020           ;ALTERS A ONLY
21040   ICOMP:  MOV     A,D             ;ARE THE SIGNS THE SAME
21060           XRA     H
21080           MOV     A,H             ;IF NOT, ANSWER IS THE SIGN OF (HL)
21100           JM      ICOMPS          ;THEY ARE DIFFERENT
21120           CMP     D               ;THEY ARE THE SAME, COMPARE THE HO'S
21140           JNZ     SIGNS           ;GO SET UP A
21160           MOV     A,L             ;COMPARE THE LO'S
21180           SUB     E
21200           JNZ     SIGNS           ;GO SET UP A
21220           RET                     ;ALL DONE, THEY ARE THE SAME
21240
21260
21280           ;COMPARE TWO DOUBLE PRECISION NUMBERS
21300           ;A=1 IF ARG .LT. FAC
21320           ;A=0 IF ARG=FAC
21340           ;A=-1 IF ARG .GT. FAC
21360           ;ALTERS A,B,C,D,E,H,L
21380   DCOMPD: LXI     H,ARGLO         ;ENTRY WITH POINTER TO ARG IN (DE)
21400           MVI     B,10            ;SET UP COUNT TO MOVE DBL NUMBERS
21420           CALL    MOVE1           ;MOVE THE ARGUMENT INTO ARG
21440   DCOMP:  LXI     D,ARG           ;GET POINTER TO ARG
21460           LDAX    D               ;SEE IF ARG=0
21480           ORA     A
21500           JZ      SIGN            ;ARG=0, GO SET UP A
21520           LXI     H,FCOMPS        ;PUSH FCOMPS ON STACK SO WE WILL RETURN TO
21540           PUSH    H               ; TO IT AND SET UP A
21560           FSIGN                   ;SEE IF FAC=0
21580           DCX     D               ;POINT TO SIGN OF ARG
21600           LDAX    D               ;GET SIGN OF ARG
21620           MOV     C,A             ;SAVE IT FOR LATER
21640           RZ                      ;FAC=0, SIGN OF RESULT IS SIGN OF ARG
21660           LXI     H,FAC-1         ;POINT TO SIGN OF FAC
21680           XRA     M               ;SEE IF THE SIGNS ARE THE SAME
21700           MOV     A,C             ;IF THEY ARE, GET THE SIGN OF THE NUMBERS
21720           RM                      ;THE SIGNS ARE DIFFERENT, GO SET A
21740           INX     D               ;POINT BACK TO EXPONENT OF ARG
21760           INX     H               ;POINT TO EXPONENT OF FAC
21780           MVI     B,10            ;SET UP A COUNT
21800   DCOMP1: LDAX    D               ;GET A BYTE FROM ARG
21820           SUB     M               ;COMPARE IT WITH THE FAC
21840           JNZ     FCOMPD          ;THEY ARE DIFFERENT, GO SET UP A
21860           DCX     D               ;THEY ARE THE SAME, EXAMINE THE NEXT LOWER
21880           DCX     H               ; ORDER BYTES
21900           DCR     B               ;ARE WE DONE?
21920           JNZ     DCOMP1          ;NO, COMPARE THE NEXT BYTES
21940           POP     B               ;THEY ARE THE SAME, GET FCOMPS OFF STACK
21960           RET>                    ;ALL DONE
21980   PAGE
22000   SUBTTL  CONVERSION ROUTINES BETWEEN INTEGER, SINGLE AND DOUBLE PRECISION
22020   IFE     LENGTH-2,<
22040           ;FORCE THE FAC TO BE AN INTEGER
22060           ;ALTERS A,B,C,D,E,H,L
22080   FRCINT: LDA     VALTYP          ;SEE WHAT WE HAVE
22100           CPI     4
22120           LHLD    FACLO           ;GET FACLO+0,1 IN CASE WE HAVE AN INTEGER
22140           RC                      ;WE HAVE AN INTEGER, ALL DONE
22160           JM      TMERR           ;WE HAVE A STRING, THAT IS A "NO-NO"
22180           CNZ     CONSD           ;IF WE HAVE A DBL, CONVERT IT TO A SNG
22200           LXI     H,OVERR         ;PUT OVERR ON THE STACK SO WE WILL GET ERROR
22220           PUSH    H               ; IF NUMBER IS TOO BIG
22240                                   ;FALL INTO CONIS
22260
22280
22300           ;CONVERT SINGLE PRECISION NUMBER TO INTEGER
22320           ;ALTRS A,B,C,D,E,H,K
22340   CONIS:  LDA     FAC             ;GET THE EXPONENT
22360           CPI     220             ;SEE IF IT IS TOO BIG
22380           JNC     CONIS2          ;IT IS, BUT IT MIGHT BE -32768
22400           CALL    QINT            ;IT ISN'T, CONVERT IT TO AN INTEGER
22420           XCHG                    ;PUT IT IN (HL)
22440   CONIS1: POP     D               ;GET ERROR ADDRESS OFF STACK
22460           ;ENTRY FROM SGN, FIN, LINPRT
22480   CONISS: SHLD    FACLO           ;STORE THE NUMBER IN FACLO
22500           MVI     A,2             ;SET VALTYP TO "INTEGER"
22520   CONISD: STA     VALTYP          ;ENTRY FROM CONDS
22540           RET                     ;ALL DONE
22560   CONIS2: MOVRI   220,200,000,000 ;CHECK IF NUMBER IS -32768, ENTRY FROM FIN
22580           CALL    FCOMP
22600           RNZ                     ;ERROR:  IT CAN'T BE CONVERTED TO AN INTEGER
22620           MOV     H,C             ;IT IS -32768, PUT IT IN (HL)
22640           MOV     L,D
22660           JMP     CONIS1          ;STORE IT IN THE FAC AND SET VALTYP
22680
22700
22720           ;FORCE THE FAC TO BE A SINGLE PRECISION NUMBER
22740           ;ALTERS A,B,C,D,E,H,L
22760   FRCSNG: LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
22780           CPI     4
22800           RZ                      ;WE ALREADY HAVE AN INTEGER, ALL DONE
22820           JC      CONSI           ;WE HAVE AN INTEGER, CONVERT IT
22840           JM      TMERR           ;STRINGS!! -- ERROR!!
22860                                   ;DBL PREC -- FALL INTO CONSD
22880
22900
22920           ;CONVERT DOUBLE PRECISION NUMBER TO A SINGLE PRECISION ONE
22940           ;ALTERS A,B,C,D,E,H,L
22960   CONSD:  CALL    MOVRF           ;GET THE HO'S IN THE REGISTERS
22980           MVI     A,4             ;SET VALTYP TO "SINGLE PRECISION"
23000           STA     VALTYP
23020           MOV     A,B             ;CHECK IF THE NUMBER IS ZERO
23040           ORA     A
23060           RZ                      ;IF IT IS, WE ARE DONE
23080           CALL    UNPACK          ;UNPACK THE NUMBER
23100           LXI     H,FACLO-1       ;GET FIRST BYTE BELOW A SNG NUMBER
23120           MOV     B,M             ;PUT IT IN B FOR ROUND
23140           JMP     ROUND           ;ROUND THE DBL NUMBER UP AND WE ARE DONE
23160
23180
23200           ;CONVERT AN INTEGER TO A SINGLE PRECISION NUMBER
23220           ;ALTERS A,B,C,D,E,H,L
23240   CONSI:  LHLD    FACLO           ;GET THE INTEGER
23260   CONSIH: MVI     A,4             ;SET VALTYP TO "SINGLE PRECISION"
23280           STA     VALTYP
23300           MOV     A,H             ;SET UP REGISTERS FOR FLOATR
23320           MOV     D,L
23340           MVI     E,0
23360           MVI     B,220
23380           JMP     FLOATR          ;GO FLOAT THE NUMBER
23400
23420
23440           ;FORCE THE FAC TO BE A DOUBLE PRECISION NUMBER
23460           ;ALTERS A,B,C,D,E,H,L
23480   FRCDBL: LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
23500           CPI     10
23520           RZ                      ;WE ALREADY HAVE A DBL, WE ARE DONE
23540           JNC     TMERR           ;GIVE AN ERROR IF WE HAVE A STRING
23560           CPI     2               ;SEE IF WE HAVE A SNG OR INT
23580           CZ      CONSI           ;CONVERT TO SNG IF WE HAVE AN INT
23600                                   ;FALL INTO CONDS AND CONVERT TO DBL
23620
23640
23660           ;CONVERT A SINGLE PRECISION NUMBER TO A DOUBLE PRECISION ONE
23680           ;ALTERS A,H,L
23700   CONDS:  LXI     H,$CODE         ;ZERO H,L
23720           SHLD    DFACLO          ;CLEAR THE FOUR LOWER BYTES IN THE DOUBLE
23740           SHLD    DFACLO+2        ; PRECISION NUMBER
23760           MVI     A,10            ;SET VALTYP TO "DOUBLE PRECISION"
23780           JMP     CONISD          ;GO FOR IT
23800   PAGE
23820   SUBTTL  GREATEST INTEGER FUNCTION
23840           ;QUICK GREATEST INTEGER FUNCTION
23860           ;LEAVES INT(FAC) IN C,D,E (SIGNED)
23880           ;ASSUMES FAC .LT. 2^23 = 8388608
23900           ;ASSUMES THE EXPONENT OF FAC IS IN A
23920           ;ALTERS A,B,C,D,E
23940   QINT:   MOV     B,A             ;ZERO B,C,D,E IN CASE THE NUMBER IS ZERO
23960           MOV     C,A
23980           MOV     D,A
24000           MOV     E,A
24020           ORA     A               ;SET CONDITION CODES
24040           RZ                      ;IT IS ZERO, WE ARE DONE
24080   ;THE HARD CASE IN QINT IS NEGATIVE NON-INTEGERS.  TO HANDLE THIS, IF THE
24100   ;NUMBER IS NEGATIVE, WE REGARD THE 3-BYTE MANTISSA AS A 3-BYTE INTEGER AND
24120   ;SUBTRACT ONE.  THEN ALL THE FRACTIONAL BITS ARE SHIFTED OUT BY SHIFTING THE
24140   ;MANTISSA RIGHT.  THEN, IF THE NUMBER WAS NEGATIVE, WE ADD ONE.  SO, IF WE
24160   ;HAD A NEGATIVE INTEGER, ALL THE BITS TO THE RIGHT OF THE BINARY POINT WERE
24180   ;ZERO.  SO THE NET EFFECT IS WE HAVE THE ORIGINAL NUMBER IN C,D,E.  IF THE
24200   ;NUMBER WAS A NEGATIVE NON-INTEGER, THERE IS AT LEAST ONE NON-ZERO BIT TO THE
24220   ;RIGHT OF THE BINARY POINT.  SO THE NET EFFECT IS THAT WE GET THE ABSOLUTE
24240   ;VALUE OF INT(FAC) IN C,D,E/  C,D,E IS THEN NEGATED IF THE ORIGINAL NUMBER WAS
24260   ;NEGATIVE SO THE RESULT WILL BE SIGNED.
24280           PUSH    H               ;SAVE (HL)
24300           CALL    MOVRF           ;GET NUMBER IN THE REGISTERS
24320           CALL    UNPACK          ;UNPACK THE NUMBER
24340           XRA     M               ;GET SIGN OF NUMBER
24360           MOV     H,A             ;DON'T LOSE IT
24380           CM      QINTA           ;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
24400           MVI     A,230           ;SEE HOW MANY WE HAVE TO SHIFT TO CHANGE
24420           SUB     B               ; NUMBER TO AN INTEGER
24440           CALL    SHIFTR          ;SHIFT NUMBER TO GET RID OF FRACTIONAL BITS
24460           MOV     A,H             ;GET SIGN
24480           RAL                     ;PUT SIGN IN CARRY SO IT WILL NOT BE CHANGED
24500           CC      ROUNDA          ;IF NUMBER WAS NEGATIVE, ADD ONE
24520           MVI     B,0             ;FORGET THE BITS WE SHIFTED OUT
24540           CC      NEGR            ;NEGATE NUMBER IF IT WAS NEGATIVE BECAUSE WE
24560                                   ; WANT A SIGNED MANTISSA
24580           POP     H               ;GET OLD (HL) BACK
24600           RET                     ;ALL DONE
24640   QINTA:  DCX     D               ;SUBTRACT ONE FROM C,D,E
24660           MOV     A,D             ;WE HAVE TO SUBTRACT ONE FROM C IF
24680           ANA     E               ; D AND E ARE BOTH ALL ONES
24700           INR     A               ;SEE IF BOTH WERE -1
24720           RNZ                     ;THEY WERE NOT, WE ARE DONE
24740   IFN     LENGTH-2,<
24760           DCR     C>              ;THEY WERE, SUBTRACT ONE FROM C
24780   IFE     LENGTH-2,<
24800   DCXBRT: DCX     B>              ;THIS IS FOR BILL.  C WILL NEVER BE ZERO
24820                                   ; (THE MSB WILL ALWAYS BE ONE) SO "DCX  B"
24840                                   ; AND "DCR      A" ARE FUNCTIONALLY EQUIVALENT
24860           RET                     ;ALL DONE
24920           ;GREATEST INTEGER FUNCTION
24940           ;ALTERS A,B,C,D,E,H,L
24960   IFE     LENGTH-2,<
24980   INTFNC: CPI     4               ;SEE WHAT KIND OF NUMBER WE AHVE
25000           RC                      ;IT IS AN INTEGER, ALL DONE
25020           JNZ     DINT            ;CONVERT THE DOUBLE PRECISION NUMBER
25040           CALL    CONIS>          ;TRY TO CONVERT THE NUMBER TO AN INTEGER
25060                                   ;IF WE CAN'T, WE WILL RETURN HERE TO GIVE A
25080                                   ; SINGLE PRECISION RESULT
25100   INT:    LXI     H,FAC           ;GET EXPONENT
25120           MOV     A,M
25140           CPI     230             ;SEE IF NUMBER HAS ANY FRACTIONAL BITS
25160   IFN     EXTFNC,<                ;THE ONLY GUY WHO NEEDS THIS DOESN'T CARE
25180           LDA     FACLO>          ; ABOUT THE SIGN
25200           RNC                     ;IT DOES NOT
25220   IFN     EXTFNC,<
25240           MOV     A,M>            ;GET EXPONENT BACK
25260           CALL    QINT            ;IT DOES, SHIFT THEM OUT
25280           MVI     M,230           ;CHANGE EXPONENT SO IT WILL BE CORRECT
25300                                   ; AFTER NORMALIZATION
25320   IFN     EXTFNC,<
25340           MOV     A,E             ;GET LO
25360           PUSH    PSW>            ;SAVE IT
25380           MOV     A,C             ;NEGATE NUMBER IF IT IS NEGATIVE
25400           RAL                     ;PUT SIGN IN CARRY
25420   IFE     EXTFNC,<
25440           JMP     FADFLT>         ;REFLOAT NUMBER
25460   IFN     EXTFNC,<
25480           CALL    FADFLT          ;REFLOAT NUMBER
25500   POPPRT: POP     PSW             ;GET LO BACK
25520           RET>                    ;ALL DONE
25580   IFE     LENGTH-2,<
25600           ;GREATEST INTEGER FUNCTION FOR DOUBLE PRECISION NUMBERS
25620           ;ALTERS A,B,C,D,E,H,L
25640   DINT:   LXI     H,FAC           ;GET POINTER TO FAC
25660           MOV     A,M             ;GET EXPONENT
25680           CPI     220             ;CAN WE CONVERT IT TO AN INTEGER?
25700           JC      FRCINT          ;THEN DO SO
25720           JNZ     DINT2           ;CHECK FOR -32768
25740           MOV     C,A             ;SAVE EXPONENT IN C
25760           DCX     H               ;GET POINTER TO SIGN AND HO
25780           MOV     A,M             ;GET SIGN AND HO
25800           XRI     200             ;CHECK IF IT IS 200
25820           MVI     B,6             ;SET UP A COUNT TO CHECK IF THE REST OF
25840   DINT1:  DCX     H               ; THE NUMBER IS ZERO, POINT TO NEXT BYTE
25860           ORA     M               ;IF ANY BITS ARE NON-ZERO, A WILL BE NON-ZERO
25880           DCR     B               ;ARE WE DONE?
25900           JNZ     DINT1           ;NO, CHECK THE NEXT LOWER ORDER BYTE
25920           ORA     A               ;IS A NOW ZERO?
25940           LXI     H,200*400+$CODE ;GET -32768 JUST IN CASE
25960           JZ      CONISS          ;A IS ZERO SO WE AHVE -32768
25980           MOV     A,C             ;GET EXPONENT
26000   DINT2:  CPI     270             ;ARE THERE ANY FRACTIONAL BITS?
26020           RNC                     ;NO, THE NUMBER IS ALREADY AN INTEGER
26040   DINTFO: PUSH    PSW             ;ENTRY FROM FOUR, CARRY IS ZERO IF WE COME
26060                                   ; HERE FROM FOUT
26080           CALL    MOVRF           ;GET HO'S OF NUMBER IN REGISTERS FOR UNPACKING
26100           CALL    UNPACK          ;UNPACK IT
26120           XRA     M               ;GET ITS SIGN BACK
26140           DCX     H               ;SET THE EXPONENT TO NORMALIZE CORRECTLY
26160           MVI     M,270
26180           PUSH    PSW             ;SAVE THE SIGN
26200           CM      DINTA           ;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
26220           MVI     A,270           ;GET HOW MANY VITS WE HAVE TO SHIFT OUT
26240           SUB     B
26260           CALL    DSHFTR          ;SHIFT THEM OUT!!
26280           POP     PSW             ;GET THE SIGN BACK
26300           CM      DROUNA          ;IF NUMBER WAS NEGATIVE, ADD ONE
26320           XRA     A               ;PUT A ZERO IN THE EXTRA LO BYTE SO WHEN
26340           STA     DFACLO-1        ; WE NORMALIZE, WE WILL SHIFT IN ZEROS
26360           POP     PSW             ;IF WE WERE CALLED FROM FOUT, DON'T NORMALIZE
26380           RNC                     ; JUST RETURN
26400           JMP     DNORML          ;RE-FLOAT THE INTEGER
26420
26440   DINTA:  LXI     H,DFACLO        ;SUBTRACT ONE FROM FAC, GET POINTER TO LO
26460   DINTA1: MOV     A,M             ;GET A BYTE OF FAC
26480           DCR     M               ;SUBTRACT ONE FROM IT
26500           ORA     A               ;CONTINUE ONLY IF THE BYTE USED TO BE ZERO
26520           INX     H               ;INCREMENT POINTER TO NEXT BYTE
26540           JZ      DINTA1          ;CONTINUE IF NECESSARY
26560           RET>                    ;ALL DONE
26580   PAGE
26600   SUBTTL  INTEGER ARITHMETIC ROUTINES
26620   IFN     MULDIM&<LENGTH-2>,<
26640           ;TWO BYTE UNSIGNED INTEGER MULTIPLY
26660           ; (HL):=(BC)*(DE)
26680           ;A,D,E,H,L ARE CHANGED
26700   DMULT:  LXI     H,$CODE         ;ZERO PRODUCT REGISTERS
26720           MOV     A,B             ;CHECK IF (BC) IS ZERO
26740           ORA     C               ;IF SO, JUST RETURN, (HL) IS ALREADY ZERO
26760           RZ                      ;THIS IS DONE FOR SPEED
26780           MVI     A,20            ;SET UP A COUNT
26800   DMULT1: DAD     H               ;ROTATE (HL) LEFT ONE
26820           JC      BSERR##         ;CHECK FOR OVERFLOW, IF SO,
26840           XCHG                    ; BAD SUBSCRIPT (BS) ERROR
26860           DAD     H               ;ROTATE (DE) LEFT ONE
26880           XCHG
26900           JNC     DMULT2          ;ADD IN (BC) IF HO WAS 1
26920           DAD     B
26940           JC      BSERR           ;CHECK FOR OVERFLOW
26960   DMULT2: DCR     A               ;SEE IF DONE
26980           JNZ     DMULT1
27000           RET>                    ;ALL DONE
27060   IFE     LENGTH-2,<
27080   COMMENT %
27100           INTEGER ARITHMETIC CONVENTIONS
27120
27140   INTEGER VARIABLES ARE 2 BYTE, SIGNED NUMBERS
27160           THE LOW BYTE COMES FIRST IN MEMORY
27180
27200   CALLING CONVENTIONS:
27220   FOR ONE ARUGMENT FUNCTIONS:
27240           THE ARGUMENT IS IN (HL), THE RESULT IS LEFT IN (HL)
27260   FOR TWO ARGUMENT OPERATIONS:    ;;
27280           THE FIRST ARGUMENT IS IN (DE)
27300           THE SECOND ARGUMENT IS IN (HL)
27320           THE RESULT IS LEFT IN (HL)
27340   IF OVERFLOW OCCURS, THE ARGUMENTS ARE CONVERTED TO SINGLE PRECISION
27360   WHEN INTEGERS ARE STORED IN THE FAC, THEY ARE STORED AT FACLO+0,1
27380   VALTYP(INTEGER)=2
27400   %
27420
27440
27460           ;INTEGER SUBTRACTION    (HL):=(DE)-(HL)
27480           ;ALTERS A,B,C,D,E,H,L
27500   ISUB:   MOV     A,H             ;EXTEND THE SIGN OF (HL) TO B
27520           RAL                     ;GET SIGN IN CARRY
27540           SBB     A
27560           MOV     B,A
27580           CALL    INEGHL          ;NEGATE (HL)
27600           MOV     A,C             ;GET A ZERO
27620           SBB     B               ;NEGATE SIGN
27640           JMP     IADDS           ;GO ADD THE NUMBERS
27660
27680
27700           LINTEGER ADDITION       (HL):=(DE)+(HL)
27720           ;ALTERS A,B,C,D,E,H,L
27740   IADD:   MOV     A,H             ;EXTEND THE SIGN OF (HL) TO B
27760           RAL                     ;GET SIGN IN CARRY
27780           SBB     A
27800   IADDS:  MOV     B,A             ;SAVE THE SIGN
27820           PUSH    H               ;SAVE THE SECOND ARGUMENT IN CASE OF OVERFLOW
27840           MOV     A,D             ;EXTEND THE SIGN OF (DE) TO A
27860           RAL                     ;GET SIGN IN CARRY
27880           SBB     A
27900           DAD     D               ;ADD THE TWO LO'S
27920           ADC     B               ;ADD THE EXTRA HO
27940           RRC                     ;IF THE LSB OF A IS DIFFERENT FROM THE MSB OF
27960           XRA     H               ; H, THEN OVERFLOW OCCURRED
27980           JP      POPPRT          ;NO OVERFLOW, GET OLD (HL) OFF STACK AND WE
28000                                   ; ARE DONE
28020           PUSH    B               ;OVERFLOW -- SAVE EXTENDED SIGN OF (HL)
28040           XCHG                    ;GET (DE) IN (HL)
28060           CALL    CONSIH          ;FLOAT IT
28080           POP     PSW             ;GET SIGN OF (HL) IN A
28100           POP     H               ;GET OLD (HL) BACK
28120           CALL    PUSHF           ;PUT FIRST ARGUMENT ON STACK
28140           XCHG                    ;PUT SECOND ARGUMENT IN (DE) FOR FLOATR;
28160           CALL    INEGAD          ;FLOAT IT
28180           POPR                    ;GET FIRST ARGUMENT OFF STACK
28200           JMP     FADD            ;ADD THE TWO NUMBERS USING SINGLE PRECISION
28220
28240
28260           ;INTEGER MULTIPLICATION         (HL):=(DE)*(HL)
28280           ;ALTERS A,B,C,D,E,H,L
28300   IMULT:  PUSH    H               ;SAVE SECOND ARGUMENT IN CASE OF OVERFLOW
28320           PUSH    D               ;SAVE FIRST ARGUMENT
28340           CALL    IMULDV          ;FIX UP THE SIGNS
28360           PUSH    B               ;SAVE THE SIGN OF THE RESULT
28380           MOV     B,H             ;COPY SECOND ARGUMENT INTO (BC)
28400           MOV     C,L
28420           LXI     H,$CODE         ;ZERO (HL), THAT IS WHERE THE PRODUCT GOES
28440           MVI     A,20            ;SET UP A COUNT
28460   IMULT1: DAD     H               ;ROTATE PRODUCT LEFT ONE
28480           JC      IMULTS          ;CHECK FOR OVERFLOW
28500           XCHG                    ;ROTATE FIRST ARGUMENT LEFT ONE TO SEE IF
28520           DAD     H               ; WE ADD IN (BC) OR NOT
28540           XCHG
28560           JNC     IMULT2          ;DON'T ADD IN ANYTHING
28580           DAD     B               ;ADD IN (BC)
28600           JC      IMULT5          ;CHECK FOR OVERFLOW
28620   IMULT2: DCR     A               ;ARE WE DONE?
28640           JNZ     IMULT1          ;NO, DO IT AGAIN
28660           POP     B               ;WE ARE DONE, GET SIGN OF RESULT
28680           POP     D               ;GET ORIGINAL FIRST ARGUMENT
28700   IMLDIV: MOV     A,H             ;ENTRY FROM IDIV, IS RESULT .GE. 32768?
28720           ORA     A
28740           JM      IMULT3          ;IT IS, CHECK FOR SPECIAL CASE OF -32768
28760           POP     D               ;RESULT IS OK, GET SECOND ARGUMENT OFF STACK
28780           MOV     A,B             ;GET THE SIGN OF RESULT IN A
28800           JMP     INEGA           ;NEGATE THE RESULT IF NECESSARY
28820   IMULT3: XRA     200             ;IS RESULT 32768?
28840           ORA     L               ;NOTE: IF WE GET HERE FROM IDIV, THE RESULT
28860           JZ      IMULT4          ; MUST BE 32768, IT CANNOT BE GREATER
28880           XCHG                    ;IT IS .GT. 32768, WE HAVE OVERFLOW
28900           XWD     1000,001        ;"LXI   B" OVER NEXT 2 BYTES
28920   IMULT5: POP     B               ;GET SIGN OF RESULT OFF STACK
28940           POP     H               ;GET THE ORIGINAL FIRST ARGUMENT
28960           CALL    CONSIH          ;FLOAT IT
28980           POP     H               ;GET THE ORIGINAL SECOND ARGUMENT
29000           CALL    PUSHF           ;SAVE FLOATED FIRST ARUMENT
29020           CALL    CONSIH          ;FLOAT SECOND ARGUMENT
29040   FMULTT: POPR                    ;GET FIRST ARGUMENT OFF STACK, ENTRY FROM POLYX
29060           JMP     FMULT           ;MULTIPLY THE ARGUMENTS USING SINGLE PRECISION
29080   IMULT4: MOV     A,B             ;IS RESUKT +32768 OR -32768?
29100           ORA     A               ;GET ITS SIGN
29120           POP     B               ;DISCARD ORIGINAL SECOND ARGUMENT
29140           RM                      ;THE RESULT SHOULD BE NEGATIVE, IT IS OK
29160           PUSH    D               ;IT IS POSITIVE, SAVE REMAINDER FOR MOD
29180           CALL    CONSIH          ;FLOAT -32768
29200           POP     D               ;GET MOD'S REMAINDER BACK
29220           JMP     NEG             ;NEGATE -32768 TO GET 32768, WE ARE DONE
29240
29260
29280           ;INTEGER DIVISION       (HL):=(DE)/(HL)
29300           ;REMAINDER IS IN (DE), QUOTIENT IN (HL)
29320           ;ALTERS A,B,C,D,E,H,L
29340   IDIV:   MOV     A,H             ;CHECK FOR DIVISION BY ZERO
29360           ORA     L
29380           JZ      DV0ERR          ;WE HAVE DIVISION BY ZERO!!
29400           CALL    IMULDV          ;FIX UP THE SIGNS
29420           PUSH    B               ;SAVE THE SIGN OF THE RESULT
29440           XCHG                    ;GET DENOMINATOR IN (HL)
29460           CALL    INEGHL          ;NEGATE IT
29480           MOV     B,H             ;SAVE NEGATED DENOMINATOR IN (BC)
29500           MOV     C,L
29520           LXI     H,$CODE         ;ZERO WHERE WE DO THE SUBTRACTION
29540           MVI     A,21            ;SET UP A COUNT
29560           PUSH    PSW             ;SAVE IT
29580           ORA     A               ;CLEAR CARRY
29600           JMP     IDIV3           ;GO DIVIDE
29620   IDIV1:  PUSH    PSW             ;SAVE COUNT
29640           PUSH    H               ;SAVE (HL) I.E. CURRENT NUMERATOR
29660           DAD     B               ;SUBTRACT DENOMINATOR
29680           JNC     IDIV2           ;WE SUBTRACTED TOO MUCH, GET OLD (HL) BACK
29700           POP     PSW             ;THE SUBTRACTION WAS GOOD, DISCARD OLD (HL)
29720           STC                     ;NEXT BIT IN QUOTIENT IS A ONE
29740           XWD     1000,076        ;"MVI   A" OVER NEXT BYTE
29760   IDIV2:  POP     H               ;IGNORE THE SUBTRACTION, WE COULDN'T DO IT
29780   IDIV3:  MOV     A,E             ;SHIFT IN THE NEXT QUOTIENT BIT
29800           RAL
29820           MOV     E,A
29840           MOV     A,D             ;SHIFT THE HO
29860           RAL
29880           MOV     D,A
29900           MOV     A,L             ;SHIFT IN THE NEXT BIT OF THE NUMERATOR
29920           RAL
29940           MOV     L,A
29960           MOV     A,H             ;DO THE HO
29980           RAL
30000           MOV     H,A             ;SAVE THE HO
30020           POP     PSW             ;GET COUNT BACK
30040           DCR     A               ;ARE WE DONE?
30060           JNZ     IDIV1           ;NO, DIVIDE AGAIN
30080           XCHG                    ;GET QUOTIENT IN (HL), REMAINDER IN (DE)
30100           POP     B               ;GET SIGN OF RESULT
30120           PUSH    D               ;SAVE REMAINDER SO STACK WILL BE ALRIGHT
30140           JMP     IMLDIV          ;CHECK FOR SPECIAL CASE OF 32768
30160
30180
30200           ;GET READY TO MULTIPLY OR DIVIDE
30220           ;ALTERS A,B,C,D,E,H,L
30240   IMULDV: MOV     A,H             ;GET SIGN OF RESULT
30260           XRA     D
30280           MOV     B,A             ;SAVE IT IN B
30300           CALL    INEGH           ;NEGATE SECOND ARGUMENT IF NECESSARY
30320           XCHG                    ;PUT (DE) IN (HL), FALL IN AND NEGATE FIRST
30340                                   ; ARGUMENT IF NECESSARY
30360
30380
30400           ;NEGATE H,L
30420           ;ALTERS A,C,H,L
30440   INEGH:  MOV     A,H             ;GET SIGN OF (HL)
30460   INEGA:  ORA     A               ;SET CONDITION CODES
30480           RP                      ;WE DON'T HAVE TO NEGATE, IT IS POSITIVE
30500   INEGHL: XRA     A               ;CLEAR A
30520           MOV     C,A             ;STORE A ZERO (WE USE THIS METHOD FOR ISUB)
30540           SUB     L               ;NEGATE LO
30560           MOV     L,A             ;SAVE IT
30580           MOV     A,C             ;GET A ZERO BACK
30600           DBB     H               ;NEGATE HO
30620           MOV     H,A             ;SAVE IT
30640           RET                     ;ALL DONE
30660
30680
30700           ;INTEGER ABSOLUTE VALUE
30720           ;ALTERS A,B,C,D,E,H,L
30740   IABS:   LDA     FACLO+1         ;GET SIGN OF INTEGER IN FAC
30760           ORA     A               ;CHECK ITS SIGN
30780           RP                      ;IT IS POSITIVE, LEAVE IT ALONE
30800                                   ;FALL INTO INEG AND NEGATE IT
30820
30840
30860           ;INTEGER NEGATION
30880           ;ALTERS A,B,C,D,E,H,L
30900   INEG:   LHLD    FACLO           ;GET THE INTEGER
30920           CALL    INEGHL          ;NEGATE IT
30940           SHLD    FACLO           ;STORE IT BACK IN THE FAC
30960           XRI     200             ;CHECK FOR SPECIAL CASE OF 32768
30980           ORA     L
31000           RNZ                     ;IT DID NOT OCCUR, EVERYTHING IS FINE
31020           XCHG                    ;WE HAVE IT, FLOAT 32768
31040           MVI     A,4             ;CHANGE VALTYP TO "SINGLE PRECISION"
31060           STA     VALTYP
31080   INEGAD: MVI     B,230           ;ENTRY FROM IADD, SET EXPONENT
31100           JMP     FLOATR          ;GO FLOAT THE NUMBER
31120
31140
31160           ;MOD OPERATOR
31180           ;(HL):=(DE)-(DE)/(HL)*(HL),  (DE)=QUOTIENT
31200           ;ALTERS A,B,C,D,E,H,L
31220   MOD:    PUSH    D               ;SAVE (DE) FOR ITS SIGN
31240           CALL    IDIV            ;DIVIDE AND GET THE REMAINDER
31260           XCHG                    ;PUT REMAINDER IN (DE)
31280           MVI     A,2             ;SET VALTYP TO "INTEGER" IN CASE RESULT OF
31300           STA     VALTYP          ; THE DIVISION WAS 32768
31320           POP     PSW             ;GET THE SIGN OF (DE) BACK
31340           JNP     INEGA>          ;NEGATE THE REMAINDER IF NECESSARY
31360   PAGE
31380   SUBTTL  DOUBLE PRECISION ARITHMETIC ROUTINES
31400   IFE     LENGTH-2,<
31420   COMMENT %
31440           DOUBLE PRECISION ARITHMETIC CONVENTIONS
31460
31480   DOUBLE PRECISION NUMBERS ARE 8 BYTE QUANTITIES
31500   THE LAST 4 BYTES IN MEMORY ARE IN THE SAME FORMAT AS SINGLE PRECISION NUMBERS
31520   THE FIRST 4 BYTES ARE 32 MORE LOW ORDER BITS OF PRECISION
31540   THE LOWEST ORDER BYTE COMES FIRST IN MEMORY
31560
31580   CALLING CONVENTIONS:
31600   FOR ONE ARUGMENT FUNCTIONS:
31620           THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
31640   FOR TWO ARGUMENT OPERATIONS:
31660           THE FIRST ARGUMENT IS IN ARG=7,6,5,4,3,2,1,0  (NOTE: ARGLO=ARG-7)
31680           THE SECOND ARGUMENT IS IN THE FAC
31700           THE RESULT IS LEFT IN THE FAC
31720   VALTYP(DOUBLE PRECISION)=10 OCTAL
31740   %
31760
31780
31800           ;DOUBLE PRECISION SUBTRACTION   FAC:=ARG-FAC
31820           ;ALTERS ALL REGISTERS
31840   DSUB:   CALL    NEG             ;NEGATE THE SECOND ARGUMENT
31860                                   ;FALL INTO DADD
31880
31900
31920           ;DOUBLE PRECISION ADDITION      FAC:=ARG+FAC
31940           ;ALTERS ALL REGISTERS
31960   DADD:   LXI     H,ARG           ;GET  POINTER TO EXPONENT OF FIRST ARGUMENT
31980           MOV     A,H             ;CHECK IF IT IS ZERO
32000           ORA     A
32020           RZ                      ;IT IS, RESULT IS ALREADY IN FAC
32040           MOV     B,A             ;SAVE EXPONENT FOR UNPACKING
32060           DCX     H               ;POINT TO HO AND SIGN
32080           MOV     C,M             ;GET HO AND SIGN FOR UNPACKING
32100           LXI     D,FAC           ;GET POINTER TO EXPONENT OF SECOND ARGUMENT
32120           LDAX    D               ;GET EXPONENT
32140           ORA     A               ;SEE IF IT IS ZERO
32160           JZ      VMOVFA          ;IT IS, MOVE ARG TO FAC AND WE ARE DONE
32180           SUB     B               ;SUBTRACT EXPONENTS TO GET SHIFT COUNT
32200           JNC     DADD2           ;PUT THE SMALLER NUMBER IN FAC
32220           CMA                     ;NEGATE SHIFT COUNT
32240           INR     A
32260           PUSH    PSW             ;SAVE SHIFT COUNT
32280           PUSH    B               ;SAVE HO TO UNPACK LATER
32300           MVI     C,10            ;SWITCH FAC AND ARG, SET UP A COUNT
32320           INX     H               ;POINT TO ARG
32340   DADD1:  LDAX    D               ;GET A BYTE OF THE FAC
32360           MOV     B,M             ;GET A BYTE OF THE ARG
32380           MOV     M,A             ;PUT THE FAC BYTE IN ARG
32400           MOV     A,B             ;PUT THE ARG BYTE IN A
32420           STAX    D               ;PUT THE ARG BYTE IN FAC
32440           DCX     D               ;POINT TO THE NEXT LO BYTE OF FAC
32460           DCX     H               ;POINT TO THE NEXT LO BYTE OF ARG
32480           DCR     C               ;ARE WE DONE?
32500           JNZ     DADD1           ;NO, DO THE NEXT LO BYTE
32520           POP     B               ;GET THE HO BACK
32540           POP     PSW             ;GET THE SHIFT COUNT BACK
32560   DADD2:  CPI     71              ;ARE WE WITHIN 56 BITS?
32580           RNC                     ;NO, ALL DONE
32600           PUSH    PSW             ;SAVE SHIFT COUNT
32620           CALL    UNPACK          ;UNPACK THE NUMBERS
32640           MOV     A,B             ;SAVE SUBTRACTION FLAG
32660           MOV     A,C             ;SAVE THE UNPACKED HO
32680           STA     ARG-1
32700           POP     PSW             ;GET SHIFT COUNT
32720           CALL    DSHFTR          ;SHIFT FAC RIGHT THE RIGHT NUMBER OF TIMES
32740           ORA     B               ;GET SUBTRACTION FLAG, HERE A=0
32760           JP      DADD3           ;SUBTRACT NUMBERS IF THEIR SIGNS ARE DIFFERENT
32780           CALL    DADDAA          ;SIGNS ARE THE SAME, ADD THE NUMBERS
32800           JNC     DROUND          ;ROUND THE RESULT IF NO CARRY
32820           INR     M               ;WE HAVE OVERLOW, ADD ONE TO THE EXPONENT
32840           JZ      OVERR           ;CHECK FOR OVERFLOW
32860           MVI     D,1             ;SHIFT NUMBER RIGHT ONE, SHIFT IN CARRY
32880           CALL    DSHFRA
32900           JMP     DROUND          ;ROUND THE RESULT
32920   DADD3:  XWD     1000,076        ;"MVI   A", SUBTRACT THE NUMBER
32940           SBB     M               ;GET THE SUBTRACT INSTRUCTION IN A
32960           CALL    DADDA           ;SUBTRACT THE NUMBERS
32980           INX     H               ;POINT TO THE UNPACKED SIGN
33000           MOV     A,M             ;COMPLEMENT IT, SINCE THE FAC WAS SMALLER
33020           CMA
33040           MOV     M,A
33060           CC      DNEGR           ;NEGATE THE RESULT IF IT WAS NEATIVE
33080                                   ;FALL INTO DNORML
33100
33120
33140           ;NORMALIZE FAC
33160           ;ALTERS A,B,C,D,H,L
33180   DNORML: XRA     A               ;CLEAR SHIFT COUNT
33200   DNORM1: MOV     B,A             ;SAVE SHIFT COUNT
33220           LDA     FAC-1           ;GET HO
33240           ORA     A               ;SEE IF WE CAN SHIFT 8 LEFT
33260           JNZ     DNORM5          ;WE CAN'T, SEE IF NUMBER IS NORMALIZED
33280           LXI     H,DFACLO-1      ;WE CAN, GET POINTER TO LO
33300           MVI     C,10            ;SET UP A COUNT
33320   DNORM2: MOV     D,M             ;GET A BYTE OF FAC
33340           MOV     M,A             ;PUT IN BYTE FROM LAST LOCATION, THE FIRST
33360                                   ; TIME THROUGH A IS ZERO
33380           MOV     A,D             ;PUT THE CURRENT BYTE IN A FOR NEXT TIME
33400           INX     H               ;INCREMENT POINTER TO NEXT HIGHER ORDER
33420           DCR     C               ;ARE WE DONE?
33440           JNZ     DNORM2          ;NO, DO THE NEXT BYTE
33460           MOV     A,B             ;SUBTRACT 0 FROM SHIFT COUNT
33480           SUI     10
33500           CPI     300             ;HAVE WE SHIFTED ALL BYTES TO ZERO?
33520           JNZ     DNORM1          ;NO, TRY TO SHIFT 8 MORE
33540           JMP     ZERO            ;YES, THE NUMBER IS ZERO
33560   DNORM3: DCR     B               ;DECREMENT SHIFT COUNT
33580           LXI     H,DFACLO-1      ;GET POINTER TO LO
33600           CALL    DSMFLC          ;SHIFT THE FAC LEFT
33620           ORA     A               ;SEE IF NUMBER IS NORMALIZED
33640   DNORM5: JP      DNORM3          ;SHIFT FAC LEFT ONE IF IT IS NOT NORMALIZED
33660           MOV     A,B             ;GET THE SHIFT COUNT
33680           ORA     A               ;SEE IF NO SHIFTING WAS DONE
33700           JZ      DROUND          ;NONE WAS, PROCEED TO ROUND THE NUMBER
33720           LXI     H,FAC           ;GET POINTER TO EXPONENT
33740           ADD     M               ;UPDATE IT
33760           MOV     M,A             ;SAVE UPDATED EXPONENT
33780           JNC     ZERO            ;UNDERFLOW, THE RESULT IS ZERO
33800           RZ                      ;RESULT IS ALREADY ZERO, WE ARE DONE
33820                                   ;FALL INTO DROUND AND ROUND THE RESULT
33840
33860
33880           ;ROUND FAC2
33900           ;ALTERS A,B,H,L
33920   DROUND: LDA     DFACLO-1        ;GET EXTRA BYTE TO SEE IF WE HAVE TO ROUND
33940   DROUNB: ORA     A               ;ENTRY FROM DDIV
33960           CM      DROUNA          ;ROUND UP IF NECESSARY
33980           LXI     H,FAC+1         ;GET PONTER TO UNPACKED SIGN
34000           MOV     A,M             ;GET SIGN
34020           ANI     200             ;ISOLATE SIGN BIT
34040           DCX     H               ;POINT TO HO
34060           DCX     H
34080           XRA     M               ;PACK SIGN AND HO
34100           MOV     M,A             ;PUT PACKED SIGN AND HO IN FAC
34120           RET                     ;WE ARE DONE
34140
34160
34180           ;SUBROUTINE FOR ROUND: ADD ONE TO FAC
34200   DROUNA: LXI     H,DFACLO        ;GET POINTER TO LO, ENTRY FROM DINT
34220           MXI     B,7             ;SET UP A COUNT
34240   DRONA1: INR     M               ;INCREMENT A BYTE
34260           RNZ                     ;RETURN IF THERE WAS NO CARRY
34280           INX     H               ;INCREMENT POINTER TO NEXT HIGHER ORDER
34300           DCR     B               ;HAVE WE INCREMENT ALL BYTES
34320           JNZ     DRONA1          ;NO, TRY THE NEXT ONE
34340           INR     H               ;YES, INCREMENT THE EXPONENT
34360           JZ      OVERR           ;CHECK FOR OVERFLOW
34380           DCX     H               ;THE NUMBER OVERFLOWED ITS EXPONENT
34400           MVI     M,200           ;PUT 200 IN HO
34420           RET                     ;ALL DONE
34440
34460
34480           ;ADD OR SUBTRACT 2 DBL QUANTITIES
34500           ;ALTERS A,C,D,E,H,L
34520   DADDD:  LXI     H,FBUFFR+^D17   ;ENTRY FROM DDIV
34540           LXI     D,ARGLO         ;ADD OR SUBTRACT FBUFFR+17 AND ARG
34560           JMP     DADDS           ;DO THE OPERATION
34580
34600   DADDAA: XWD     1000,076        ;"MVI   A", ENTRY FROM DADD, DMULT
34620           ADC     M               ;SETUP ADD INSTRUCTION FOR LOOP
34640   DADDA:  LXI     H,ARGLO         ;GET POINTER TO ARG, ENTRY FROM DADD
34660   DADDFO: LXI     D,DFACLO        ;GET POINTER TO FAC, ENTRY FROM FOUT
34680   DADDS:  MVI     C,7             ;SET UP A COUNT
34700           STA     DADDOP          ;STORE THE ADD OR SUBTRACT INSTRUCTION
34720           XRA     S               ;CLEAR CARRY
34740   DADDL:  LDAX    D               ;GET A BYTE FROM RESULT NUMBER
34760   DADDOP: NOP                     ;THIS IS EITHER "ADC    ," OR "SBB      M"
34780           STAX    D               ;SAVE THE CHANGED BYTE
34800           INX     D               ;INCREMENT POINTERS TO NEXT HIGHER ORDER BYTE
34820           INX     H
34840           DCR     C               ;ARE WE DONE?
34860           JNZ     DADDL           ;NO, DO THE NEXT HIGHER ORDER BYTE
34880           RET                     ;ALL DONE
34900
34920
34940           ;NEGATE SIGNED NUMBER IN FAC
34960           ;THIS IS USED BY DADD, DINT
34980           ;ALTERS A,B,C,H,L
35000   DNEGR:  MOV     A,H             ;COMPLEMENT SIGN OF FAC
35020           CMA                     ;USE THE UNPACKED SIGN BYTE
35040           MOV     M,A             ;SAVE THE NEW SIGN
35060           LXI     H,DFACLO-1      ;GET POINTER TO LO
35080           MVI     B,10            ;SET UP A COUNT
35100           XRA     A               ;CLEAR CARRY AND GET A ZERO
35120           MOV     C,A             ;SAVE ZERO IN C
35140   DNEGR1: MOV     A,C             ;GET A ZERO
35160           SBB     M               ;NEGATE THE BYTE OF FAC
35180           MOV     M,A             ;UPDATE FAC
35200           INX     H               ;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
35220           DCR     B               ;ARE WE DONE?
35240           JNX     DNEGR1          ;NO, NEGATE THE NEXT BYTE
35260           RET                     ;ALL DONE
35280
35300
35320           ;SHIFT DBL FAC RIGHT ONE
35340           ;A = SHIFT COUNT
35360           ;ALTERS A,C,D,E,H,L
35380   DSHFTR: LXI     H,DFACLO-1      ;GET POINTER TO LO
35400           MVI     M,0             ;PUT ZERO IN EXTRA LO ORDER BYTE
35420   DSHFT1: SUI     10              ;SEE IF WE CAN SHIFT 8 RIGHT
35440           JC      DSHFR3          ;WE CAN'T, CHECK IF WE ARE DONE
35460   DSHFRM: LXI     H,FAC-1         ;ENTRY FROM DMULT, GET POINTER TO HO
35480           MVI     E,0             ;SHIFT A ZERO INTO THE HO
35500           MVI     D,10            ;SET UP A COUNT
35520   DSHFR2: MOV     C,M             ;SAVE A BYTE OF FAC
35540           MOV     M,E             ;PUT THE LAST BYTE IN ITS PLACE
35560           MOC     E,C             ;SET UP E FOR NEXT TIME THROUGH THE LOOP
35580           DCX     H               ;POINT TO NEXT LOWER ORDER BYTE
35600           DCR     D               ;ARE WE DONE?
35620           JNZ     DSHFR2          ;NO, DO THE NEXT BYTE
35640           JMP     DSHFR1          ;YES, SEE IF WE CAN SHIFT OVER 8 MORE
35660   DSHFR3: ADI     11              ;CORRECT SHIFT COUNT
35680           MOV     D,A             ;SAVE SHIFT COUNT IN D
35700   DSHFR4: XRA     A               ;CLEAR CARRY
35720           DCR     D               ;ARE WE DONE?
35740           RZ                      ;YES
35760   DSHFRA: LXI     H,FAC-1         ;NO, GET POINTER TO LO, ENTRY FROM DADD, DMULT
35780           MVI     E,10            ;SET UP A COUNT, RORARE FAC ONE LEFT
35800   DSHFR5: MOV     A,M             ;GET A BYTE OF THE FAC
35820           RAR                     ;ROTATE IT LEFT
35840           MOV     M,A             ;PUT THE UPDATED BYTE BACK
35860           DCX     H               ;DECREMENT POINTER TO NEXT LOWER ORDER BYTE
35880           DCR     E               ;ARE WE DONE?
35900           JNZ     DSHFR5          ;NO, ROTATE THE NEXT LOWER ORDER BYTE
35920           JMP     DSHFR4          ;YES, SEE IF WE ARE DONE SHIFTING
35940
35960
35980           ;ROTATE FAC LEFT ONE
36000           ;ALTERS A,C,H,L
36020   DSHFLC: MVI     C,10            ;SET UP A COUNT
36040   DSHFTL: MOV     A,M             ;GET A BYTE OF FAC
36060           RAL                     ;ROTATE IT LEFT ONE
36080           MOV     M,A             ;UPDATE BYTE IN FAC
36100           INX     H               ;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
36120           DCR     C               ;ARE WE DONE?
36140           JNZ     DSHFTL          ;NO, ROTATE THE NEXT BYTE
36160           RET                     ;ALL DONE
36180
36200
36220           ;DOUBLE PRECISION MULTIPLICATION        FAC:=ARG+FAC
36240           ;ALTERS ALL REGISTERS
36260   DMULT:  FSIGN                   ;CHECK IF WE ARE MULTIPLYING BY ZERO
36280           RZ                      ;YES, ALL DONE, THE FAC IS ZERO
36300           CALL    MULDVA          ;ADD EXPONENTS AND TAKE CARE OF SIGNS
36320           CALL    DMULDV          ;ZERO FAC AND PUT FAC IN FBUFFR
36340           MOV     M,C             ;PUT UNPACKED HO IN ARG
36360           LXI     D,ARGLO         ;GET POINTER TO LO OF ARG
36380           MVI     B,7             ;SET UP A COUNT
36400   DMULT2: LDAX    D               ;GET THE BYTE OF ARG TO MULTIPLY BY
36420           INX     D               ;INCREMENT POINTER TO NEXT HIGHER BYTE
36440           ORA     A               ;CHECK IF WE ARE MULTIPLYING BY ZERO
36460           PUSH    D               ;SAVE POINTER TO ARG
36480           JZ      DMULT5          ;WE ARE
36500           MVI     C,10            ;SET UP A COUNT
36520   DMULT3: PUSH    B               ;SAVE COUNTERS
36540           RAR                     ;ROTATE MULTIPLIER RIGHT
36560           MOV     B,A             ;SAVE IT
36580           CC      DADDAA          ;ADD IN OLD FAC IF BIT OF MULTIPIER WAS ONE
36600           MVI     D,1             ;ROTATE PRODUCT RIGHT ONE
36620           CALL    DSHFRA
36640           MOV     A,B             ;GET MULTIPLIER IN A
36660           POP     B               ;GET COUNTERS BACK
36680           DCR     C               ;ARE WE DONE WITHT HIS BYTE OF ARG?
36700           JNZ     DMULT3          ;NO, MULTIPLY BY THE NEXT BIT OF THE MULTIPLIER
36720   DMULT4: POP     D               ;YES, GET POINTER INTO ARG BACK
36740           DCR     B               ;ARE WE DONE?
36760           JNZ     DMULT2          ;NO, MULTIPLY BY NEXT HIGHER ORDER BY OF ARG
36780           JMP     NORMAL          ;ALL DONE, NORMALIZE AND ROUND RESULT
36800   DMULT5: CALL    DSHFRM          ;SHIFT PRODUCT RIGHT ONE BYTE, WE ARE
36820           JMP     DMULT4          ; MULTIPLYIING BY ZERO
36840
36860
36880           ;CONSTANT FOR DIV10, DDIV10
36900   DTEN:   000     ; 10D0
36920           000
36940           000
36960           000
36980   FTEN:   000     ;10.0
37000           000
37020           040
37040           204
37060
37080           ;DOUBLE PRECISION DIVIDE FAC BY 10
37100           ;ALTERS ALL REGISTERS
37120   DDIV10: CALL    VMOVAF          ;SAVE THE FAC IN ARG
37140           LXI     H,DTEN          ;GET POINTER TO A DOUBLE PRECISION 10
37160           CALL    VMOVFM          ;MOVE TEN INTO THE FAC
37180                                   ;FALL INTO DDIV AND DIVIDE BY TEN
37200
37220
37240           ;DOUBLE PRECISION DIVISION      FAC:=ARG/FAC
37260           ;ALTERS ALL REGISTERS
37280   DDIV:   FSIGN                   ;CHECK FOR DIVISION BY ZERO
37300           JZ      DV0ERR          ;DON'T LET HIM DO IT
37320           CALL    MULDVS          ;SUBTRACT EXPONENTS AND CHECK SIGNS
37340           INR     M               ;ADD TWO TO EXPONENT TO CORRECT SCALING
37360           INR     M
37380           CALL    DMULDV          ;ZERO FAC AND PUT FAC IN FBUFFT
37400           LXI     H,ARG           ;GET POINTE RTO THE EXTRA HO BYTE WE WILL USE
37420           MOV     M,C             ;ZERO IT
37440           MXI     B,0             ;ZERO FLAG TO SEE WHEN WE START DIVIDING
37460   DDIV1:  XWD     1000,076        ;"MVI   A", SUBTRACT FBUFFR FROM ARG
37480           SBB     M               ;GET SUBTRACT INSTRUCTION
37500           CALL    DADDD           ;DO THE SUBTRACTION
37520           LDAX    D               ;SUBTRACT FROM EXTRA HO BYTE
37540           SBB     C               ;HERE C=0
37560           CMC                     ;CARRY=1 IF SUBTRACTION WAS GOOD
37580           JC      DDIV2           ;WAS IT OK?
37600           XWD     1000,076        ;"MVI   A" NO, ADD FBUFFR BACK IN
37620           ADC     M               ;GET ADD INSTRUCTION
37640           CALL    DADDD           ;DO THE ADDITION
37660           XRA     A               ;CLEAR CARRY
37680           XWD     1000,332        ;"JC" OVER NEXT TWO BYTES
37700   DDIV2:  STAX    D               ;STORE THE NEW HIGHEST ORDER BYTE
37720           INR     B               ;INCREMENT FLAG TO SHOW WE COULD DIVIDE
37740           LDA     FAC-1           ;CHECK IF WE ARE DONE DIVIDING
37760           INR     A               ;SET SIGN FLAG WITHOUT AFFECTING CARRY
37780           DCR     A
37800           RAR                     ;PUT CARRY IN MSG FOR DROUND
37820           JM      DROUNB          ;WE ARE DONE, WE HAVE 57 BITS OF ACCURACY
37840           RAL                     ;GET OLD CARRY BACK WHERE IT BELONDS
37860           LXI     H,DFACLO        ;GET POINTE RTO LO OF FAC
37880           MVI     C,7             ;SET UP A COUNT, SHIFT FAC LEFT ONE
37900           CALL    DSHFTL          ;SHIFT IN THE NEXT BIT IN THE QUOTIENT
37920           LXI     H,ARGLO         ;GET POINTER TO LO IN ARG
37940           CALL    DSHFLC          ;SHIFT DIVIDEND ONE LEFT
37960           MOV     A,B             ;IS THIS THE FIRST TIME AND WAS THE
37980           ORA     A               ; SUBTRACTION NOT GOOD? (B WILL GET
38000           JNZ     DDIV1           ; CHANGED ON THE FIRST OR SECOND SUBTRACTION)
38020           LXI     H,FAC           ;YES, SUBTRACT ONE FROM EXPONENT TO CORRECT
38040           DCR     M               ; SCALING
38060           JNZ     DDIV1           ;CONTINUE DIVIDING IF NO OVERFLOW
38080           JMP     OVERR           ;WE HAVE OVERFLOW!!
38100
38120
38140           ;TRANSFER FAC TO FBUFFR FOR DMULT AND DDIV
38160           ;ALTERS A,B,C,D,E,H,L
38180   DMULDV: MOV     A,C             ;PUT UNPACKED HO BACK IN ARG
38200           STA     ARG-1
38220           DCX     H               ;POINT TO HO OF FAC
38240           LXI     D,FBUFFR+^D23   ;POINT TO END OF FBUFFR
38260           MVI     B,7             ;SET UP A COUNT
38280           MVI     C,0             ;GET A ZERO TO FILL FAC WITH
38300   DMLDV1: MOV     A,M             ;GET A BYTE FROM FAC
38320           STAX    D               ;PUT IT IN FBUFFR
38340           MOV     M,C             ;PUT A ZERO IN FAC
38360           DCX     D               ;POINT TO NEXT BYTE IN FBUFFR
38380           DCX     H               ;POINT TO NEXT LOWER ORDER BYTE IN FAC
38400           DCR     B               ;ARE WE DONE?
38420           JNZ     DMLDV1          ;NO, TRANSFER THE NEXT BYTE
38440           RET                     ;ALL DONE
38460
38480
38500           ;DOUBLE PRECISION MULTIPLY THE FAC BY 10
38520           ;ALTERS ALL REGISTERS
38540   DMUL10: CALL    VMOVAF          ;SAVE THE FAC IN ARG
38560                                   ;VMOVAF EXITS WITH (DE)=FAC+1
38580           XCHG                    ;GET THE POINTER INTO THE FAC IN (HL)
38600           DCX     H               ;POINT TO THE EXPONENT
38620           MDV     A,M             ;GET THE EXPONENT
38640           ADI     2               ;MULTIPLY FAC BY 4 BY ADDING 2 TO THE EXPONENT
38660           JC      OVERR           ;CHECK FOR OVERFLOW
38680           MOV     M,A             ;SAVE THE NEW EXPONENT
38700           PUSH    H               ;SAVE POINTER TO FAC
38720           CALL    DADD            ;ADD IN THE ORIGINAL FAC TO GET 5 TIMES  FAC
38740           POP     H               ;GET THE POINTER TO FAC BACK
38760           INR     M               ;ADD ONE TO EXPONENT TO GET 10 TIMES FAC
38780           RNZ                     ;ALL DONE IF OVERFLOW DID NOT OCCUR
38800           JMP     OVERR>          ;IT DID, GIVE THE APPROPRIATE MESSAGE
38820   PAGE
38840   SUBTTL  FLOATING POINT INPUT ROUTINE
38860           ;ALTERS ALL REGISTERS
38880           ;THE NUMBER IS LEFT IN FAC
38900           ;AT ENTRY, (HL) POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
38920           ;THE FIRST CHARACTER IS ALSO IN A.  WE PACK THE DIGITS INTO THE FAC
38940           ;AS AN INTEGER AND KEEP TRACK OF WHERE THE DECIMAL POINT IS.
38960           ;C IS 377 IF WE HAVE NOT SEEN A DECIMAL POINT, 0 IF WE HAVE.
38980           ;B IS THE NUMBER OF DIGITS AFTER THE DECIMAL POINT.
39000           ;AT THE END, B AND THE EXPONENT (IN E) ARE USED TO DETERMINE HOW MANY
39020           ;TIMES WE MULTIPLY OR DIVIDE BY TEN TO GET THE CORRECT NUMBER.
39040   FIN:
39060   IFN     STRING,<
39080           ;IF WE ARE CALLED BY VAL, THE SIGNS MAY NOT BE CRUNCHED
39100           CPI     "-"             ;SEE IF NUMBER IS NEGATIVE
39120           PUSH    PSW             ;SAVE SIGN
39140           JZ      FIN1            ;IGNORE MINUS SIGN
39160           CPI     "+"             ;IGNORE A LEADING SIGN
39180           JZ      FIN1>
39200           DCX     H               ;SET CHARACTER POINTER BACK ONE
39220   FIN1:
39240   IFN     LENGTH-2,<
39260           CALL    ZERO            ;CLEAR FAC
39280           MOV     B,A             ;CLEAR FLAGS: B=DECIMAL PLACE COUNT
39300           MOV     D,A             ;D=SIGN OF EXPONENT
39320           MOV     E,A             ;E=EXPONENT
39340           CMA
39360           MOV     C,A             ;C="." FLAG
39380           ;HERE TO GET THE NEXT DIGIT OF THE NUMBER, A DECIMAL POINT OR AN "E"
39400   FINC:   CHRGET                  ;GET A CHARACTER
39420           JC      FINDIG          ;DO WE HAVE A DIGIT?
39440           CPI     "."             ;TEST FOR DECIMAL POINT
39460           JZ      FINDP
39480           CPI     "E"             ;CHECK FOR BEGINNING OF EXPONENT
39500           JNZ     FINE            ;"NONE OF THE ABOVE" SO END OF NUMBER
39520           ;HERE TO CHECK FOR THE SIGN OF THE EXPONENT
39540           CHRGET                  ;CHECK FOR ITS SIGN
39560   IFN     STRING,<
39580           PUSH    H               ;SAVE TEXT POINTER
39600           LXI     H,FINEC         ;PUT FINEC ON STACK SO WE CAN JUMP
39620           XTHL>                   ; TO IT IN LESS BYTES
39640           DCR     D               ;SET SIGN OF EXPONENT FLAG
39660           CPI     MINUTK          ;NEGATIVE EXPONENT?
39680   IFE     STRING,<
39700           JZ      FINEC>
39720   IFN     STRING,<
39740           RZ
39760           CPI     "-"
39780           RZ>
39800           INR     D               ;NO, RESET FLAG
39820   IFN     STRING,<
39840           CPI     "+"
39860           RZ>
39880           CPI     PLUSTK          ;IGNORE "+"
39900   IFE     STRING,<
39920           JZ      FINEC>
39940   IFN     STRING,<
39960           RZ
39980           POP     PSW>            ;GET FINEC OFF STACK
40000           DCX     H               ;CHECK IF LAST CHARACTER A DIGIT
40020           ;HERE TO GET THE NEXT DIGIT OF THE EXPONENT
40040   FINEC:  CHRGET                  ;GET NEXT CHARACTER
40060           JC      FINEDG          ;IS IT A DIGIT?
40080           INR     D               ;NO, EXPONENT ALL IN
40100           JNZ     FINE            ;SET ITS SIGN
40120           XRA     A
40140           SUB     E
40160           MOV     E,A
40180           INR     C               ;MAKE SURE C IS NOT 377
40200           ;HERE TO CHECK IF WE HAVE SEEN 2 DECIMAL POINTS AND SET THE DECIMAL
40220           ; POINT FLAG
40240   FINDP:  INR     C               ;DECIMAL POINTS!! -- SET FLAG
40260           JZ      FINC            ;CONTINUE SCANNING CHARACTERS
40280                                   ;WE DON'T WANT TWO SO END OF NUMBER
40300           ;HERE TO MULTIPLY OR DIVIDE BY 10 THE CORRECT NUMBER OF TIMES.
40320           ;WE HAVE ALREADY READ IN ALL THE DIGITS.
40340   FINE:   PUSH    H               ;SAVE POINTER FOR LATER
40360           MOV     A,E             ;EXPONENT=EXPONENT-# OF DECIMAL PLACES
40380           SUB     B
40400   FINE2:  CP      FINMUL          ;MULTIPLY BY THEN IF EXPONENT IS POSITIVE
40420           JP      FINE3           ;DIVIDE BY TEN IF EXPONENT IS NEGATIVE
40440           PUSH    PSW             ;SAVE EXPONENT
40460           CALL    DIV10           ;DIVIDE NUMBER BY TEN
40480           POP     PSW             ;GET EXPONENT
40500           INR     A               ;INCREMENT IT
40520   FINE3:  JNZ     FINE2           ;DO AGAIN IF WE ARE NOT DONE
40540   IFE     STRING,<
40560           POP     H>              ;GET CHARACTER POINTER
40580   IFN     STRING,<
40600           POP     D               ;GET CHARACTER POINTER
40620           POP     PSW             ;GET SIGN
40640           CZ      NEG             ;NEGATE IF NECESSARY
40660           XCHG>                   ;GET CHARACTER POINTER IN (HL)
40680           RET>                    ;ALL DONE
40700   IFE     LENGTH-2,<
40720           XCHG                    ;SAVE THE TEXT POINTER IN (DE)
40740           LXI     B,377+$CODE     ;CLEAR FLAGS:  B=DECIMAL PLACE COUNT
40760                                   ;C="." FLAG
40780           MOV     H,C             ;ZERO (HL)
40800           MOV     L,C
40820           CALL    CONISS          ;ZERO FAC, SET VALTYP TO "INTEGER"
40840           XCHG                    ;GET THE TEXT POINTER BACK IN (HL)
40860           ;HERE TO CHECK FOR A DIGIT, A DECIMAL POINT, "E" OR "D"
40880   FINC:   CHRGET                  ;GET THE NEXT CHARACTER OF THE NUMBER
40900           JC      FINDIG          ;WE HAVE A DIGIT
40920           CPI     "."             ;CHECK FOR A DECIMAL POINT
40940           JZ      FINDP           ;WE HAVE ONE, I GUESS
40960           CPI     "E"             ;CHECK FOR A SINGLE PRECISION EXPONENT
40980           JZ      FINEX           ;WE HAVE A SINGLE PRECISION NUMBER
40000           CPI     "D"             ;CHECK FOR A DOUBLE PRECISION EXPONENT
41020           JNZ     FINE            ;WE DON'T HAVE ONE, THE NUMBER IS FINISHED
41040           ORA     A               ;DOUBLE PRECISION NUMBER -- TURN OFF ZERO FLAG
41060   FINEX:  CALL    FINFRC          ;FORCE THE FAC TO BE SNG OR DBL
41080           PUSH    H               ;SAVE THE TEXT POINTER
41100           LXI     H,FINEC         ;GET ADDRESS TO JUMP TO, THIS IS TO SAVE BYTES
41120           XTHL                    ;PUT IT ON STACK AND GET TEXT POINTER
41140           ;HERE TO CHECK FOR THE SIGN OF THE EXPONENT
41160           CHRGET                  ;GET THE FIRST CHARACTER OF THE EXPONENT
41180           DCR     D               ;SET SIGN OF EXPONENT TO MINUS
41200           CPI     MINUTK          ;CHECK IF THE EXPONENT IS NEGATIVE
41220           RZ                      ;IT IS
41240           CPI     "-"             ;THIS IS IN CASE WE ARE CALLED BY VAL
41260           RZ
41280           INR     D               ;EXPONENT IS STILL POSITIVE, RESET FLAG
41300           CPI     PLUSTK          ;IGNORE A LEADING PLUS SIGN
41320           RZ
41340           CPI     "+"
41360           RZ
41380           DCX     H               ;THE FIRST CHARACTER WAS NOT A SIGN, GO BACK
41400                                   ; AND CHECK FOR A DIGIT
41420           POP     PSW             ;POP FINEC OFF THE STACK, WE NO LONGER NEED IT
41440           ;HERE TO GET THE NEXT DIGIT OF THE EXPONENT
41460   FINEC:  CHRGET                  ;GET THE NEXT CHARACTER
41480           JC      FINEDG          ;PACK THE NEXT DIGIT INTO THE EXPONENT
41500           INR     D               ;IT WAS NOT A DIGIT, PUT THE CORRECT SIGN ON
41520           JNZ     FINE            ; THE EXPONENT, IT IS POSITIVE
41540           XRA     A               ;THE EXPONENT IS NEGATIVE
41560           SUB     E               ;NEGATE IT
41580           MOV     E,A             ;SAVE IT AGAIN
41600           ;HERE TO FINISH UP THE NUMBER
41620   FINE:   LDA     VALTYP          ;FINISH UP -- WHAT KIND OF NUMBER IS IT?
41640           CPI     2
41660           JNZ     FINEF           ;IT IS A FLOATING POINT ONE
41680           ;HERE TO FINISH UP AN INTEGER
41700           POP     PSW             ;IT IS AN INTEGER, GET ITS SIGN
41720           XCHG                    ;SAVE THE TEXT POINTER IN (DE)
41740           CZ      INEG            ;NEGATE IT IF NECESSARY
41760           XCHG                    ;GET THE TEXT POINTER BACK IN (HL)
41780           RET                     ;ALL DONE
41800           ;HERE TO FINISH UP A FLOATING POINT NUMBER
41820   FINEF:  PUSH    H               ;SAVE THE TEXT POINTER
41840           MOV     A,E             ;FIND OUT HOW MANY TIMES WE HAVE TO MULTIPLY
41860           SUB     B               ; OR DIVIDE BY TEN
41880           ;HERE TO MULTIPLY OR DIVIDE BY TEN THE CORRECT NUMBER OF TIMES
41900   FINEF2: CP      FINMUL          ;MULTIPLY IF WE HAVE TO
41920           CM      FINDIV          ;DIVIDE IF WE HAVE TO
41940           JNZ     FINEF2          ;MULTIPLY OR DIVIDE AGAIN IF WE ARE NOT DONE
41960           ;HERE TO PUT THE CORRECT SIGN ON THE NUMBER
41980           POP     D               ;GET THE TEXT POINTER
42000           POP     PSW             ;GET THE SIGN
42020           CZ      NEG             ;NEGATE IF NECESSARY
42040           XCHG                    ;GET THE TEXT POINTER IN (HL)
42060           LDA     VALTYP          ;WE WANT -32768 TO BE AN INT, BUT UNTIL NOW
42080           CPI     4               ; IT WOULD BE A SNG
42100           RNZ                     ;IT IS NOT SNG, SO IT IS NOT -32768
42120           PUSH    H               ;WE HAVE A SNG, SAVE TEXT POINTER
42140           LXI     H,POPMRT        ;GET ADDRESS THAT POP'S H OFF STACK BECAUSE
42160           PUSH    H               ; CONIS2 DOES FUNN THINGS WITH THE STACK
42180           CALL    CONIS2          ;CHECK IF WE AHVE -32768
42200           RET                     ;WE DON'T, POPHRT IS STILL ON THE STACK SO
42220                                   ; WE CAN JUST RETURN
42240
42260           ;HERE TO CHECK IF WE HAVE SEEN 2 DECIMAL PONTS AND SET THE DECIMAL
42280           ; POINT FLAG
42300   FINDP:  INR     C               ;SET THE FLAG
42320           JNZ     FINEF           ;WE HAD 2 DECIMAL POINTS, NOW WE ARE DONE
42340           CALL    FINFRC          ;THIS IS THE FIRST ONE, CONVERT FAC TO SNG
42360           JMP     FINC            ;CONTINUE LOOKING FOR DIGITS
42380
42400           ;FORCE THE FAC TO BE SNG OR DBL
42420           ;IF THE ZERO FLAG IS ON, THEN FORCE THE FAC TO BE SNG
42440           ;IF THE ZERO FLAG IS OFF, FORCE THE FAC TO BE DBL
42460   FINFRC: PUSH    H               ;SAVE TEXT POINTER
42480           PUSH    D               ;SAVE EXPONENT INFORMATION
42500           PUSH    B               ;SAVE DECIMAL POINT INFORMATION
42520           PUSH    PSW             ;SAVE WHAT WE WANT THE FAC TO BE
42540           CZ      FRCSNG          ;CONVERT TO SNG IF WE AHVE TO
42560           POP     PSW             ;GET TYPE FLAG BACK
42580           CNZ     FRCDBL          ;CONVERT TO DBL IF WE HAVE TO
42600           POP     B               ;GET DECIMAL POINT INFORMATION BACK
42620           POP     D               ;GET EXPONENT INFORMATION BACK
42640           POP     H               ;GET TEXT POINTER BACK
42660           RET>                    ;ALL DONE
42700           ;THIS SUBROUTINE MULIPLIES BY TEN ONCE.
42720           ;IT IS A SUBROUTINE BECAUSE IT SAVES BYTES WHEN WE CHECK IF A IS ZERO
42740   FINMUL: RZ                      ;RETURN IF EXPONENT IS ZERO, ENTRY FROM FOUT
42760   FINMLT: PUSH    PSW             ;SAVE EXPONENT, ENTRY FROM FOUT
42780   IFN     LENGTH-2,<
42800           CALL    MUL10>          ;MULTIPLY BY TEN
42820   IFE     LENGTH-2,<
42840           LDA     CALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
42960           CPI     4
42980           PUSH    PSW             ;SAVE THE TYPE
42900           CZ      MUL10           ;WE HAVE A SNG, MULTIPLY BY 10.0
42920           POP     PSW             ;GET THE TYPE BACK
42940           CNZ     DMUL10>         ;WE HAVE A DBL, MULTIPLY BY 1000
43960           POP     PSW             ;GET EXPONENT
43980   DCRART: DCR     A               ;DECREASE IT
43000           RET                     ;ALL DONE
43040   IFE     LENGTH-2,<
43060   FINDIC: PUSH    PSW             ;WE HAVE TO DIVIDE -- SAVE COUNT
43080           LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
43100           CPI     4
43120           PUSH    PSW             ;SAVE THE TYPE
43140           CZ      DIV10           ;WE HAVE A SNG NUMBER
43160           POP     PSW             ;GET THE TYPE BACK
43180           CNZ     DDIV10          ;WE HAVE A DBL NUMBER
43200           POP     PSW             ;GET COUNT BACK
43220           INR     A               ;UPDATE IT
43240           RET>
43280           ;HERE TO PACK THE NEXT FIGIT OF THE NUMBER INTO THE FAC
43300           ;WE MULTIPLY THE FAC BY TEN AND ADD IN THE NEXT DIGIT
43320   FINDIG:
43340   IFN     LENGTH-2,<
43360           PUSH    D               ;DIGITS: SAVE EXPONENT INFORMATION
43380           MOV     D,A             ;PROTECT DIGIT FROM BELOW
43400           MOV     A,B             ;INCREMENT DECIMAL PLACE COUNT
43420           ADC     C               ; IF PAST THE DECIMAL POINT
43440           MOV     B,A
43460           PUSH    B               ;SAVE NECESSARY DATA
43480           PUSH    H
43500           PUSH    D               ;SAVE DIGIT
43520           CALL    MUL10           ;MULTIPLY OLD NUMBER BY 10
43540           POP     PSW             ;GET NEXT DIGIT
43560           SUI     "0"             ;SUBTRACT OFF ASCII CODE
43580   IFE     EXTFNC,<
43600           CALL    PUSHF           ;PUT NUMBER ON STACK
43620           CALL    FLOAT           ;CONVERT TO FLOATING POINT NUMBER
43640           POPR
43660           CALL    FADD>           ;ADD IN NEXT DIGIT
43680   IFN     EXTFNC,<
43700           CALL    FINLOG>
43720           POP     H               ;RECALL DATA
43740           POP     B
43760           POP     D
43780           JMP     FINC>           ;GET NEXT CHARACTER
43800   IFE     LENGTH-2,<
43820           PUSH    D               ;SAVE EXPONENT INFORMATION
43840           MOV     A,B             ;INCREMENT DECIMAL PLACE COUNT IF WE ARE
43860           ADC     C               ; PAST THE DECIMAL POINT
43880           MOV     B,A
43900           PUSH    B               ;SAVE DECIMAL POINT INFORMATION
43920           PUSH    H               ;SAVE TEXT POINTER
43940           MOV     A,M             ;GET THE DIGIT
43960           SUI     "0"             ;CONVERT IT TO ASCII
43980           PUSH    PSW             ;SAVE THE DIGIT
44000           LDA     VALTYP          ;SEE WHAT KIND OF NUMBER WE HAVE
44020           CPI     4
44040           JNC     FINDGV          ;WE DO NOT HAVE AN INTEGER
44060           ;HERE TO PACK THE NEXT DIGIT OF AN INTEGER
44080           LHLD    FACLO           ;WE HAVE AN INTEGER, GET IT IN (HL)
44100           LXI     D,^D3277+$CODE  ;SEE IF WE WILL OVERFLOW
44120           COMPAR                  ;COMPAR RETURNS WITH CARRY ON IF
44140           JNC     FINDG2          ; (HL) .LT. (DE), SO THE NUMBER IS TOO BIG
44160           MOV     D,H             ;COPY (HL) INTO (DE)
44180           MOV     E,L
44200           DAD     H               ;MULTIPLY (HL) BY 2
44220           DAD     H               ;MULTIPLY (HL) BY 2, (HL) NOW IS 4*(DE)
44240           DAD     D               ;ADD IN OLD (HL) TO GET 5*(DE)
44260           DAD     H               ;MULTIPLY BY 2 TO GET TEN TIMES THE OLD (HL)
44280           POP     PSW             ;GET THE DIGIT
44300           MOV     C,A             ;SAVE IT SO WE CAN USE DAD, B IS ALREADY ZERO
44320           DAD     B               ;ADD IN THE NEXT DIGIT
44340           MOV     A,H             ;CHECK FOR OVERFLOW
44360           ORA     A               ;OVERFLOW OCCURRED IF THE MSB IS ON
44380           JM      FINDG1          ;WE HAVE OVERFLOW!!
44400           SHLO    FACLO           ;EVERYTHING IS FINE, STORE THE NEW NUMBER
44420   FINDGE: POP     H               ;ALL DONE, GET THE TEXT POINTER BACK
44440           POP     B               ;GET DECIMAL POINT INFORMATION BACK
44460           POP     D               ;GET EXPONENT INFORMATION BACK
44480           JMP     FINC            ;GET THE NEXT CHARACTER
44500           ;HERE TO HANDLE 32768, 32769
44520   FINDG1: MOV     A,C             ;GET THE DIGIT
44540           PUSH    PSW             ;PUT IT BACK ON THE STACK
44560           ;HERE TO CONVERT THE INTEGER DIGITS TO SINGLE PRECISION DIGITS
44580   FINDG2: CALL    CONSI           ;CONVERT THE INTEGER TO SINGLE PRECISION
44600           XRA     A               ;DO NOT TAKE THE FOLLOWING JUMP
44620           ;HERE TO DECIDE IF WE HAVE A SINGLE OR DOUBLE PRECISION NUMBER
44640   FINDGV: JNZ     FINDGD          ;FALL THROUGH IF VALTYP WAS 4 I.E. SNG PREC
44660           MOVRI   224,164,044,000 ;GET 1000000, DO WE HAVE 7 DIGITS ALREADY?
44680           CALL    FCOMP           ;IF SO, FAC .GE. 1000000
44700           JP      FINDG3          ;WE DO, CONVERT TO DOUBLE PRECISION
44720           POP     PSW             ;GET THE NEXT DIGIT
44740           CALL    FINLOG          ;PACK IT INTO THE FAC
44760           JMP     FINDGE          ;GET FLAGS OFF STACK AND WE ARE DONE
44780           ;HERE TO CONVERY A 7 DIGIT DINGLE PRECISION NUMBER TO DOUBLE PRECISION
44800   FINDG3: CALL    CONDS           ;CONVERT SINGLE TO DOUBLE PRECISION
44820           ;HERE TO PACK IN THE NEXT DIGIT OF A DOUBLE PRECISION NUMBER
44840   FINDGD: CALL    DMUL10          ;MULTIPLY THE FAC BY 10
44860           CALL    VMOVAF          ;SAVE THE FAC IN ARG
44880           POP     PSW             ;GET THE NEXT DIGIT
44900           CALL    FLOAT           ;CONVERT THE DIGIT TO SINGLE PRECISION
44920           CALL    CONDS           ;NOW, CONVERT THE DIGIT TO DOUBLE PRECISION
44940           CALL    DADD            ;ADD IN THE DIGIT
44960           JMP     FINDGE>         ;GET THE FLAGS OFF THE STACK AND WE ARE DONE
45000   IFN     EXTFNC,<
45020           ;SUBROUTINE FOR FIN, LOG
45040   FINLOG: CALL    PUSHF           ;SAVE FAC ON STACK
45060           CALL    FLOAT           ;CONVERT A TO A FLOATING POINT NUMBER
45080   IFN     LENGTH-2,<
45100           JMP     FADDT>          ;ADD IT IN
45120   IFE     LENGTH-2,<
45140           POPR                    ;GET PREVIOUS NUMBER OFF STACK
45160           JMP     FADD>>          ;ADD IT IN
45200           ;HERE WE PACK IN THE NEXT DIGIT OF THE EXPONENT
45220           ;WE MULTIPLY THE OLD EXPONENT BY TEN AND ADD IN THE NEXT DIGIT
45240           ;NOTE: EXPONENT OVERFLOW IS NOT CHECKED FOR
45260   FINEDG: MOV     A,E             ;EXPONENT DIGIT -- MULTIPLY EXPONENT BY 10
45280           RLC                     ;FIRST BY 4
45300           RLC
45320           ADD     E               ;ADD 1 TO MAKE 5
45340           RLC                     ;NOW DOUBLE TO GET 10
45360           ADD     M               ;ADD IT IN
45380           SUI     "0"             ;SUBTRACT OFF ASCII CODE
45400           MOV     E,A             ;STORE EXPONENT
45420           JMP     FINEC           ;CONTINUE
45440   PAGE
45460   SUBTTL  FLOATING POINT OUTPUT ROUTINE
45480           ;ENTRY TO LINPRT
45500   INPRT:  PUSH    H               ;SAVE LINE NUMBER
45520           LXI     H,INTXT##       ;PRINT MESAGE
45540           CALL    STROUT
45560           POP     H               ;FALL INTO LINPRT
45620           ;PRINT THE 2 BYTE NUMBER IN H,L
45640           ;ALTERS ALL REGISTERS
45660   LINPRT:
45700   IFN     LENGTH-2,<
45720           XCHG                    ;SET UP REGISTERS FOR FLOATR
45740           XRA     A
45760           MVI     B,230
45760           CALL    FLOATR          ;CONVERT TO FLOATING POINT
45780   IFE     LENGTH-2,<
45800           CALL    CONISS          ;PUT THE LINE NUMBER IN THE FAC AS AN INTEGER
45820           XRA     A               ;SET FORMAT TO FREE FORMAT
45840           CALL    FOUINI          ;SET UP THE SIGN
45860           LXI     H,STROUI##      ;PUT PRINT STRING ADDRESS ON STACK SO WE WILL
45880           PUSH    H               ; RETURN TO IT AND DO AN "INX   H"
45900                                   ;THIS GETS RID OF THE SPACE FOR THE SIGN AT
45920                                   ; THE BEGINNING OF A LINE NUMBER
45940                                   ;FALL INTO FOUT
45960   IFE     LENGTH-2,<
45980           PUSH    B               ;PUT DUMMY FIELD LENGTHS ON STACK
46000           JMP     STROUI##        ;PRINT THE NUMBER
46060           ;FLOATING OUTPUT OF FAC
46080           ;ALTERS ALL REGISTERS
46100           ;THE ORIGINAL CONTENTS OF THE FAC IS LOST
46120   IFN     LENGTH-2,<
46140   FOUT1:  LXI     H,FBUFFR        ;GET BEGINING OF CHARACTER BUFFER
46160           PUSH    H               ;SAVE IT FOR WHEN WE RETURN
46180           ;PUT THE SIGN OF THE NUMBER IN THE BUFFER AND MAKE IT POSITIVE
46200           FSIGN                   ;GET SIGN OF NUMBER
46220           MVI     M," "           ;PRINT SPACE IF POSITIVE
46240           JP      FOUT1
46260           MVI     M,"-"           ;PRINT A MINUS SIGN IF NEGATIVE
46280   FOUT1:  INX     H               ;INCREMENT POINTER TO NEXT CHRACTER POSIT
46300           MVI     M,"0"           ;PUT A ZERO IN BUFFER IN CASE NUMBER=0
46320           JZ      FOUT19          ;DO IT IF THE NUMBER IS ZERO
46340           PUSH    H               ;SAVE BUFFER POINTER
46360           CM      NEG             ;NEGATE NUMBER IF NEGATIVE
46400   ;HERE WE GET THE FAC IN THE RANGE 100000 .LE. FAC .LE. 999999 AND ROUND IT TO
46420   ;AN INTEGER.  WE KEEP A COUNT OF HOW MANY TIMES WE MULTIPLY OR DIVIDE BY TEN
46440   ;SO WE KNOW WHAT THE EXPONENT WILL BE.  THE FAC IS THEN CONVERTED TO AN
46460   ;INTEGER IN C,D,E.  WE USE A TABLE OF POWERS OF TEN TO CALCULATE EACH DIGIT.
46480   ;THIS ALGORITHM IS USED FOR SPEED.
46500           XRA     A               ;PUT TEN'S EXPONENT COUNT ON STACK
46520           PUSH    PSW
46540           CALL    FOUTCB          ;SEE IF NUMBER IS TOO BIG OR TOO SMALL
46560   FOUT3:  MOVRI   221,103,117,370 ;IS NUMBER .LE. 99999.9499?  IT IS TOO SMALL
46580           CALL    FCOMP           ;FCOMP RETURNS 377, 0 OR 1 IN A, SO THE
46600                                   ; PARITY WILL BE OFF IFF 1 IS RETURN
46620           JPO     FOUT5           ;NO, NUMBER IS IN RANGE
46640           POP     PSW
46660           CALL    FINMLT          ;YES, MULTIPLY IT BY TEN TO GET
46680           PUSH    PSW             ; IT IN RANGE
46700           JMP     FOUT3           ;SEE IF NUMBER IS NOW IN RANGE
46720   FOUT9:  CALL    DIV10           ;NO, DIVIDE NUMBER BY TEN, IT IS TOO BIG
46740           POP     PSW             ;ADD ONE TO EXPONENT
46760           INR     A
46780           PUSH    PSW
46800           CALL    FOUTCB          ;IS NUMBER .LE. 999999.499?
46820                                   ;YES, NUMBER IS IN PRINTING RANGE, I.E.
46840                                   ; ALL DIGITS TO BE PRINTED ARE THE INTEGER PART
46860   FOUT5:  CALL    FADDH           ;ROUND NUMBER TO NEAREST INTEGER
46880           INR     A               ;MAKE A NON-ZERO, SINCE NUMBER IS POSITIVE
46900                                   ; AND NON-ZERO, ROUND WILL EXIT WITH THE HO
46920                                   ; IN A, SO THE MSB WILL ALWAYS BE ZERO AND
46940                                   ; ADDING ONE WILL NEVER CAUSE A TO BE ZERO
46960           CALL    QINT            ;GET INTEGER PART IN C,D,E
46980           CALL    MOVFR           ;SAVE NUMBER IN FAC
47000           ;DECIDE IF THE NUMBER SHOULD BE PRINTED IN FIXED OR FLOATING NOTATION
47020           LXI     B,2*400+6+$CODE ;SET DECIMAL POINT COUNT FOR E NOTATION
47040                                   ;C = DIGIT COUNT
47060           POP     PSW             ;GET EXPONENT
47080           ADD     C               ;SHOULD THE NUMBER BE PRINTED IN E NOTATION?
47100           JM      FOUT6           ;YES, IT IS .LT. 1
47120           CPI     7
47140           JNC     FOUT6           ;YES,  IT IS .GT. 999999
47160           INR     A
47180           MOV     B,A             ;B = DECIMAL POINT COUNT
47200           MVI     A,1             ;SET FIXED POINT FLAG, THE EXPONENT IS ZERO
47220                                   ; IF WE ARE USING FIXED POINT NOTATION
47240   FOUT6:  DCR     A               ;E NOTATION: ADD 5 TO ORIGINAL EXPONENT
47260           POP     H               ;GET BUFFER POINTER FROM STACK
47280           PUSH    PSW             ;SAVE EXPONENT FOR LATER
47300           ;CALCULATE THE DIGITS OF THE NUMBER
47320           LXI     D,FOUTBL        ;STORE LOC OF LARGEST POWER OF TEN
47340   FOUT8:  DCR     B               ;SEE IF IT IS TIME TO PRINT A DECIMAL POINT
47360           MVI     M,"."           ;PUT A DECIMAL POINT IN THE BUFFER
47380           CZ      INXHRT          ;INCREMENT THE BUFFER POINTER IF IT IS TIME
47400           PUSH    B               ;SAVE FLAGS
47420           PUSH    H               ;SAVE CHARCATER POINTER
47440           PUSH    D               ;SAVE POWER OF TEN POINTER
47460           CALL    MOVRF           ;GET NUMBER IN C,D,E
47480           POP     H               ;GET POWER OF TEN POINTER
47500           MVI     B, "0"-1        ;B = NEXT DIGIT TO BE PRINTED
47520   FOUT10: INR     B               ;ADD ONE TO DIGIT
47540           MOV     A,E             ;SUBTRACT LO
47560           SUB     M
47580           MOV     E,A
47600           INX     H               ;POINT TO NEXT BYTE OF POWER OF TEN
47620           MOV     A,D             ;SUBTRACT MO
47640           SBB     M
47660           MOV     D,A
47680           INX     H
47700           MOV     A,C             ;SUBTRACT HO
47720           SBB     M
47740           MOV     C,A
47760           DCX     H               ;POINT TO BEGINNING OF POWER OF TEN
47780           DCX     H
47800           JNC     FOUT10          ;SUBTRACT AGAIN IF RESULT WAS POSITIVE
47820           CALL    FADDA           ;IT WASN'T, ADD POWER OF TEN BACK IN
47840           INX     H               ;INCREMENT POINTER TO NEXT POWER OF TEN
47860           CALL    MOVFR           ;SAVE C,D,E IN FAC
47880           XCHG                    ;GET POWER OF TEN POINTER IN (DE)
48900           POP     H               ;GET BUFFER POINTER
48920           MOV     M,B             ;PUT CHARACTER IN BUFFER
48940           INX     H               ;INCREMENT BUFFER POINTER
48960           POP     B               ;GET COUNTERS OFF STACK
48980           DCR     C               ;WAS THAT THE LAST DIGIT
48000           JNZ     FOUT8           ;DO MORE IF NOT
48020           DCR     B               ;SEE IF DECIMAL POINT GOES AFTER LAST DIGIT
48040           JZ      FOUT12          ;IT DOES, WE HAVE NO ZEROES TO SUPPRESS
48060           ;SUPPRESS THE TRAILING ZEROS
48080   FOUT11: DCX     H               ;GO BACK TO LAST CHARACTER
48100           MOV     A,M             ;GET IT
48120           CPI     "0"             ;IGNORE TRAILING ZEROS
48140           JZ      FOUT11
48160           ;SUPPRESS DECIMAL POINT IF WE HAVE AN INTEGER
48180           CPI     "."             ;IGNORE DECIMAL POINT BEFORE TRAILING ZEROS
48200           CNZ     INXHRT          ;IF NO DP, MOVE POINER TO NEXT POSITION
48220   FOUT12: POP     PSW             ;GET DECIMAL EXPONENT
48240           JZ      FOUT17          ;RETURN IF NUMBER WAS IN FIXED POINT FORMAT
48260           ;FLOATING POINT NOTATION -- PUT AN "E" IN THE BUFFER
48280           MVI     M,"E"           ;PUT AN "E" IN THE BUFFER
48300           INX     H               ;PUT SIGN OF EXPONENT IN BUFFER
48320           ;PUT IN THE SIGN OF THE EXPONENT
48340           MVI     M,"+"           ;A PLUS IF POSITIVE
48360           JP      FOUT14
48380           MVI     M,"-"           ;A MINUS IF NEGATIVE
48400           CMA                     ;NEGATE EXPONENT
48420           INR     A
48440           ;CALCULATE THE TWO DIGIT EXPONENT
48460   FOUT14: MVI     B,"0"-1         ;INITIALIZE TEN'S DIGIT COUNT
48480   FOUT15: INR     B               ;INCREMENT DIGIT
48500           SUI     12              ;SUBTRACT TEN
48520           JNC     FOUT15          ;DO IT AGAIN IF RESULT WAS POSITIVE
48540           ADI     "0"+12          ;ADD BACK IN TEN AND CONVERT TO ASCII
48560           LPUT THE EXPONENT IN THE BUFFER
48580           INX     H
48600           MOV     M,B             ;PUT TEN'S DIGIT OF EXPONENT IN BUFFER
48620   FOUT19: INX     H               ;WHEN WE JUMP TO HERE, A IS ZERO
48640           MOV     M,A             ;PUT ONE'S DIGIT IN BUFFER
48660           INX     H               ;INCREMENT POINTER
48680   FOUT17: MOV     M,C             ;PUT ZERO AT END OF BUFFER
49700           POP     H               ;EXIT WITH (HL) POINTING TO STRING
49720           RET                     ;ALL DONE
49760           ;SEE IF FAC .LE. 999999.499
49780   FOUTCB: MOVRI   224,164,043,367 ;COMPARE NUMBER WITH CONSTANT
49800           CALL    FCOMP
48820           POP     H               ;GET RETURN ADDRESS OFF STACK
48840           JPO     FOUT9           ;NUMBER TOO BIG, DIVIDE BY TEN
48860           PCHL                    ;NUMBER OK, RETURN
48900           ;CONSTANTS FOR FOUT
48920   FHALF:  000     ;1/2
48940           000     ;THIS CONSTANT IS ALSO USED BY SQR, SIN, COS
48960           000
48980           200
49000           ;POWER OF TEN TABLE
49020   FOUTBL: 240     ; 100000
49040           206
49060           001
49080           020     ; 10000
49100           047
49120           000
49140           350     ; 1000
49160           003
49180           000
49200           144     ; 100
49220           000
49240           000
49260           012     ; 10
49280           000
49300           000
49320           001     ; 1
49340           000
49360           000>
49380   IFE     LENGTH-2,<
49400           ;OUTPUT THE VALUE IN THE FAC ACCORDING TO THE FORMAT SPECIFICATIONS
49420           ; IN A,B,C
49440           ;ALL REGISTERS ARE ALTERED
49460           ;THE ORIGINAL CONTENTS OF THE FAC IS LOST
49480
49500           ;THE FORMAT IS SPECIFIED IN A, B AND C AS FOLLOWS:
49520           ;THE BITS OF A MEAN THE FOLLOWING:
49540   ;BIT 7  0 MEANS FREE FORMAT OUTPUT, I.E. THE OTHER BITS OF A MUST BE ZERO,
49560   ;       TRAILING ZEROS ARE SUPPRESSED, A NUMBER IS PRINTED IN FIXED OR FLOATING
49580   ;       POINT NOTATION ACCORDING TO ITS MAGNITUDE, THE NUMBER IS LEFT
49600   ;       JUSTIFIED IN ITS FIELD, B AND C ARE IGNORED.
49620   ;MD     1 MEANS FIXED FORMAT OUTPUT, I.E. THE OTHER BITS OF A ARE CHECKED FOR
49640   ;MD     FORMATTING INFORMATION, THE NUMBER IS RIGHT JUSTIFIED IN ITS FIELD,
49660   ;MD     TRAILING ZEROS ARE NOT SUPPRESSED.  THIS IS USED FOR PRINT USING.
49680   ;BIT 6  1 MEANS GROUP THE DIGITS IN THE INTEGER PART OF THE NUMBER INTO GROUPS
49700   ;MD     OF THREE AND SEPARATE THE GROUPS BY COMMAS
49720   ;MD     0 MEANS DON'T PRINT THE NUMBER WITH COMMAS
49740   ;BIT 5  1 MEANS FILL THE LEADING SPACES IN THE FIELD WITH ASTERISKS ("*")
49760   ;BIT 4  1 MEANS OUTPUT THE NUMBER WITH A FLOATING DOLLAR SIGN ("$")
49780   ;BIT 3  1 MEANS PRINT THE SIGN OF A POSITIVE NUMBER AS A PLUS SIGN ("+")
49800   ;       INSTEAD OF A SPACE
49820   ;BIT 2  1 MEANS PRINT THE SIGN OF THE NUMBER AFTER THE NUMBER
49840   ;BIT 1  UNUSED
49860   ;BIT 0  1 MEANS PRINT THE NUMBER IN FLOATING POINT NOTATION I.E. "E NOTATION"
49880   ;       IF THIS BIT IS ON, THE COMMA SPECIFICATION (BIT 6) IS IGNORED.
49900   ;MD     0 MEANS PRINT THE NUMBER IN FIXED POINT NOTATION.  NUMBER .GE. 1E16
49920   ;       CANNOT BE PRINTED IN FIXED POINT NOTATION.
49940
49960           ;B AND C TELL HOW BIG THE FIELD IS:
49980   ;B  =   THE NUMBER OF PLACES IN THE FIELD TO THE LEFT OF THE DECIMAL POINT
50000   ;       (B DOES NOT INCLUDE THE DECIMAL POINT)
50020   ;C  =   THE NUMBER OF PLACES IN THE FIELD TO THE RIGHT OF THE DECIMAL POINT
50040   ;MD     (C INCLUDES THE DECIMAL POINT)
50060   ;MD     B AND C DONOT INCLUDE THE 4 POSITIONS FOR THE EXPONENT IF BIT 0 IS ON
50080           ;FOUT ASSUMES B+C .LE. 24 (DECIMAL)
50100
50120           ;ENTRY TO PRINT THE FAC IN FREE FORMAT
50140   FOUT:   XRA     A               ;SET FORMAT FLAGS TO FREE FORMATED OUTPUT
50160           ;ENTRY TO PRINT THE FAC USING THE FORMAT SPECIFICATIONS IN A, B, AND C
50180   PUFOUT: CALL    FOUINI          ;SAVE THE FORMAT SPECIFICATION IN A AND PUT
50200                                   ;A SPACE FOR POSITIVE NUMBERS IN THE BUFFER
50220           PUSH    B               ;SAVE THE FIELD LENGTH SPECIFICATIONS
50240           ANI     10              ;CHECK IF POSITIVE NUMBERS GET A PLUS SIGN
50260           JZ      FOUT1           ;THEY DON'T
50280           MVI     M,"+"           ;THEY DO, PUT IN A PLUS SIGN
50300   FOUT1:  LDA     VALTYP          ;SEE WHAT KIND OF A VALUE WE HAVE
50320           MOV     B,A             ;SAVE IT
50340           XCHG                    ;SAVE BUFFER POINTER
50360           MOV     A,B             ;GET THE SIGN OF THE FAC
50380           XCHG                    ;PUT THE BUFFER POINTER BACK IN (HL)
50400           MOV     A,B             ;GET THE VALTYP BACK
50420           JP      FOUT2           ;IF WE HAVE A NEGATIVE NUMBER, NEGATE IT
50440           MVI     M,"-"           ; AND PUT A MINUS SIGN IN THE BUFFER
50460           PUSH    H               ;SAVE THE BUFFER POINTER
50480           CALL    VNEG            ;NEGATE THE NUMBER
50500           POP     H               ;GET THE BUFFER POINTER BACK
50520   FOUT2:  INX     H               ;POINT TO WHERE THE NEXT CHARACTER GOES
50540           LDA     TEMP3           ;GET THE FORMAT SPECIFICATION
50560           MOV     D,A             ;SAVE IT FOR LATER
50580           RAL                     ;PUT THE FREE FORMAT OR NOT BIT IN THE CARRY
50600           LDA     VALTYP          ;GET THE VALTYP, VNEG COULD HAVE CHANGED THIS
50620                                   ; SINCE -32768 IS INT AND 32768 IS SNG,
50640                                   ; SO B IS NOT ACCURATE
50660           JC      FOUTFX          ;THE MAN WANTS FIXED FORMATTED OUTPUT
50680           ;HERE TO PRINT NUMBERS IN FREE FORMAT
50700           POP     B               ;WE CAN IGNORE THE OLD B AND C
50720           MVI     "0"             ;PUT A ZERO IN THE BUFFER IN CASE THE NUMBER
50740           JZ      FOUTZR          ; IS ZERO.  IT IS, FINISH IT UP
50760           CPI     4               ;DECIDE WHAT KIND OF A VALUE WE HAVE
50780           JNC     FOUFRV          ;WE HAVE A SNG OR DBL
50800           ;HERE TO PRINT AN INTEGER IN FREE FORMAT
50820           LXI     B,$CODE         ;SET THE DECIMAL POINT COUNT AND COMMA COUNT
50840                                   ; TO ZERO
50860           CALL    FOUTCI          ;CONVERT THE INTEGER TO DECIMAL
50880                                   ;FALL INTO FOUTZS AND ZERO SUPPRESS THE THING
50900
50920           ;ZERO SUPPRESS THE DIGITS IN FBUFFR
50940           ;ASTERISK FILL AND ZERO SUPPRESS IF NECESSARY
50960           ;SET UP B AND CONDITION CODES IF WE HAVE A TRAILING SIGN
50980   FOUTZS: LXI     H,FBUFFR+1      ;GET POINTER TO THE SIGN
51000           MOV     B,M             ;SAVE THE SIGN IN B
51020           MVI     C," "           ;DEFAULT FILL CHARACTER TO A SPACE
51040           LDA     TEMP3           ;GET FORMAT SPECS TO SEE IF WE AHVE TO
51060           MOV     E,A             ; ASTERISK FILL.  SAVE IT
51080           ANI     40
51100           JZ      FOTZS1          ;WE DON'T
51120           MOV     A,B             ;WE DO, SEE IF THE SIGN WAS A SPACE
51140           CMP     C               ;ZERO FLAG IS SET IF IT WAS
51160           MVI     C,"*"           ;SET FILL CHARACTER TO AN ASTERISK
51180           JNZ     FOTZS1          ;SET THE SIGN TO AN ASTERISK IF IT WAS A SPACE
51200           MOV     B,C             ;B HAS THE SIGN, C THE FILL CHARACTER
51220   FOTZS1: MOV     M,C             ;FILL IN THE ZERO OR THE SIGN
51240           CHRGET                  ;GET THE NEXT CHARACTER IN THE BUFFER
51260                                   ;SINCE THERE ARE NO SPACES, "CHRGET" IS
51280                                   ; EQUIVALENT TO "INX    H"/"MOV A,M"
51300           CPI     "0"             ;DO WE HAVE A ZERO?
51320           JZ      FOTZS1          ;YES, SUPPRESS IT
51340           CPI     54              ;54=","  DO WE HAVE A COMMA?
51360           JZ      FOTSZ1          ;YES. SUPPRESS IT
51380           CPI     "."             ;ARE WE AT THE DECIMAL POINT?
51400           JNZ     FOTZS2          ;NO, I GUESS NOT
51420           DCX     H               ;YES, BACK UP AND PUT A ZERO BEFORE IT
51440           MVI     M,"0"
51460   FOTZS2: MOV     A,E             ;GET THE FORMAT SPECS TO CHECK FOR A FLOATING
51480           ANI     20              ; DOLLAR SIGN
51500           JZ      FOTZS3          ;WE DON'T HAVE ONE
51520           DCX     H               ;WE HAVE ONE, BACK UP AND PUT IN THE DOLLAR
51540           MVI     M,"S"           ; SIGN
51560   FOTZS3: MOV     A,E             ;DO WE HAVE A TRAILING SIGN?
51580           ANI     4
51600           RNZ                     ;YES, RETURN; NOTE THE NON-ZERO FLAG IS SET
51620   FOFXIS: DCX     H               ;NO, BACK UP ONE AND PUT THE SIGN BACK IN
51640                                   ;PEOPLE JUMP HERE WHO WANT A "DCX       H" AND
51660                                   ; DON'T CARE ABOUT M
51680           MOV     M,B             ;PUT IN THE SIGN
51700           RET                     ;ALL DONE
51720
51740           ;HERE TO INITIALLY SET UP THE FORMAT SPECS AND PUT A SPACE FOR THE
51760           ;SIGN OF A POSITIVE NUMBER
51780   FOUINI: STA     TEMP3           ;SAVE THE FORMAT SPECIFICATION
51800           LXI     H,FBUFFR+1      ;GET A POINTER INTO BUGGET
51820           MVI     M," "           ;PUT IN A SPACE
51840           RET                     ;ALL DONE
51860
51880           ;HERE TO PRINT A SNG OR DBL IN FREE FORMAT
51900   FOUFRV: PUSH    H               ;SAVE THE BUFFER POINTER
51920           JZ      FOUFRS          ;WE HAVE A SNG
51940           ;HERE TO SET UP THE FLAG TO PRINT A DBL IN FREE FORMAT
51960           MVI     D,20            ;WE HAVE A DBL, SET THE DIGIT COUNT
51980           XWD     1000,001        ;"LXI   B" OVER THE NEXT TWO BYTES
52000           ;HERE TO SET UP THE FLAG TO PRINT A SNG IN FREE FORMAT
52020   FOUFRS: MVI     D,6             ;SET THE DIGIT COUNT
52040           CALL    FOUTNV          ;NORMALIZE THE FAC SO ALL SIGNIFICANT DIGITS
52060                                   ; ARE IN THE INTEGER PART
52080           LXI     B,2*400+$CODE   ;B = DECIMAL POINT COUNT
52100                                   ;C = COMMA COUNT
52120                                   ;SET COMMA COUNT TO ZERO AND DECIMAL POINT
52140                                   ; COUNT FOR E NOTATION
52160           ADD     D               ;SEE IF NUMBER SHOULD BE PRINTED IN E NOTATION
52180           JM      FOFRS1          ;IT SHOULD, IT IS .LT .1
52200           INR     D               ;CHECK IF IT IS TOO BG
52220           CMP     D
52240           JNC     FOFRS1          ;IT IS TOO BIG, IT IS .GT. 10^D-1
52260           INR     A               ;IT IS OK FOR FIXED POINT NOTATION
52280           MOV     B,A             ;SET DECIMAL POINT COUNT
52300           MVI     A,1             ;SET FIXED POINT FLAG, THE EXPONENT IS ZERO
52320                                   ; IF WE ARE USING FIXED POINT NOTATION
52340   FOFRS1: DCR     A               ;E NOTATION: ADD D-1 TO ORIGINAL EXPONENT
52360           POP     H               ;GET THE BUGGER POINTER BACK
52380           PUSH    PSW             ;SAVE THE EXPONENT FOR LATER
52400           CALL    FOUTCV          ;CONVERT THE NUMBER TO DECIMAL DIGITS
52420           ;HERE TO SUPPRESS THE TRAILING ZEROS
52440   FOFRS2: DCX     H               ;MOVE BACK TO THE LAST CHARACTER
52460           MOV     A,M             ;GET IT AND SEE IF IT WAS ZERO
52480           CPI     "0"
52500           JZ      FOFRS2          ;IT WAS, CONTINUE SUPPRESSING
52520           COU     "."             ;HAVE WE SUPPRESSED ALL THE FRACTIONAL DIGITS?
52540           CNZ     INXHRT          ;YES, IGNORE THE DECIMAL POINT ALSO
52560           POP     PSW             ;GET THE EXPONENT BACK
52580           JZ      FOUTON          ;WE ARE DONE IF WE ARE IN FIXED POINT NOTATION
52600                                   ;FALL IN AND PUT THE EXPONENT IN THE BUFFER
52620
52640           ;HERE TO PUT THE EXPONENT AND "E" OR "D" IN THE BUFFER
52660           ;THE EXPONENT IS IN A
52680   FOFLDN: MOV     B,A             ;SAVE THE EXPONENT
52700           LDA     VALTYP          ;GET THE VALTYP TO DEIDE IF WE PRINT AN "E"
52720           CPI     4               ; ON A "D"
52740           MOV     A,B             ;GET THE EXPONENT BACK
52760           JZ      FOUCEE          ;WE HAVE TO PRINT AN "E"
52780           MVI     M,"D"           ;GET THE "D"
52800           XWD     1000,001        ;"LXI   B" OVER THE NEXT TWO BYTES
52820   FOUCEE: MVI     M,"E"           ;GET AN "E"
52840           INX     H               ;PUT SIGN OF EXPONENT IN BUFFER
52860           ;PUT IN THE SIGN OF THE EXPONENT
52880           MVI     M,"+"           ;A PLUS IF POSITIVE
52900           JP      FOUCE1
52920           MVI     M,"-"           ;A MINUS IF NEGATIVE
52940           CMA                     ;NEGATE EXPONENT
52960           INR     A
52980           ;CALCULATE THE TWO DIGIT EXPONENT
53000   FOUCE1: MVI     B,"0"-1         ;INITIALIZE TEN'S DIGIT COUNT
53020   FOUCE2: INR     B               ;INCREMENT DIGIT
53040           SUI     12              ;SUBTRACT TEN
53060           JNC     FOUCE2          ;DO IT AGAIN IF RESULT WAS POSITIVE
53080           ADI     "0"+12          ;ADD BACK IN TEN AND CONVERT TO ASCII
53100           ;PUT THE EXPONENT IN THE BUFFER
53120           INX     H
53140           MOV     M,B             ;PUT THEN'S DIGIT OF EXPONENT IN BUFFER
53160           INX     H               ;WHEN WE JUMP TO HERE, A IS ZERO
53180           MOV     M,A             ;PUT ONE'S DIGIT IN BUFFER
53200   FOUTZR: INX     H               ;INCREMENT POINTER, HERE TO FINISH UP PRINTING
53220                                   ; A FREE FORMAT ZERO
53240   FOUTON: MVI     M,0             ;PUT A ZERO AT THE END OF THE NUMBER
53260           XCHG                    ;SAVE THE POINTER TO THE END OF THE NUMBER
53280                                   ; IN (DE) FOR FFXFLV
53300           LXI     H,FBUFFR+1      ;GET A POINTER TO THE BEGINNING
53320           RET                     ;ALL DONE
53340
53360           ;HERE TO PUT A POSSIBLE COMMA COUNT IN C, AND ZERO IF WE ARE NOT
53380           ;USING THE COMMA SPECIFICATION
53400   FOUTCC: MOV     C,A             ;SAVE A POSSIBLE COMMA COUNT
53420   FOUICC: LDA     TEMP3           ;GET THE FORMAT SPECS
53440           ANI     100             ;LOOK AT THE COMMA BIT
53460           RNZ                     ;WE ARE USING COMMAS, JUST RETURN
53480           MOV     C,A             ;WE AREN'T, ZERO THE COMMA COUNT
53500           RET                     ;ALL DONE
53520
53540           ;HERE TO PRINT A NUMBER IN FIXED FORMAT
53560   FOUTFC: CPI     4               ;CHECK WHAT KIND OF VALUE WE HAVE
53580           MOV     A,D             ;GET THE FORMAT SPECS
53600           JNC     FOUFXV          ;WE HAVE A SNG OR A DBL
53620           ;HERE TO PRINT AN INTEGER IN FIXED FORMAT
53640           RAR                     ;CHECK IF WE HAVE TO PRINT IT IN FLOATING
53660           JC      FFXIFL          ; POINT NOTATION
53680           ;HERE TO PRINT AN INTEGER IN FIXED FORMAT-FIXED POINT NOTATION
53700           LXI     B,6*400+3+$CODE ;SET DECIMAL POINT COUNT TO 6 AND
53720                                   ; COMMA COUNT TO 3
53740           CALL    FOICC           ;CHECK IF WE DON'T HAVE TO USE THE COMMAS
53760           POP     D               ;GET THE FIELD LENGTHS
53780           MOV     A,D             ;SEE IF WE HAVE TO PRINT EXTRA SPACES BECAUSE
53800           SUI     5               ; THE FIELD IS TOO BIG
53820           CP      FOTZER          ;WE DO, PUT IN ZEROS, THEY WILL LATER BE
53840                                   ; CONVERTED TO SPACES OR ASTERISKS BY FOUTZS
53860           PUSH    D               ;SAVE THE FIELD LENGTHS AGAIN
53880           CALL    FOUTC1          ;CONVERT THE NUMBER TO DECIMAL DIGITS
53900           POP     D               ;GET THE FIELD LENGTHS BACK
53920           ORA     E               ;DO WE NEED A DECIMAL POINT?  HERE A=0
53940           CZ      FOFXIS          ;WE DON'T, BACKSPACE OVER IT.  AT FOFXIS,
53960                                   ; WE DON'T CARE ABOUT B, WE ONLY WANT THE
53980                                   ; "DCX  H".  LATER ON WE WILL DO A "MVI M,0"
54000                                   ; AND COVER UP WHAT WAS IN B.
54020           CNZ     FOTZER          ;FOFXIS PRESERVED THE CONDITION CODES
54040                                   ;IF WE DO HAVE DECIMAL PLACES, FILL THEM UP
54060                                   ; WITH ZEROS
54080                                   ;FALL IN AND FINISH UP THE NUMBER
54100
54120           ;HERE TO FINISH UP A FIXED FORMAT NUMBER
54140   FOUTTS: PUSH    H               ;SAVE BUFFER POINTER
54160           CALL    FOUTZS          ;ZERO SUPPRESS THE NUMBER
54180           POP     H               ;GET THE BUFFER POINTER BACK
54200           JZ      FFXIX1          ;CHECK IF WE HAVE A TRAILING SIGN
54220           MOV     M,B             ;WE DO, PUT THE SIGN IN THE BUFFER
54240           INX     H               ;INCREMENT THE BUFFER POINTER
54260   FFXIXI: MVI     M,0             ;PUT A ZERO AT THE END OF THE NUMBER
54280
54300           ;HERE TO CHECK IF A FIXED FORMAT-FIXED POINT NUMBER OVERFLOWED ITS
54320           ;FIELD LENGTH
54340           ;D = THE B IN THE FORMAT SPECIFICATION
54360           ;THIS ASSUMES THE LOCATION OF THE DECIMAL POINT IS IN TEMP2
54380           LXI     H,FBUFFR        ;GET A POINTER TO THE BEGINNING
54400   FOUBE1: INX     H               ;INCREMENT POINTER TO THE NEXT CHARACTER
54420   FOUBE5: LDA     TEMP2           ;GET THE LOCATION OF THE DECIMAL POINT
54440           SUB     L               ;FIGURE OUT HOUW MUCH SPACE WE ARE TAKING
54460           SUB     D               ;IS THIS THE RIGHT AMOUNT OF SPACE TO TAKE?
54480           RZ                      ;YES, WE ARE DONE, RETURN FROM FOUT
54500           MOV     A,M             ;NO, WE MUST HAVE TOO MUCH SINCE WE STARTED
54520                                   ; CHECKING FROM THE BEGINNING OF THE BUFFER
54540                                   ; AND THE FIELD MUST BE SMALL ENOUGH TO FIT IN
54560                                   ; THE BUFFER.  GET THE NEXT CHARACTER IN
54580                                   ; THE BUFFER
54600           CPI     " "             ;IF IT IS A SPACE OR AN ASTERISK, WE CAN
54620           JZ      FOUBE1          ; IGNORE IT AND MAKE THE FIELD SHORTER WITH
54640           CPI     "*"             ; NO ILL EFFECTS
54660           JZ      FOUBE1
54680           DCX     H               ;MOVE THE POINTER BACK ONE TO READ THE
54700                                   ; CHARACTER WITH CHRGET
54720           PUSH    H               ;SAVE THE POINTER
54740
54760           ;HERE WE SEE IF WE CAN IGNORE THE LEADING ZERO BEFORE A DECIMAL POINT.
54780           ;THIS OCCURS IF WE SEE THE FOLLOWING: (IN ORDER)
54800           ;       A SIGN (EITHER "-" OR "+")      [OPTIONAL]
54820           ;       A DOLLAR SIGN                   [OPTIONAL]
54840           ;       A ZERO                          [MANDATORY]
54860           ;       A DECIMAL POINT                 [MANDATORY]
54880           ;       ANOTHER DIGIT                   [MANDATORY]
54900           ;IF YOU SEE A LEADING ZERO, IT MUST BE THE ONE BEFORE A DECIMAL POINT
54920           ;PR ELSE FOUTZS WOULD HAVE SUPPRESSED IT, SO WE CAN JUST "INX   H"
54940           ;OVER THE CHARACTER FOLLOWING THE ZERO, AND NOT CHECK FOR THE
54960           ;DECIMAL POINT EXPLICITLY.
54980   FOUBE2: PUSH    PSE             ;PUT THE LAST CHARACTER ON THE STACK.  THE
55000                                   ; ZERO FLAG IS SET.  THE FIRST TIME THE ZERO
55020                                   ; ZERO FLAG IS NOT SET.
55040           LXI     B,FOUBE2        ;GET THE ADDRESS WE GO TO IF WE SEE A CHARACTER
55060           PUSH    B               ; WE ARE LOOKING FOR
55080           CHRGET                  ;GET THE NEXT CHARACTER
55100           CPI     "-"             ;SAVE IT AND GET THE NEXT CHARACTER
55120           RZ                      ; A MINUS SIGN, A PLUS SIGN OR A DOLLAR SIGN
55140           CPI     "+"
55160           RZ
55180           CPI     "$"
55200           RZ
55220           POP     B               ;IT ISN'T, GET THE ADDRESS OFF THE STACK
55240           CPI     "0"             ;IS IT A ZERO?
55260           JNZ     FOUBE4          ;NO, WE CAN NOT GET RID OF ANOTHER CHARACTER
55280           INX     H               ;SKIP OVER THE DECIMAL POINT
55300           CHRGET                  ;GET THE NEXT CHARACTER
55320           JNC     FOUBE4          ;IT IS NOT A DIGIT, WE CAN'T SHORTEN THE FIELD
55340           DCX     H               ;WE CAN!!!  POINT TO THE DECIMAL POINT
55360           XWD     1000,001        ;"LXI   B" OVER THE NEXT 2 BYTES
55380   FOUBE3: DCX     H               ;POINT BACK ONE CHARACTER
55400           MOV     M,A             ;PUT THE CHARACTER BACK
55420
55440           ;IF WE CAN GET RID OF THE ZERO, WE PUT THE CHARACTERS ON THE STACK
55460           ;BACK INTO THE BUFFER ONE POSITION IN FRONT OF WHERE THEY ORIGINALLY
55480           ;WERE.  NOTE THAT THE MAXIMUM NUMBER OF STACK LEVELS THIS USES IS
55500           ;THREE -- ONE FOR THE LAST ENTRY FLAG, ONE FOR A POSSIBLE SIGN,
55520           ;AND ONE FOR A POSSIBLE DOLLAR SIGN.  WE DON'T HAVE TO WORRY ABOUT
55540           ;THE FIRST CHARACTER BEING IN THE BUFFER TWICE BECAUSE THE POINTER
55560           ;WHEN FOUT EXITS WILL BE POINTING TO THE SECOND OCCURANCE.
55580           POP     PSW             ;GET THE CHARACTER OFF THE STACK
55600           JZ      FOUBE3          ;PUT IT BACK IN THE BUFFER IF IT IS NOT THE
55620                                   ; LAST ONE
55640           POP     B               ;GET THE BUFFER POINTER OFF THE STACK
55660           JMP     FOUBE4          ;SEE IF THE FIELD IS NOW SMALL ENOUGH
55680           ;HERE IF THE NUMBER IS TOO BIG FOR THE FIELD
55700   FOUBE4: POP     PSW             ;GET THE CHARACTERS OFF THE STACK
55720           JZ      FOUBE4          ;LEAVE THE NUMBER IN THE BUFFER ALONE
55740           POP     H               ;GET THE POINTER TO THE BEGINNING OF THE
55760                                   ; NUMBER MINUTE 1
55780           MVI     M,"%"           ;PUT IN A PERCENT SIGN TO INDICATE THE NUMBER
55800                                   ; WAS TOO LARGE FOR THE FIELD
55820           RET                     ;ALL DONE -- RETURN FROM FOUT
55840
55860           ;HERE TO PRINT A SNG OR DBL IN FIXED FORMAT
55880   FOUFXV: PUSH    H               ;SAVE THE BUFFER POINTER
55900           RAR                     ;GET FIXED OR FLOATING NOTATION FLAG IN CARRY
55920           JC      FFXFLV          ;PRINT THE NUMBER IN E-NOTATION
55940           JZ      FFXSFX          ;WE HAVE A SNG
55960           ;HERE TO PRINT A DBL IN FIXED FORMAT--FIXED POINT NOTATION
55980           LXI     D,FFXDXM        ;GET POINTER TO 1D16
56000           CALL    DCOMPD          ;WE CAN'T PRINT A NUMBER .GE. 10^16 IN FIXED
56020                                   ; POINT NOTATION
56040           LXI     D,16*400+$CODE  ;SET D = NUMBER OF DIGITS TO PRINT FOR A DBL
56060                                   ;C = 0 FOR DBL (THIS IS FOR COMMAS)
56080           JM      FFXSDC          ;IF THE FAC WAS SMALL ENOUGH, GO PRINT IT
56100           ;HERE TO PRINT IN FREE FORMAT WITH A PERCENT SIGN A NUMBER .GE. 10^16
56120   FFXSDO: XRA     A               ;SET THE FORMAT SPECS TO FREE FORMAT
56140           STA     TEMP3
56160           POP     H               ;GET THE BUFFER POINTER
56180           DCX     H               ;SET IT UP TO JUMP BACK INTO FOUT
56200                                   ;NOW (HL)=FBUFFR+1
56220           CALL    FOUT1           ;PRINT THE NUMBER IN FREE FORMAT, THE SIGN
56240                                   ; IS ALREADY IN THE BUFFER
56260           DCX     H               ;POINT IN FRONT OF THE NUMBER
56280           MVI     M,"%"           ;PUT IN THE PERCENT SIGN
56300           RET                     ;ALL DONE--RETURN FROM FOUT
56320           ;HERE TO PRINT A SNG IN FIXED FORMAT--FIXED POINT NOTATION
56340   FFXSFX: MOVRI   226,016,033,312 ;GET 1E16, CHECK IF THE NUMBER IS TOO BIG
56360           CALL    FCOMP
56380           JP      FFXSD0          ;IT IS,PRINT IT IN FREE FORMAT WITH A % SIGN
56400           LXI     D,6*400+2+$CODE ;SET UP FLAGS FOR SNG --
56420                                   ;D = NUMBER OF DIGITS TO PRINT IN A SNG
56440                                   ;C = 2 (THIS IS FOR THE COMMAS)
56460           ;HERE TO ACTUALLY PRINT A SNG OR DBL IN E NOTATION
56480   FFXSDC: FSIGN                   ;SEE IF WE HAVE ZERO
56500           CNZ     FOUTNV          ;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
56520                                   ; BE PRINTED ARE IN THE INTEGER PART
56540           POP     H               ;GET THE BUFFER POINTER
56560           POP     B               ;GET THE FIELD LENGTH SPECS
56580           JM      FFXXVS          ;DO DIFFERENT STUFF IF ??? EXPONENT IS NEGATIVE
56600           ;HERE TO PRINT A NUMBER WITH NO FRACTIONAL DIGITS
56620           PUSH    B               ;SAVE THE FIELD LENGTH SPECS AGAIN
56640           MOV     C,A             ;SAVE THE EXPONENT
56660           MOV     A,B             ;WE HAVE TO PRINT LEADING ZEROS IF THE FIELD
56780           SUB     D               ; HAS MORE CHARACTERS THAN THERE ARE DIGITS IN
56700           SUB     C               ; THE NUMBER
56720           CP      FOTZER          ;FOUTZS WILL LATER SUPPRESS THEM
56740           MOV     A,C             ;SET UP THE COMMA COUNT
56760           ADD     E
56780           MOV     E,C             ;WE NO LONGER NEED THE NUMBER WE SETUP IN E
56800   FFXXV1: SUI     3               ;REDUCE A MOD 3
56820           JNC     FFXXV1
56840           ADI     5               ;ADD 3 BACK AND ADD IN 2 MORE FOR SCALING
56860           CALL    FOUTCC          ;CHECK IF WE HAVE TO USE COMMAS AT ALL
56880           MOV     A,E             ;SETUP THE DECIMAL POINT COUNT
56900           ADD     D
56920           INR     A
56940           MOV     B,A             ;IT GOES IN B
56960           PUSH    D               ;SAVE SNG OR DBL AND EXPONENT INFORMATION
57980           CALL    FOUTCV          ;CONVERT THE NUMBER TO DECIMAL DIGITS
57000           POP     D               ;GET THE SNG OR DBL AND EXPONENT INFO BACK
57020           ORA     E               ;PUT IN DIGITS AFTER THE NUMBER IF IT
57040                                   ; IS BIG ENOUGH, HERE A=0
57060           CNZ     FOTZRC          ;THERE CAN BE COMMAS IN THESE ZEROS
57080           POP     D               ;GET THE FIELD LENGTH SPECS
57100           ORA     E               ;HERE A=0
57120           CNZ     FOUTDP          ;PRINT A DECIMAL POINT IF NECESSARY
57140           DCR     A               ;SEE IF WE SHOULD PRINT SOME ZEROS TO FILL IN
57160           CP      FOTZER          ; THE DECIMAL PLACES
57180           JMP     FOUTTS          ;GO CHECK THE SIZE, ZERO SUPPRESS, ETC. AND
57200                                   ; FINISH THE NUMBER
57220           ;HERE TO PRINT A SNG OR DBL THAT HAS FRACTIONAL DIGITS
57240   FFXXVS: MOV     E,A             ;SAVE THE EXPONENT, WE DON'T NEED WHAT IS IN E
57260           MOV     A,C             ;DIVIDE BY TEN THE RIGHT NUMBER OF TIMES SO
57280           ORA     A               ; THE RESULT WILL BE ROUNDED CORRECTLY AND
57300           CNZ     DCRART          ; HAVE THE CORRECT NUMBER OF SIGNIFICANT
57320           ADD     E               ; DIGITS
57340           PUSH    PSW             ;SAVE THIS NUMBER FOR LATER
57360   FFXXV2: CM      FINDIV          ;THIS IS THE DIVIDE LOOP
57380           JM      FFXXV2
57400           MOV     A,E             ;WE HAVE TWO CASES DEPENDING ON WHETHER THE
57420           ADD     D               ; THE NUMBER IS .LT. .1 OR NOT
57440           MOV     A,B
57460           JM      FFXXV3
57480           ;HERE TO PRINT NUMBERS .GE. .1
57500           SUB     D               ;PRINT SOME LEADING ZEROS IF THE FIELD IS
57520           SUB     E               ; BIGGER THAN THE NUMBER OF DIGITS WE WILL
57540           CP      FOTZER          ; PRINT
57560           POP     PSW             ;WE DON'T NEED THE NUMBER WE SAVED BEFORE
57580           MOV     B,E             ;GET ALL THE PERTINENT INFO IN B,C
57600           PUSH    B               ;SAVE THE EXPONENT AND "C" IN FIELD SPEC
57620           MOV     A,E             ;SET UP THE DECIMAL POINT COUNT
57640           ADD     D
57660           INR     A
57680           MOV     B,A
57700           MOV     A,D             ;SET UP THE COMMA COUNT
57720           ANI     2               ;THESE 2 INSTRUCTIONS MAP 6 TO 4
57740           ADI     2               ; AND 16 TO 2
57760           ADD     E
57780           CALL    FOUTCC          ;CHECK IF WE HAVE TO DO THE COMMA THING
57800           JMP     FFXXV6          ;CONVERT THE DIGITS AND DO THE TRIMMING UP
57820           ;HERE TO PRINT A NUMBER .LT. 1
57840   FFXXV3: CALL    FOTZER          ;PUT ALL ZEROS BEFORE THE DECIMAL POINT
57860           MOV     A,C             ;SAVE C
57880           CALL    FOUTOP          ;PUT IN A DECIMAL POINT
57900           MOV     C,A             ;RESTORE C
57920           POP     PSW             ;GET THE NUMBER WE SAVED
57940           JM      FFXXV4          ;DECIDE HOW MANY ZEROS TO PRINT BETWEEN THE
57960           XRA     A               ; DECIMAL POINT AND THE FIRST DIGIT WE WILL
57980           SUB     E               ; PRINT.  HERE THE FIELD IS BIG ENOUGH TO
58000           SUB     D               ; HOLD ALL THE DIGITS
58020           JMP     FFXXV5          ;GO PRINT THEM
58040   FFXXV4: MOV     A,C             ;HERE WE HAD TO DIVIDE BY TEN SO THE FIELD
58060           SUB     D               ; IS SMALLER THAN ALL SIGNIFICANT DIGITS IN
58080           DCR     A               ; THE NUMBER
58100   FFXXV5: CALL    FOTZER          ;PRINT THE ZEROS
58120           MOV     B,E             ;SAVE THE EXPONENT IN B
58140           PUSH    B               ;SAVE EXPONENT AND THE "C" IN THE FIELD SPEC
58160           MOV     B,A             ;ZERO THE DECIMAL PLACE COUNT
58180           MOV     C,A             ;ZERO THE COMMA COUNT
58200   FFXXV6: CALL    FOUTCV          ;CONVERT THE NUMBER TO DECIMAL DIGITS
58220           POP     D               ;GET THE EXPONENT AND FIELD SPEC BACK
58240           ORA     E               ;CHECK IF WE HAVE TO PRINT ANY ZEROS AFTER
58260                                   ; THE LAST DIGIT
58280           JZ      FFXXV7          ;CHECK IF THERE WERE ANY DECIMAL PLACES AT ALL
58300           ADD     D               ;PRINTE SOME MORE TRAILING ZEROS
58320           DCR     A
58340           CP      FOTZER
58360           JMP     FOUTTS          ;FINISH UP THE NUMBER
58380           ;THERE WERE NO DECIMAL PLACES, IGNORE ALL DIGITS AFTER THE DECIMAL
58400           ;POINT
58420   FFXXV7: LHLD    TEMP2           ;THE END OF THE NUMBER IS WHERE THE DP IS
58440           JMP     FOUTTS          ;FINISH UP THE NUMBER
58460
58480           ;HERE TO PRINT AN INTEGER IN FIXED FORMAT--FLOATING POING NOTATION
58500   FFXIFL: PUSH    H               ;SAVE THE BUFFER POINTER
58520           PUSH    D               ;SAVE THE FORMAT SPECS
58540           CALL    CONSI           ;CONVERT THE INTEGER TO A SNG
58560           POP     D               ;GET THE FORMAT SPECS BACK
58580           POP     H               ;GET THE BUFFER POINTER BACK
58600           XRA     A               ;SET FLAGS TO PRINT THE NUMBER AS A SNG
58620                                   ;FALL INTO FFXFLV
58640
58660           ;HERE TO PRINT A SNG OR DBL IN FIXED FORMAT-FLOTATING POINT NOTATION
58680   FFXFLV: JZ      FFXSFL          ;IF WE HAVE A SNG, SET THE RIGHT FLAGS
58700           MVI     E,20            ;WE HAVE A DBL, GET HOW MANY DIGITS WE HAVE
58720           XWD     1000,001        ;"LXI   B" OVER THE NEXT TWO BYTES
58740   FFXSFL: MVI     E,6             ;WE HAVE A DBL, GET HOW MANY DIGITS WE PRINT
58760           FSIGN                   ;SEE IF WE HAVE ZERO
58780           CNZ     FOUTNV          ;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
58800                                   ; BE PRINTED ARE IN THE INTEGER PART
58820           POP     H               ;GET THE BUFFER POINTER BACK
58840           POP     B               ;GET THE FIELD LENGTH SPECS
58860           PUSH    PSW             ;SAAVE THE EXPONENT
58880           MOV     A,C             ;CALCULATE HOW MANY SIGNIFICANT DIGITS WE MUST
58900           ORA     A               ; PRINT
58920           PUSH    PSW             ;SAVE THE "C" FIELD SPEC FOR LATER
58940           CNZ     DCRART
58960           ADD     B
58980           MOV     C,A
59000           MOV     A,D             ;GET THE FIELD SPEC
59020           ANI     4               ;SEE IF THE SIGN IS A TRAILING SIGN
59040           CPI     1               ;SET CARRY IF A IS ZERO
59060           SBB     A               ;SET D=0 IF WE HAVE A TRAILING SIGN,
59080           MOV     D,A             ; D=377 IF WE DO NOT
59100           ADD     C
59120           MOV     C,A             ;SET C=NUMBER OF SIGNIFICANT DIGITS TO PRINT
59140           SUB     E               ;IF WE HAVE LESS THAN E, THEN WE MUST GET RID
59160   FFXLV1: CM      FINDIV          ; OF SOME BY DIVIDING BY TEN AND ROUNDING
59180           JM      FFXLV1
59200           PUSH    B               ;SAVE THE "B" FIELD SPEC AND # OF SIG DIGITS
59220           MOV     A,B             ;SET THE DECIMAL PLACE COUNT
59240           INR     A
59260           SUB     D               ;TAKE INTO ACCOUNT IF THE SIGN IS TRAILING
59280           MOV     B,A
59300           MVI     C,0             ;SET COMMA COUNT TO ZERO, THE COMMA SPEC IS
59320           PUSH    D               ; IGNORED.  SAVE TRAILING SIGN INFO
59340           CALL    FOUTCV          ;CONVERT THE NUMBER TO DECIMAL DIGITS
59360           POP     D               ;GET THE TRAILING SIGN INFO BACK
59380           POP     B               ;GET # OF SIG DIGITS AND "B" FIELD SPEC BACK
59400           MOV     A,C             ;PRINT TRAILING ZEROS IF THE FIELD LENGTH IS
59420           SUB     E               ; LONGER THAN THE NUMBER OF DIGITS WE CAN PRINT
59440           CP      FOTZRC          ;THE DECIMAL POINT COULD COME OUT IN HERE
59460           POP     PSW             ;GET THE "C" FIELD SPEC BACK
59580           CZ      FOFXIS          ;IF C=0, THE LAST THING WAS A DECIMAL POINT,
59500                                   ; SO IGNORE IT/  ALL WE CARE ABOUT IS THE
59520                                   ; "DCX  H" AND NOT THE "MOV     M,B" AT FOFXIS
59540           POP     PSW             ;GET THE EXPONENT BACK
59560           ADD     E               ;SCALE IT CORRECTLY
59680           SUB     B
59600           SUB     D
59620           PUSH    B               ;SAVE THE "B" FIELD SPEC
59640           CALL    FOFLON          ;PUT THE EXPONENT IN THE BUFFER
59660           XCHG                    ;GET THE POINTER TO THE END IN (HL)
59680                                   ; IN CASE WE HAVE A TRAILING SIGN
59700           POP     D               ;GET THE "B" FIELD SPEC IN D, PUT ON A POSSIBLE
59720           JMP     FOUTTS          ; TRAILING SIGN AND WE ARE DONE
59740
59860           ;NORMALIZE THE NUMBER IN THE FAC SO ALL THE DIGITS ARE IN THE INTEGER
59880           ;PART,  RETURN THE BASE 10 EXPONENT IN A
59800           ;D,E ARE LEFT UNALTERED
59820   FOUTNV: PUSH    D               ;SAVE (DE)
59840           LDA     VALTYP          ;GET WHAT KIND OF VALUE WE HAVE
59860           CPI     4
59880           JNZ     FOUTND          ;WE HAVE A DBL
59900           ;NORMALIZE A SNG
59920           XRA     A               ;ZERO THE EXPONENT
59940           PUSH    PSW             ;SAVE IT
59960           CALL    FOUNDSC         ;IS THE FAC TOO BIG OR TOO SMALL?
59980   FOUNS1: MOVRI   221,103,117,370 ;GET 99999.9499 TO SEE IF THE FAC IS BIG
60000           CALL    FCOMP           ; ENOUGH YET
60020           JPO     FOUNS3          ;IT IS, WE ARE DONE
60040           POP     PSW             ;IT ISN'T, MULTIPLY BY TEN
60060           CALL    FINMLT
60080           PUSH    PSW             ;SAVE THE EXPONENT AGAIN
60100           JMP     FOUNDS1         ;NOW SEE IF IT IS BIG ENOUGH
60120   FOUNS2: POP     PSW             ;THE FAC IS TOO BIG, GET THE EXPONENT
60140           CALL    FINDIV          ;DIVIDE IT BY TEN
60160           PUSH    PSW             ;SAVE THE EXPONENT AGAIN
60180           CALL    FOUNSC          ;SEE IF THE FAC IS SMALL ENOUGH
60200   FOUNS3: POP     PSW             ;WE ARE DONE, GET THE EXPONENT BACK
60220           POP     D               ;GET (DE) BACK
60240           RET                     ;ALL DONE
60260           ;HERE TO SEE IF THE FAC IS SMALL ENOUGH YET
60280   FOUNSC: MOVRI   224,164,043,367 ;GET 999999.499 TO SEE IF THE FAC IS TOO BIG
60300           CALL    FCOMP
60320           POP     H               ;GET THE RETURN ADRESS OFF THE STACK
60340           JPO     FOUNS2          ;IT IS TOO BIG, MAKE IT SMALLER
60360           PCHL                    ;IT IS SMALL ENOUGH, RETURN
60380           ;HERE TO NORMALIZE A DBL NUMBER
60400   >
60420   PAGE
60440   SUBTTL  EXPONENTIATION AND THE SQUARE ROOT FUNCTION
60460   IFE     EXTFNC,<
60480           ;SQUARE ROOT FUNCTION  ---  X=SQR(A)
60500           ;FIRST WE SCALE THE ARUGMENT TO BETWEEN .5 AND 2 BY LOOKING AT THE
60520           ;EXPONENT AND USING SQR(M*2^(2*N))=2^N*SQR(M).  THEN NEWTON'S METHOD
60540           ;IS USED TO COMPUTE SQR(M).  THE EXPONENT IS SAVED TO SCALE THE
60560           ;RESULT AT THE END.
60580           ;NEWTON'S METHOD FOR SQUARE ROOT:
60600           ;  X(0)=A
60620           ;  X(N+1)=(X(N)+A/X(N))/2
60640   SQR:    FSIGN                   ;CHECK FOR ERROR CONDITION
60660           JM      FCERR           ;CAN'T TAKE SQR OF NEGATIVE NUMBER
60680           RZ                      ;  0=SQR(0)
60700           LXI     H,FAC           ;SCALE ARGUMENT TO BETWEEN .5 AND 2
60720           MOV     A,M             ;GET EXPONENT
60740           RAR                     ;GET EXPONENT OF SCALE FACTOR
60760                                   ;USE  SQR(M*2^(2*N))=2^N*SQR(M)
60780           PUSH    PSW             ;SAVE IT
60800           PUSH    H               ;SAVE POINTER TO EXPONENT
60820           MVI     A,100           ;SET EXPONENT OF SCALED DOWN NUMBER
60840           RAL
60860           MOV     M,A             ;REPLACE IT
60880           LXI     H,FBUFFR        ;SAVE A
60900           CALL    MOVMF
60920           MVI     A,4             ;SET ITERATION COUNT
60940   SQR1:   PUSH    PSW             ;SAVE COUNT
60960           CALL    PUSHF           ;SAVE X(N)
60980           LXI     H,FBUFFR        ;COMPUTE A/X(N)
61000           CALL    MOVRM           ;GET A IN THE REGISTERS
61020           CALL    FDIV
61040           POPR
61060           CALL    FADD            ;ADD IN X(N)
61080           LXI     H,FHALF         ;DIVIDE BY 2
61100           CALL    FMULTS
61120           POP     PSW             ;GET COUNT
61140           DCR     A               ;ARE WE DONE?
61160           JNZ     SQR1            ;NO, DO MORE ITERATIONS
61180           POP     H               ;YES, SET EXPONENT OF ANSWER
61200           POP     PSW             ;GET SCALE FACTOR
61220           ADI     300             ;CONVERT TO AN EXPONENT
61240           ADD     M               ;ADD EXPONENT IN
61260           MOV     M,A             ;REPLACE EXPONENT
61280           RET>                    ;ALL DONE
61340   IFN     EXTFNC,<
61360           ;SUBROUTINE FOR PPWR, ATN
61380   PSHNEG: LXI     H,NEG           ;GET THE ADDRESS OF NEG
61400           XTHL                    ;SWITCH RET ADDR AND ADDR OF NEG
61420           PCHL                    ;RETURN, THE ADDRESS OF NEG IS ON THE STACK
61480           ;SQUARE ROOT FUNCTION
61500           ;WE USE SQR(X)=X^.5
61520   SQR:    CALL    PUSHF           ;SAVE ARG
61540           LXI     H,FHALF         ;GET 1/2
61560           CALL    MOVFM           ;  SQR(X)=X^0.5
61580   FPWRT:  POPR                    ;GET ARG IN REGISTERS, ENTRY TO FPWR IF
61600                                   ; ARGUMENT IS ON STACK.  FALL INTO FPWR
61660           ;EXPONENTIATION    ---    X^Y
61680           ;N.B.  0^0=1
61700           ;FIRST WE CHECK IF Y=0, IF SO, THE RESULT IS 1.
61720           ;NEXT, WE CHECK IF X=0, IF SO, THE RESULT IS 0.
61740           ;THEN WE CHECK IF X IS POSITIVE, IF NOT, WE CHECK THAT Y IS A
61760           ;NEGATIVE INTEGER, AND WHETHER IT IS EVEN OR ODD.  IF Y IS A NEGATIVE
61780           ;INTEGER, WE NEGATE X.  IF NOT, LOG WILL GIVE AN FC ERROR WHEN WE CALL
61800           ;IT.  IF X IS NEGATIVE AND Y IS ODD, WE PUSH THE ADDRESS OF NEG ON THE
61820           ;STACK SO WE WILL RETURN TO IT AND GET A NEGATIVE RESULT.  TO COMPUTE
61840           ;THE RESULT WE USE X^Y=EXP(Y*LOG(X))
61860   FPWR:   FSIGN                   ;SEE IF Y IS ZERO
61880           JZ      EXP             ;IT IS, RESULT IS ONE
61900           MOV     A,B             ;SEE IF X IS ZERO
61920           ORA     A
61940           JZ      ZERO0           ;IT IS, RESULT IS ZERO
61960           PUSHR                   ;SAVE X ON STACK
62980           MOV     A,C             ;CHECK THE SIGN OF X
62000           ORI     177             ;TURN THE ZERO FLAG OFF
62020           CALL    MOVRF           ;GET Y IN THE REGISTERS
62040           JP      FPWR1           ;NO PROBLEMS IF X IS POSITIVE
62060           PUSHR                   ;SAVE Y
62080           CALL    INT             ;SEE IF Y IS AN INTEGER
62100           POPR                    ;GET Y BACK
62120           PUSH    PSW             ;SAVE LO OF INT FOR EVEN AND ODD INFORMATION
62140           CALL    FCOMP           ;SEE IF WE HAVE AN INTEGER
62160           POP     H               ;GET EVEN-ODD INFORMATION
62180           MOV     A,H             ;PUT EVEN-ODD FLAG IN CARRY
62200           RAR
62220   FPWR1:  POP     H               ;GET X BACK IN FAC
62240           SHLD    FAC-1           ;STORE HO'S
62260           POP     H               ;GET LO'S OFF STACK
62280           SHLD    FACLO           ;STORE THEM IN FAC
62300           CC      PSHNEG          ;NEGATE NUMBER AT END IF Y WAS ODD
62320           CZ      NEG             ;NEGATE THE NEGATIVE NUMBER
62340   FPWR2:  PUSHR                   ;SAVE Y AGAIN
62360           CALL    LOG             ;COMPUTE  EXP(Y=LOG(X))
62380           POPR                    ;IF X WAS NEGATIVE AND Y NOT AN INTEGER THEN
62400           CALL    FMULT>          ; LOG WILL BLOW HIM OUT OF THE WATER
62420   ;       JMP     EXP
62440   PAGE
62460   SUBTTL  EXPONENTIAL FUNCTON
62480   IFN     EXTFNC,<
62500           ;WE FIRST SAVE THE ORIGINAL ARGUMENT AND MULTIPLY THE FAC BY LOG2(E)
62520           ;THE RESULT IS USED TO DETERMINE IF WE WILL GET OVERFLOW SINCE
62540           ;EXP(X)=2^(X=LOG2(E)) WHERE LOG2(E)=LOG(E) BASE 2. THEN WE SAVE THE
62560           ;INTEGER PART OF THIS TO SCALE THE ANSWER AT THE END, SINCE
62580           ;2^Y=2^INT(Y)*2^(Y-INT(Y)) AND 2*INT(Y) IS EASY TO COMPUTE.  SO WE
62600           ;NOW COMPUTE 2^(X*LOG2(E)-INT(X*LOG2(E))) BY
62620           ;P(LN(2)*(INT(X*LOG2(E))+1)-X) WHERE P IS AN APPROXIMATION
62640           ;POLYNOMIAL.  THE RESULT IS THEN SCALED BY THE POWER OF 2 WE
62660           ;PREVIOUSLY SAVED.
62680   EXP:    CALL    PUSHF           ;SAVE ARGUMENT
62700           MOVRI   201,070,252,073 ;GET LOG(E) BASE 2,   CALCULATE:
62720           CALL    FMULT           ;   INT(ARG/LN(2)) = INT(ARG*LOG2(E))
62740           LDA     FAC             ;CARRY=0 IF FAC IS TOO BIG
62760           CPI     210             ; I.E. IF ABS(FAC) .GE. 128
62780           JNC     MLDVEX          ;IT IS TOO BIG
62800           CALL    INT             ;IS ARGUMENT TOO BIG?
62820           ADI     200             ;CHECK FOR OVERFLOW
62840           ADI     2
62860           JC      MLDVEX          ;WE HAVE OVERFLOW!!
62880           PUSH    PSW             ;SAVE SCALE FACTOR
62900           LXI     H,FONE          ;ADD ONE TO THE NUMBER
62920           CALL    FADDS
62920           CALL    MULLN2          ;MULTIPLY BY LN(2)
62960           POP     PSW             ;GET SCALE FACTOR OFF STACK
62980           POPR                    ;GET ARGUMENT
63000           PUSH    PSW             ;;
63020           CALL    FSUB            ;;
63040           CALL    NEG             ;;
63060           LXI     H,EXPCON        ;;
63080           CALL    POLY            ;;
63100           LXI     D,$CODE         ;;
63120           POP     B               ;;
63140           MOV     C,D             ;;
63160           JMP     FMULT
63200           ;CONSTANTS FOR EXP
63220   EXPCON: 10      ;DEGREE
63240           100     ; -.0001413161
63260           056
63280           224
63300           164
63320           160     ; .001329882
63340           117
63360           056
63380           167
63400           156     ; -.00830136
63420           002
63440           210
63460           172
63480           346     ; .04165735
63500           240
63520           052
63540           174
63560           120     ; -.1666653
63580           252
63600           252
63620           176
63640           377     ; .4999999
63660           377
63680           177
63700           177
63720           000     ; -1.0
63740           000
64760           200
64780           201
63800           000     ; 1.0
63820           000
63840           000
63860           201>
63880   PAGE
63900   SUBTTL  POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR
63920   IFN     EXTFNC,<
63940           ;EVALUATE P(x^2)*X
63960           ;POINTER TO DEGREE+1 IS IN (HL)
63980           ;THE CONSTANTS FOLLOW THE DEGREE
64000           ;CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
64020           ;WE COMPUTE:
64040           ; C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
64060   POLYX:  CALL    PUSHF           ;SAVE X
64080           LXI     D,FMULTT        ;PUT ADDRESS OF FMULTT ON STACK
64100           PUSH    D               ; RETURN WE WILL MULTIPLY BY X
64120           PUSH    H               ;SAVE CONSTANT POINTER
64140           CALL    MOVRF           ;SQUARE X
64160           CALL    FMULT
64180           POP     H               ;GET CONSTANT POINTER
64200                                   ;FALL INTO POLY
64260           ;POLYNOMIAL EVALUATOR
64280           ;POINTER TO DEGREE+1 IS IN (HL), IT IS UPDATED
64300           ;THE CONSTANTS FOLLOW THE DEGREE
64320           ;CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
64340           ;WE COMPUTE:
64360           ; C0+C1*X+C2*C^2+C3*X^3+...+C(N-1)*X^(N-1)+C(N)*X^N
64380   POLY:   CALL    PUSHF           ;SAVE X
64400           MOV     A,M             ;GET DEGREE
64420           INX     H               ;INCREMENT POINTER TO FIRST CONSTANT
64440           CALL    MOVFM           ;MOVE FIRST CONSTANT TO FAC
64460           XWD     1000,006        ;"MVI   B" OVER NEXT BYTE
64480   POLY1:  POP     PSW             ;GET DEGREE
64500           POPR                    ;GET X
64520           DCR     A               ;ARE WE DONE?
64540           RZ                      ;YES, RETURN
64560           PUSHR                   ;NO, SAVE X
64580           PUSH    PSW             ;SAVE DEGREE
64600           PUSH    H               ;SAVE CONSTANT POINTER
64620           CALL    FMULT           ;EVALUATE THE POLY, MULTIPLY BY X
64640           POP     H               ;GET LOCATION OF CONSANTS
64660           CALL    MOVRM           ;GET CONSTANT
64680           PUSH    H               ;STORE LOCATION OF CONSTANTS SO FADD AND FMULT
64700           CALL    FADD            ; WILL NOT SCREW THEM UP, ADD IN CONSTANT
64720           POP     H               ;MOVE CONSTANT POINTER TO NEXT CONSTANT
64740           JMP     POLY1>          ;SEE IF DONE
64800           ;PSEUDO-RANDOM NUMBER GENERATOR
64820           ;IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED
64840           ;IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS STARTED
64860           ; USING THE ARGUMENT    ;;
64880           ;TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE, WE MULTIPLY THE
64900           ;PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT, AND ADD IN ANOTHER
64920           ;RANDOM CONSTANT.  THEN THE HO AND LO BYTES ARE SWITCHED, THE
64940           ;EXPONENT IS PUT WHERE IT WILL BE SHIFTED IN BY NORMAL, AND THE
64960           ;EXPONENT IN THE FAC SET TO 200 SO THE RESULT WILL BE LESS THAN 1.
64980           ;THIS IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
65000           ;THE HO AND LO BYTES WERE SWITCHED SO WE HAVE A RANDOM CHANCE OF
65020           ;GETTING A NUMBER LESS THAN OR GREATER THAN .5
65040   RND:
65060   IFN     LENGTH-2,<
65080           FSIGN>                  ;GET SIGN OF ARG
65100   IFE     LENGTH-2,<
65120           CALL    VSIGN           ;GET THE SIGN OF THE ARG
65140           PUSH    PSW             ;SAVE THE SIGN
65160           CM      FRCSNG          ;IF IT IS NEGATIVE, FORCE IT TO BE A SNG
65180           MVI     A,4             ; SINCE WE WILL USE IT
65200           STA     VALTYP          ;MAKE SURE THE RESULT IS "SINGLE PRECISION"
65220           POP     PSW>            ;GET THE SIGN BACK
65240           JM      RND1            ;START NEW SEQUENCE IF NEGATIVE
65260           LXI     H,RNDX          ;GET LAST NUMBER GENERATED
65280           CALL    MOVFM
65300           RZ                      ;RETURN LAST NUMBER GENERATED IF ZERO
65320   IFE     EXTFNC,<
65340           CALL    FMULTS>         ;MULTIPLY BY CONSTANT A
65360   IFN     EXTFNC,<
65380           CALL    MOVRM
65400           CALL    FMULT>
65420           MOVRI   150,050,261,106 ;ADD IN CONSTANT OF ORDER 2^(-24)
65440           CALL    FADD
65460   RND1:   CALL    MOVRF           ;SWITCH HO AND LO BYTES
65480           MOV     A,E             ;GET LO
65500           MOV     E,C             ;PUT HO IN LO BYTE
65520           MOV     C,A             ;PUT LO IN HO BYTE
65540           MVI     M,200           ;MAKE RESULT POSITIVE
65560           DCX     H               ;GET POINTER TO EXPONENT
65580           MOV     B,M             ;PUT EXPONENT IN OVERFLOW POSITION
65600           MVI     M,200           ;SET EXP SO RESULT WILL BE BETWEEN 0 AND 1
65620           CALL    NORMAL          ;NORMALIZE THE RESULT
65640           LXI     H,RNDX          ;SAVE RANDOM NUMBER GENERATED FOR NEXT
65660           JMP     MOVMF           ; TIME
65700           ;CONSTANTS AND STORAGE FOR RND
65720   RNDX:   122     ;LAST RANDOM NUMBER GENERATED, BETWEEN 0 AND 1
65740           307
65760           117
65780           200
65800           172     ;RANDOM NUMBER OF ORDER 2^24
65820           104
65840           065
65860           230
65880   PAGE
65900   SUBTTL  SINE, COSINE AND TANGENT FUNCTIONS
65920   IFN     EXTFNC,<
65940           ;COSINE FUNCTION
65960           ;IDEA:  USE COS(X)=SIN(X+PI/2)
65980   COS:    LXI     H,PI2           ;ADD PI/2 TO FAC
66000           CALL    FADDS>
66020                                   ;FALL INTO SIN
66080           ;SINE FUNCTION
66100           ;IDEA: USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV
66120           ;THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED BECAUSE
66140           ;SIN(X+2*PI)=SIN(X).  THEN THE ARGUMENT CAN BE COMPARED WITH PI/2 BY
66160           ;COMPARING THE RESULT OF THE DIVISION WITH PI/2/(2*PI)=1/4.
66180           ;IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS I OR IV.
66200           ;AN APPROXIMATION POLYNOMIAL IS THEN USED TO COMPUTE SIN(X).
66220   SIN:    CALL    PUSHF           ;DIVIDE FAC BY 2*PI
66240           MOVRI   203,111,017,333 ;AFTER DIVIDING BY 2*PI, RESULT IS
66260           CALL    MOVFR           ; BETWEEN 0 AND 1
66280           POPR
66300           CALL    FDIV
66320           CALL    PUSHF           ;DISREGARD INTEGER PART SINCE SIN
66340           CALL    INT             ; IS PERIODIC WITH PERIOD 2*PI
66360           POPR
66380           CALL    FSUB
66400   IFE     EXTFNC,<
66420           LXI     B,177*400+$CODE ;GET 1/4
66440           MOV     D,C
66460           MOV     E,C
66480           CALL    FSUB>
66500   IFN     EXTFNC,<
66520           LXI     H,FR4           ;SEE WHAT QUADRANT WE ARE IN
66540           CALL    FSUBS>
66560           FSIGN
66580           STC                     ;SEE EQUADRANT I FLAG
66600           JP      SIN1            ;FIRST QUADRANT, GET BACK ORIGINAL X
66620           CALL    FADDM           ;ADD 1/2
66640           FSIGN
66660           ORA     A               ;CLEAR CARRY
66680   SIN1:   PUSH    PSW             ;SAVE QUADRANT FLAG
66700           CP      NEG             ;NEGATE IF IN QUADRANTS I, II, OR III
66720   IFE     EXTFNC,<
66740           LXI     B,177*400+$CODE ;GET 1/4
66760           MOV     D,C
66780           MOV     E,C
67800           CALL    FADD>
67820   IFN     EXTFNC,<
67840           LXI     H,FR4           ;ADD 1/4.  IN QUADRANTS II, III
67860                                   ; USE THE IDENTITY: SIN(PI-X)=SIN(X)
67880                                   ;IN QUADRANT IV, USE THE IDENTITY:
67900           CALL    FADDS>          ;   SIN(X-2*2)=SIN(X)
67920           POP     PSW             ;GET QUADRANT FLAG
67940           CNC     NEG             ;NEGATE IF IN QUADRANTS II, III OR IV
66960   IFE     EXTFNC,<                ;EVALUATE APPROXIMATION POLYNOMIAL
66980           CALL    PUSHF           ;SAVE X
67000           CALL    MOVRF           ;SQUARE X
67020           CALL    FMULT
67040           CALL    PUSHF           ;SAVE X^W
67060           LXI     H,SINCON
67080           CALL    MOVFM           ;MOVE FIRST CONSTANT INTO FAC
67100           POPR                    ;GET X^2
67120           MVI     A,4             ;GET DEGREE
67140   POLY1:  PUSH    PSW             ;SAVE DEGREE
67160           PUSHR                   ;SAVE X^2
67180           PUSH    H               ;SAVE CONSTANT POINTER
67200           CALL    FMULT           ;EVALUATE THE POLY, MULTIPLY BY X^2
67220           POP     H               ;GET POINTER TO CONSTANTS
67240           CALL    MOVRM           ;GET CONSTANT
67260           PUSH    H               ;SAVE POINTER
67280           CALL    FADD            ;ADD IN CONSTANT
67300           POP     H               ;MOVE POINTER TO NEXT CONSTANT
67320           POPR                    ;GET X^2
67340           POP     PSW             ;GET DEGREE
67360           DCR     A               ;SEE IF DONE
67380           JNZ     POLY1           ;NO, DO NEXT TERM
67400           JMP     FMULTT>         ;MULTIPLY BY X AND WE ARE DONE
67420   IFN     EXTFNC,<
67440           LXI     H,SINCON        ;CALCUALTE THE SIN BY EVALUATING
67460           JMP     POLYX           ; THE APPROXIMATION POLYNOMIAL
67480           ;CONSTANTS FOR SIN, COS
67500   IFN     EXTFNC,<
67520   PI2:    333     ; PI/2
67540           017
67560           111
67580           201
67600   FR4:    000     ; 1/4
67620           000
67640           000
67660           177>
67680   SINCON:
67700   IFN     EXTFNC,<
67720           5>      ;DEGREE
67740           272     ; 39.701067
67760           327
67780           036
67800           206
67820           144     ; -76.57498
67840           046
67860           231
67880           207
67900           130     ; 81.60223
67920           064
67940           043
67960           207
67980           340     ; -41.34168
68000           135
68020           245
68040           206
68060           332     ; 6.283185
68080           017
68100           111
68120           203
68180   IFN     EXTFNC,<
68200           ;TANGENT FUNCTION
68220           ;TAN(X)=SIN(X)/COS(X)
68240   TAN:    CALL    PUSHF           ;SAVE ARG
68260           CALL    SIN             ;   TAN(X)=SIN(X)/COS(X)
68280           POP     B               ;GET X OFF STACK
68300           POP     H               ;PUSHF SMASHES (DE)
68320           CALL    PUSHF
68340           XCHG                    ;GET LO'S WHERE THEY BELONG
68360           CALL    MOVFR
68380           CALL    COS
68400           JMP     FDIVT>
68420   PAGE
68440   SUBTTL  ARCTANGENT FUNCTION
68460   IFN     EXTFNC,<
68480           ;IDEA: USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
68500           ;AN APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X)
68520   ATN:    FSIGN                   ;SEE IF ARG IS NEGATIVE
68540           CM      PSHNEG          ;IF ARG IS NEGATIVE, USE:
68560           CM      NEG             ;   ARCTAN(X)=-ARCTAN(-X)
68580           LDA     FAC             ;SEE IF FAC .GT. 1
68600           CPI     201
68620           JC      ATN2
68640           LXI     B,201*400+$CODE ;GET THE CONSTANT 1
68660           MOV     D,C
68680           MOV     E,C             ;COMPUTE RECIPROCAL TO USE THE IDENTITY:
68700           CALL    FDIV            ;  ARCTAN(X)=PI/2-ARCTAN(1/X)
68720           LXI     H,FSUBS         ;PUT FSUBS ON THE STACK SO WE WILL RETURN
68740           PUSH    H               ; TO IT AND SUBTRACT THE REULT FROM PI/2
68760   ATN2:   LXI     H,ATNCON        ;EVALUATE APPROXIMATION POLYNOMIAL
68780           CALL    POLYX
68800           LXI     H,PI2           ;GET POINTER TO PI/2 IN CASE WE HAVE TO
68820           RET                     ; SUBTRACT THE RESULT FROM PI/2
68860           ;CONSTANTS FOR ATN
68880   ATNCON: 11      ;DEGREE
68900           112     ; .002866226
68920           327
68940           073
68960           170
68980           002     ; -.01616574
69000           156
69020           204
69040           173
69060           376     ; .04290961
69080           301
69100           057
69120           174
69140           164     ; -.07528964
69160           061
69180           232
69200           175
69220           204     ; .1065626
69240           075
69260           132
69280           175
69300           310     ; -.142089
69320           177
69340           221
69360           176
69380           344     ; .1999355
69400           273
69420           114
69440           176
69460           154     ; -.3333315
69480           252
69500           252
69520           177
69540           000     ; 1.0
69560           000
69580           000
69600           201>
69620   PAGE
69640   SUBTTL  SYSTEM INITIALIZATION CODE
69660   RADIX   10              ;IN ALL NON-MATH PACKAGE CODE
69680   ;THIS IS THE SYSTEM INITIALIZATION CODE
69700   ;IT SHOULD BE LOADED AT THE END OF THE BASIC
69720   ;INTERPRETER
69760   INTERNAL        INIT
69800   EXTERNAL        CRDO,LINGET,QINLIN,READY,SCRTCH,STROUT,REASON,BUF
69820   EXTERNAL        SNERR,OMERR,ILLFUN
69860   FUNIO==<^D256*^O312>+^O40+$CODE
69880   INITSA: BLOCK   10
69900   INITAT: LXI     H,AUTTXT
69920           CALL    STROUT
69940   INIT:
69960   IFN     REALIO,<
69980           IN      1               ;IGNORE GARBAGE CHARACTER IN INTERFACE
70000           IN      ^D255           ;SEE WHAT KIND OF I/O HE IS
70020           ANI     ^O100           ;IS HE FUNNY TTY?
70040           JZ      NOTSIO
70060           LXI     H,FUNIO
70080           SHLD    CNLCA2##+2
70100           MVI     H,^O310
70120           SHLD    CNLCA3##+2
70140   IFN     LENGTH,<
70160           MVI     H,^O304         ;SUBSTITUE "CNZ"
70180           SHLD    CNLCA4##+2>
70200   FUNIO==$CODE+<^D256*^O312>+2
70220           LXI     H,FUNIO
70240           SHLD    CNLCA1##+2
70260   NOTSIO: IN      ^D255
70280           ANI     ^O40
70300           JZ     NOTPIO
70320   FUNIO==$CODE+<^D256*^O312>+2
70340           LXI     H,FUNIO
70360           SHLD    CNLCA2+2
70380           MVI     H,^O310
70400           SHLD    CNLCA3+2
70420   IFN     LENGTH,<
70440           MVI     H,^O304
70460           SHLD    CNLCA4+2>
70480   FUNIO==$CODE+<^D256*^O312>+1
70500           LXI     H,FUNIO
70520           SHLD    CNLCA+2
70540   NOTPIO:>
70560           LXI     H,$CODE+^D65535
70580           SHLD    CURLIN##        ;IN CASE OF ERROR
70600           LXI     H,TSTACK        ;SET UP TEMP STACK
70620           SPHL
70640           SHLD    STKTOP##
70660   IFN     CONTRW,<
70680           XRA     A
70700           STA     CNTWFL##>
70720           CALL    CRDO            ;TYPE A CR
70740   IFN     STRING,<
70760           LXI     H,TEMPST##
70780           SHLD    TEMPPT##>
70800   IFN     REALIO,<
70820           LXI     H,MEMORY        ;ASK HOW MUCH MEMORY AVAILABLE
70840           CALL    STROUT          ;CALL THE STRING PRINTER
70860           CALL    QINLIN          ;GET A LINE OF INPUT
70880           CHRGET                  ;GET A CHAR
70900           CPI     "A"
70920           JZ      INITAT
70940           ORA     A
70960           JNZ     USEDE9          ;NON ZERO, DONT USE DEFAULT
70980           LXI     H,LASTWR
71000   LOOPMM: INX     H
71020           MVI     A,311
71040           MOV     M,A
71060           CMP     M
71080           JNZ     USEDEF
71100           DCR     A
71120           MOV     M,A
71140           CMP     M
71160           JZ      LOOPMM
71180           JMP     USEDEF
71200   USEDE9: LXI     H,BUF
71220           CALL    LINGET          ;GET DECIMAL AMOUNT OF MEMORY IN [D,E]
71240           ORA     A
71260           JNZ     SNERR           ;MAKE SURE HE HAS A TERMINATOR
71280           XCHG
71300           DCX     H
71320   USEDEF: DCX     H>
71340   IFE     REALIO,<
71360           LXI     H,$CODE+16190>
71380           PUSH    H               ;ALSO SAVE FOR LATER
71400   TTYW:   LXI     H,TTYWID
71420           CALL    STDOUT
71440           CALL    QINLIN
71460           CHRGET
71480           ORA     A
71500           JZ      DFLENT
71520           LXI     H,BUF
71540           CALL    LINGET
71560           MOV     A,D
71580           ORA     A
71600           JNZ     TTYW
71620           MOV     A,E
71640           CPI     16
71660           JC      TTYW
71680           STA     LINPT1##        ;DECLARE LINPT1 EXTERNAL
71700   IFN     LENGTH,<
71720           STA     LINPT2##
71740   IFN     STRING,<
71760           STA     LINPT3##>
71780   MORCPS: SUI     14
71800           JNC     MORCPS
71820           ADI     28
71940           CMA
71960           INR     A
71980           ADD     E
71900           STA     LINPT4##
71920   DFLENT:
71940   IFN     STRING,<                ;SET UP DEFAULT STRING SPACE
71960           LXI     D,$CODE+^D65536-^D50+1
71980           POP     H
72000           SHLD    MEMSIZ##        ;SAVE IN REAL MEMORY SIZE
72020           SHLD    FRETOP##        ;STRINGS START FROM HERE DOWN
72040           DAD     D               ;CALC STRBOT BY SUBTRACTING 200 FROM STKTOP
72060           JNC     OMERR           ;MUST BE POSITIVE
72080           DCX     H               ;ONE LOWER IS STKTOP
72100           PUSH    H>              ;SAVE IT ON STACK
72120   IFE     EXTFNC,<
72140
72160   ; FUNCTION DELETION ROUTINE FOR 4K MACHINE
72180   ; TO ADD A NEW FUNCTION JUST UPDATE TBLDO
72200
72220   ASKAGN: LXI     H,TBLDO         ;START OF FUNCTION TABLE
72240   LOPASK: PUSHM                   ;PUT ON CANDIDATE FOR START OF FREE MEMORY
72260           LXI     D,TBDASK        ;DONE ASKING?
72280           COMPAR
72300           JZ      FINFUN          ;YES, GET FIRST FREE MEM LOC
72320                                   ;INTO [D,E] AND QUIT
72340           PUSHM                   ;PUT ON MESSAGE LOCATION
72360           XTHL                    ;[H,L]=MESSAGE POINTER
72380                                   ;POINTER INTO TBLDO GOES ON THE STACK
72400           CALL    STROUT          ;PRINT THE MESSAGE
72420           CALL    QINLIN          ;SEE WHAT HE HAS TO SAY
72440           CHRGET                  ;SEE WHAT THE FIRST CHARACTER OF INPUT WAS
72460           POP     H               ;POP OFF POINTER INTO TBLDO
72480           CPI     "Y"
72500   FINFUN: POP     D               ;POP OFF CANDIDATE FOR START OF
72520                                   ;FREE MEMORY
72540           JZ      HAVFNS          ;HE WANTS IT SO WE ARE DONE
72560           CPI     "N"             ;IF A BAD ANSWER
72580           JNZ     ASKAGN          ;MAKE HIM START OVER
72600           PUSHM                   ;PUSH ON FUNCTION CALL
72620                                   ;LOCATION THAT WE FIX UP
72640           XTML                    ;[H,L]=FIXUP PLACE
72660                                   ;POINTER INTO TBLDO GOES ON THE STACK
72680           LXI     D,ILLFUN        ;THIS IS WHAT WE STORE
72700           MOV     M,E
72720           INX     H
72740           MOV     M,D
72760           POP     H               ;GET TBLDO POINTER
72780           JMP     LOPASK>         ;GO ASK AGAIN FOR ANOTHER FUNCTION
72800   IFN     EXTFNC,<
72820   ASKAGN: LXI     H,FNS           ;ASK IF WANTS SIN, COS, ATN
72840           CALL    STROUT          ;THE STRING
72860           CALL    QINLIN
72880           CHRGET
72900           CPI     "Y"
72920           LXI     D,INITSA        ;ASSUME NOT DELETE ANY FNS
72940           JZ      HAVFNS          ;YUP.
72960           CPI     "A"
72980           JZ      OKCHAR
73000           CPI     "N"
73020           JNZ     ASKAGN
73040   OKCHAR: LXI     H,ILLFUN        ;MAKE SURE BOMBS IF TRIES TO CALL THEM
73060           LXI     D,ATN
73080           SHLD    ATNFIX##
73100           CPI     "A"             ;DELETE ATN BUT NOT SIN, COS?
73120           JZ      HAVFNS          ;TEST
73140           SHLD    COSFIN##
73160           SHLD    TANFIX##
73180           SHLD    SINFIX##
73200           LXI     D,COS>
73220   HAVFNS:                         ;TEXT ALWAYS PRECEDED BY ZERO
73240           XCHG                    ;PUT BOTTOM OF MEMORY IN [H,L]
73260           MVI     M,0             ;STORE IT
73280           INX     H               ;INCREMENT POINTER
73300           SHLD    TXTTAB##        ;SAVE BOTTOM OF MEMORY
73320           XTHL
73340           LXI     D,TSTACK
73360           COMPAR
73380           JC      OMERR
73400           POP     D
73420           SPHL
73440           SHLD    STKTOP
73460           XCHG
73480           CALL    REASON
73500           MOV     A,E             ;SUBTRACT VARTAB FROM STKTOP
73520           SUB     L               ;LOW PART
73540           MOV     L,A             ;
73560           MOV     A,D             ;HIGH PART
73580           SBB     H               ;
73600           MOV     H,A             ;LEAVE IN [B,C]
73620           LXI     B,$CODE+65520
74640           DAD     B
74660           CALL    CRDO            ;TYPE CRLF
73680           CALL    LINPRT          ;PRINT # OF BYTES FREE
73700           LXI     H,WORDS         ;TYPE THE HEADING
73720           CALL    STROUT          ;"ALTAIR BASIC VERSION-----"
73740           LXI     H,STROUT
73760           SHLD    REPINI##+1
73780           CALL    SCRTCH          ;NOW SET UP EVERYTHING ELSE
73800   IFN     LPTSW,<
73820           MVI     A,4
73840           OUT     2               ;CLEAR THE LPT
73860           XRA     A
73880           STA     PRTFLG##
73900           STA     LPTPOS##>
73920   IFE     CONSSW,<LXI     H,READY>
73940   IFN     CONSSW,<
73960           LXI     H,CONSDO##>
73980           SHLD    $CODE+2
74000           PCHL
74040   IFE     EXTFNC,<
74060   TBLDO:  ADR(INITSA)
74080           ADR(FNS)
74100           ADR(SINFIX)
74120           ADR(SIN)
74140           ADR(FN2)
74160           ADR(RNDFIX)
74180           ADR(RND)
74200           ADR(FNS3)
74220           ADR(SQRFIX)
74240           ADR(SQR)
74260   TBDASK:                         ;END OF ASK TABLE
74280   FNS:    DC"WANT SIN"
74300           0
74320   FNS2:   DC"WANT RND"
74340           0
74360   FNS3:   DC"WANT SQR"
74380           0>
74400   IFN     EXTFNC,<
74420   FNS:    DC"WANT SIN-COS-TAN-ATN"
74440           0>
74460   AUTTXT: ACRLF
74480           ^D10
74500           DC"WRITTEN BY BILL GATES & PAUL ALLEN & MONTE DAVIDOFF."
74520           ACRLF
74540           0
74580   TTYWID: DC"TERMINAL WIDTH"
74600           0
74620   WORDS:  DC" BYTES FREE"
74640           ACRLF
74660           ACRLF
74680           DC"ALTAIR BASIC VERSION 3.0"
74700           ACRLF
74720   IFE     LENGTH,<DC"[FOUR-K VERSION]">
74740   IFE     LENGTH-1,<DC"[EIGHT-K VERSION">
74760   IFE     LENGTH-2,<DC"[BIG VERSION]">
74780           ACRLF
74800           0
74840   MEMORY: DC"MEMORY SIZE"
74860           0
74880   LASTWR::                        ;LAST WORD OF SYSTEM CODE+1
74900           BLOCK   ^D30            ;SPACE FOR TEMP STACK
74920   TSTACK::
74940   IFE     LENGTH,<
74960           BLOCK   ^D13000>
74980   IFN     LENGTH,<
75000           BLOCK   ^D10000>
75020           .C2==:.P
75040   END
